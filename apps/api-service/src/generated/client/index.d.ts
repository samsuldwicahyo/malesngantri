/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Barbershop
 *
 */
export type Barbershop = $Result.DefaultSelection<Prisma.$BarbershopPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Barber
 *
 */
export type Barber = $Result.DefaultSelection<Prisma.$BarberPayload>;
/**
 * Model Service
 *
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>;
/**
 * Model BarberService
 *
 */
export type BarberService =
  $Result.DefaultSelection<Prisma.$BarberServicePayload>;
/**
 * Model Queue
 *
 */
export type Queue = $Result.DefaultSelection<Prisma.$QueuePayload>;
/**
 * Model QueueHistory
 *
 */
export type QueueHistory =
  $Result.DefaultSelection<Prisma.$QueueHistoryPayload>;
/**
 * Model Review
 *
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>;
/**
 * Model BarberSchedule
 *
 */
export type BarberSchedule =
  $Result.DefaultSelection<Prisma.$BarberSchedulePayload>;
/**
 * Model SubscriptionPlan
 *
 */
export type SubscriptionPlan =
  $Result.DefaultSelection<Prisma.$SubscriptionPlanPayload>;
/**
 * Model BarbershopSubscription
 *
 */
export type BarbershopSubscription =
  $Result.DefaultSelection<Prisma.$BarbershopSubscriptionPayload>;
/**
 * Model AnalyticsDaily
 *
 */
export type AnalyticsDaily =
  $Result.DefaultSelection<Prisma.$AnalyticsDailyPayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    SUPER_ADMIN: 'SUPER_ADMIN';
    ADMIN: 'ADMIN';
    BARBER: 'BARBER';
    CUSTOMER: 'CUSTOMER';
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const QueueStatus: {
    WAITING: 'WAITING';
    CALLED: 'CALLED';
    IN_PROGRESS: 'IN_PROGRESS';
    COMPLETED: 'COMPLETED';
    NO_SHOW: 'NO_SHOW';
    CANCELLED: 'CANCELLED';
    SKIPPED: 'SKIPPED';
  };

  export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus];

  export const BarberStatus: {
    AVAILABLE: 'AVAILABLE';
    BUSY: 'BUSY';
    ON_BREAK: 'ON_BREAK';
    OFFLINE: 'OFFLINE';
  };

  export type BarberStatus = (typeof BarberStatus)[keyof typeof BarberStatus];

  export const SubscriptionStatus: {
    ACTIVE: 'ACTIVE';
    SUSPENDED: 'SUSPENDED';
    CANCELLED: 'CANCELLED';
    EXPIRED: 'EXPIRED';
  };

  export type SubscriptionStatus =
    (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type QueueStatus = $Enums.QueueStatus;

export const QueueStatus: typeof $Enums.QueueStatus;

export type BarberStatus = $Enums.BarberStatus;

export const BarberStatus: typeof $Enums.BarberStatus;

export type SubscriptionStatus = $Enums.SubscriptionStatus;

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Barbershops
 * const barbershops = await prisma.barbershop.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Barbershops
   * const barbershops = await prisma.barbershop.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>,
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent,
    ) => void,
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(
    query: TemplateStringsArray | Prisma.Sql,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(
    query: string,
    ...values: any[]
  ): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P],
    options?: { isolationLevel?: Prisma.TransactionIsolationLevel },
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>,
    ) => $Utils.JsPromise<R>,
    options?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    },
  ): $Utils.JsPromise<R>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.barbershop`: Exposes CRUD operations for the **Barbershop** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Barbershops
   * const barbershops = await prisma.barbershop.findMany()
   * ```
   */
  get barbershop(): Prisma.BarbershopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barber`: Exposes CRUD operations for the **Barber** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Barbers
   * const barbers = await prisma.barber.findMany()
   * ```
   */
  get barber(): Prisma.BarberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Services
   * const services = await prisma.service.findMany()
   * ```
   */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barberService`: Exposes CRUD operations for the **BarberService** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more BarberServices
   * const barberServices = await prisma.barberService.findMany()
   * ```
   */
  get barberService(): Prisma.BarberServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queue`: Exposes CRUD operations for the **Queue** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Queues
   * const queues = await prisma.queue.findMany()
   * ```
   */
  get queue(): Prisma.QueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueHistory`: Exposes CRUD operations for the **QueueHistory** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more QueueHistories
   * const queueHistories = await prisma.queueHistory.findMany()
   * ```
   */
  get queueHistory(): Prisma.QueueHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Reviews
   * const reviews = await prisma.review.findMany()
   * ```
   */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.barberSchedule`: Exposes CRUD operations for the **BarberSchedule** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more BarberSchedules
   * const barberSchedules = await prisma.barberSchedule.findMany()
   * ```
   */
  get barberSchedule(): Prisma.BarberScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptionPlan`: Exposes CRUD operations for the **SubscriptionPlan** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more SubscriptionPlans
   * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
   * ```
   */
  get subscriptionPlan(): Prisma.SubscriptionPlanDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.barbershopSubscription`: Exposes CRUD operations for the **BarbershopSubscription** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more BarbershopSubscriptions
   * const barbershopSubscriptions = await prisma.barbershopSubscription.findMany()
   * ```
   */
  get barbershopSubscription(): Prisma.BarbershopSubscriptionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.analyticsDaily`: Exposes CRUD operations for the **AnalyticsDaily** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AnalyticsDailies
   * const analyticsDailies = await prisma.analyticsDaily.findMany()
   * ```
   */
  get analyticsDaily(): Prisma.AnalyticsDailyDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends bigint
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    Barbershop: 'Barbershop';
    User: 'User';
    Barber: 'Barber';
    Service: 'Service';
    BarberService: 'BarberService';
    Queue: 'Queue';
    QueueHistory: 'QueueHistory';
    Review: 'Review';
    BarberSchedule: 'BarberSchedule';
    SubscriptionPlan: 'SubscriptionPlan';
    BarbershopSubscription: 'BarbershopSubscription';
    AnalyticsDaily: 'AnalyticsDaily';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'barbershop'
        | 'user'
        | 'barber'
        | 'service'
        | 'barberService'
        | 'queue'
        | 'queueHistory'
        | 'review'
        | 'barberSchedule'
        | 'subscriptionPlan'
        | 'barbershopSubscription'
        | 'analyticsDaily';
      txIsolationLevel: Prisma.TransactionIsolationLevel;
    };
    model: {
      Barbershop: {
        payload: Prisma.$BarbershopPayload<ExtArgs>;
        fields: Prisma.BarbershopFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BarbershopFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BarbershopFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          findFirst: {
            args: Prisma.BarbershopFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BarbershopFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          findMany: {
            args: Prisma.BarbershopFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>[];
          };
          create: {
            args: Prisma.BarbershopCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          createMany: {
            args: Prisma.BarbershopCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BarbershopCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>[];
          };
          delete: {
            args: Prisma.BarbershopDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          update: {
            args: Prisma.BarbershopUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          deleteMany: {
            args: Prisma.BarbershopDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BarbershopUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BarbershopUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>[];
          };
          upsert: {
            args: Prisma.BarbershopUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopPayload>;
          };
          aggregate: {
            args: Prisma.BarbershopAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBarbershop>;
          };
          groupBy: {
            args: Prisma.BarbershopGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BarbershopGroupByOutputType>[];
          };
          count: {
            args: Prisma.BarbershopCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<BarbershopCountAggregateOutputType>
              | number;
          };
        };
      };
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      Barber: {
        payload: Prisma.$BarberPayload<ExtArgs>;
        fields: Prisma.BarberFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BarberFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BarberFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          findFirst: {
            args: Prisma.BarberFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BarberFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          findMany: {
            args: Prisma.BarberFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>[];
          };
          create: {
            args: Prisma.BarberCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          createMany: {
            args: Prisma.BarberCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BarberCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>[];
          };
          delete: {
            args: Prisma.BarberDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          update: {
            args: Prisma.BarberUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          deleteMany: {
            args: Prisma.BarberDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BarberUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BarberUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>[];
          };
          upsert: {
            args: Prisma.BarberUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberPayload>;
          };
          aggregate: {
            args: Prisma.BarberAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBarber>;
          };
          groupBy: {
            args: Prisma.BarberGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BarberGroupByOutputType>[];
          };
          count: {
            args: Prisma.BarberCountArgs<ExtArgs>;
            result: $Utils.Optional<BarberCountAggregateOutputType> | number;
          };
        };
      };
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>;
        fields: Prisma.ServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[];
          };
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>;
          };
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateService>;
          };
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>;
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number;
          };
        };
      };
      BarberService: {
        payload: Prisma.$BarberServicePayload<ExtArgs>;
        fields: Prisma.BarberServiceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BarberServiceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BarberServiceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          findFirst: {
            args: Prisma.BarberServiceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BarberServiceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          findMany: {
            args: Prisma.BarberServiceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>[];
          };
          create: {
            args: Prisma.BarberServiceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          createMany: {
            args: Prisma.BarberServiceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BarberServiceCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>[];
          };
          delete: {
            args: Prisma.BarberServiceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          update: {
            args: Prisma.BarberServiceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          deleteMany: {
            args: Prisma.BarberServiceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BarberServiceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BarberServiceUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>[];
          };
          upsert: {
            args: Prisma.BarberServiceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberServicePayload>;
          };
          aggregate: {
            args: Prisma.BarberServiceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBarberService>;
          };
          groupBy: {
            args: Prisma.BarberServiceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BarberServiceGroupByOutputType>[];
          };
          count: {
            args: Prisma.BarberServiceCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<BarberServiceCountAggregateOutputType>
              | number;
          };
        };
      };
      Queue: {
        payload: Prisma.$QueuePayload<ExtArgs>;
        fields: Prisma.QueueFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.QueueFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.QueueFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          findFirst: {
            args: Prisma.QueueFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.QueueFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          findMany: {
            args: Prisma.QueueFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[];
          };
          create: {
            args: Prisma.QueueCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          createMany: {
            args: Prisma.QueueCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.QueueCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[];
          };
          delete: {
            args: Prisma.QueueDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          update: {
            args: Prisma.QueueUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          deleteMany: {
            args: Prisma.QueueDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.QueueUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.QueueUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>[];
          };
          upsert: {
            args: Prisma.QueueUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueuePayload>;
          };
          aggregate: {
            args: Prisma.QueueAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQueue>;
          };
          groupBy: {
            args: Prisma.QueueGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QueueGroupByOutputType>[];
          };
          count: {
            args: Prisma.QueueCountArgs<ExtArgs>;
            result: $Utils.Optional<QueueCountAggregateOutputType> | number;
          };
        };
      };
      QueueHistory: {
        payload: Prisma.$QueueHistoryPayload<ExtArgs>;
        fields: Prisma.QueueHistoryFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.QueueHistoryFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.QueueHistoryFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          findFirst: {
            args: Prisma.QueueHistoryFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.QueueHistoryFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          findMany: {
            args: Prisma.QueueHistoryFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>[];
          };
          create: {
            args: Prisma.QueueHistoryCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          createMany: {
            args: Prisma.QueueHistoryCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.QueueHistoryCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>[];
          };
          delete: {
            args: Prisma.QueueHistoryDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          update: {
            args: Prisma.QueueHistoryUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          deleteMany: {
            args: Prisma.QueueHistoryDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.QueueHistoryUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.QueueHistoryUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>[];
          };
          upsert: {
            args: Prisma.QueueHistoryUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$QueueHistoryPayload>;
          };
          aggregate: {
            args: Prisma.QueueHistoryAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateQueueHistory>;
          };
          groupBy: {
            args: Prisma.QueueHistoryGroupByArgs<ExtArgs>;
            result: $Utils.Optional<QueueHistoryGroupByOutputType>[];
          };
          count: {
            args: Prisma.QueueHistoryCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<QueueHistoryCountAggregateOutputType>
              | number;
          };
        };
      };
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>;
        fields: Prisma.ReviewFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[];
          };
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>;
          };
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateReview>;
          };
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ReviewGroupByOutputType>[];
          };
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>;
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number;
          };
        };
      };
      BarberSchedule: {
        payload: Prisma.$BarberSchedulePayload<ExtArgs>;
        fields: Prisma.BarberScheduleFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BarberScheduleFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BarberScheduleFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          findFirst: {
            args: Prisma.BarberScheduleFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BarberScheduleFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          findMany: {
            args: Prisma.BarberScheduleFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>[];
          };
          create: {
            args: Prisma.BarberScheduleCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          createMany: {
            args: Prisma.BarberScheduleCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BarberScheduleCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>[];
          };
          delete: {
            args: Prisma.BarberScheduleDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          update: {
            args: Prisma.BarberScheduleUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          deleteMany: {
            args: Prisma.BarberScheduleDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BarberScheduleUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BarberScheduleUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>[];
          };
          upsert: {
            args: Prisma.BarberScheduleUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarberSchedulePayload>;
          };
          aggregate: {
            args: Prisma.BarberScheduleAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBarberSchedule>;
          };
          groupBy: {
            args: Prisma.BarberScheduleGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BarberScheduleGroupByOutputType>[];
          };
          count: {
            args: Prisma.BarberScheduleCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<BarberScheduleCountAggregateOutputType>
              | number;
          };
        };
      };
      SubscriptionPlan: {
        payload: Prisma.$SubscriptionPlanPayload<ExtArgs>;
        fields: Prisma.SubscriptionPlanFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.SubscriptionPlanFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          findFirst: {
            args: Prisma.SubscriptionPlanFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          findMany: {
            args: Prisma.SubscriptionPlanFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[];
          };
          create: {
            args: Prisma.SubscriptionPlanCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          createMany: {
            args: Prisma.SubscriptionPlanCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[];
          };
          delete: {
            args: Prisma.SubscriptionPlanDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          update: {
            args: Prisma.SubscriptionPlanUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          deleteMany: {
            args: Prisma.SubscriptionPlanDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.SubscriptionPlanUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>[];
          };
          upsert: {
            args: Prisma.SubscriptionPlanUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPlanPayload>;
          };
          aggregate: {
            args: Prisma.SubscriptionPlanAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateSubscriptionPlan>;
          };
          groupBy: {
            args: Prisma.SubscriptionPlanGroupByArgs<ExtArgs>;
            result: $Utils.Optional<SubscriptionPlanGroupByOutputType>[];
          };
          count: {
            args: Prisma.SubscriptionPlanCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<SubscriptionPlanCountAggregateOutputType>
              | number;
          };
        };
      };
      BarbershopSubscription: {
        payload: Prisma.$BarbershopSubscriptionPayload<ExtArgs>;
        fields: Prisma.BarbershopSubscriptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.BarbershopSubscriptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.BarbershopSubscriptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          findFirst: {
            args: Prisma.BarbershopSubscriptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.BarbershopSubscriptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          findMany: {
            args: Prisma.BarbershopSubscriptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>[];
          };
          create: {
            args: Prisma.BarbershopSubscriptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          createMany: {
            args: Prisma.BarbershopSubscriptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.BarbershopSubscriptionCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>[];
          };
          delete: {
            args: Prisma.BarbershopSubscriptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          update: {
            args: Prisma.BarbershopSubscriptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          deleteMany: {
            args: Prisma.BarbershopSubscriptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.BarbershopSubscriptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.BarbershopSubscriptionUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>[];
          };
          upsert: {
            args: Prisma.BarbershopSubscriptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$BarbershopSubscriptionPayload>;
          };
          aggregate: {
            args: Prisma.BarbershopSubscriptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateBarbershopSubscription>;
          };
          groupBy: {
            args: Prisma.BarbershopSubscriptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<BarbershopSubscriptionGroupByOutputType>[];
          };
          count: {
            args: Prisma.BarbershopSubscriptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<BarbershopSubscriptionCountAggregateOutputType>
              | number;
          };
        };
      };
      AnalyticsDaily: {
        payload: Prisma.$AnalyticsDailyPayload<ExtArgs>;
        fields: Prisma.AnalyticsDailyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnalyticsDailyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnalyticsDailyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          findFirst: {
            args: Prisma.AnalyticsDailyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnalyticsDailyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          findMany: {
            args: Prisma.AnalyticsDailyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>[];
          };
          create: {
            args: Prisma.AnalyticsDailyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          createMany: {
            args: Prisma.AnalyticsDailyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          createManyAndReturn: {
            args: Prisma.AnalyticsDailyCreateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>[];
          };
          delete: {
            args: Prisma.AnalyticsDailyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          update: {
            args: Prisma.AnalyticsDailyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          deleteMany: {
            args: Prisma.AnalyticsDailyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnalyticsDailyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateManyAndReturn: {
            args: Prisma.AnalyticsDailyUpdateManyAndReturnArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>[];
          };
          upsert: {
            args: Prisma.AnalyticsDailyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnalyticsDailyPayload>;
          };
          aggregate: {
            args: Prisma.AnalyticsDailyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnalyticsDaily>;
          };
          groupBy: {
            args: Prisma.AnalyticsDailyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnalyticsDailyGroupByOutputType>[];
          };
          count: {
            args: Prisma.AnalyticsDailyCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnalyticsDailyCountAggregateOutputType>
              | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
          result: any;
        };
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]];
          result: any;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
      isolationLevel?: Prisma.TransactionIsolationLevel;
    };
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null;
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    barbershop?: BarbershopOmit;
    user?: UserOmit;
    barber?: BarberOmit;
    service?: ServiceOmit;
    barberService?: BarberServiceOmit;
    queue?: QueueOmit;
    queueHistory?: QueueHistoryOmit;
    review?: ReviewOmit;
    barberSchedule?: BarberScheduleOmit;
    subscriptionPlan?: SubscriptionPlanOmit;
    barbershopSubscription?: BarbershopSubscriptionOmit;
    analyticsDaily?: AnalyticsDailyOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>,
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type BarbershopCountOutputType
   */

  export type BarbershopCountOutputType = {
    users: number;
    barbers: number;
    services: number;
    subscriptions: number;
    queues: number;
    reviews: number;
    analytics: number;
  };

  export type BarbershopCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | BarbershopCountOutputTypeCountUsersArgs;
    barbers?: boolean | BarbershopCountOutputTypeCountBarbersArgs;
    services?: boolean | BarbershopCountOutputTypeCountServicesArgs;
    subscriptions?: boolean | BarbershopCountOutputTypeCountSubscriptionsArgs;
    queues?: boolean | BarbershopCountOutputTypeCountQueuesArgs;
    reviews?: boolean | BarbershopCountOutputTypeCountReviewsArgs;
    analytics?: boolean | BarbershopCountOutputTypeCountAnalyticsArgs;
  };

  // Custom InputTypes
  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopCountOutputType
     */
    select?: BarbershopCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountUsersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountBarbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountSubscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarbershopSubscriptionWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountQueuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * BarbershopCountOutputType without action
   */
  export type BarbershopCountOutputTypeCountAnalyticsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnalyticsDailyWhereInput;
  };

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    queues: number;
    reviews: number;
    changedLogs: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    queues?: boolean | UserCountOutputTypeCountQueuesArgs;
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs;
    changedLogs?: boolean | UserCountOutputTypeCountChangedLogsArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQueuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChangedLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueHistoryWhereInput;
  };

  /**
   * Count Type BarberCountOutputType
   */

  export type BarberCountOutputType = {
    services: number;
    schedules: number;
    queues: number;
    reviews: number;
  };

  export type BarberCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    services?: boolean | BarberCountOutputTypeCountServicesArgs;
    schedules?: boolean | BarberCountOutputTypeCountSchedulesArgs;
    queues?: boolean | BarberCountOutputTypeCountQueuesArgs;
    reviews?: boolean | BarberCountOutputTypeCountReviewsArgs;
  };

  // Custom InputTypes
  /**
   * BarberCountOutputType without action
   */
  export type BarberCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberCountOutputType
     */
    select?: BarberCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * BarberCountOutputType without action
   */
  export type BarberCountOutputTypeCountServicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberServiceWhereInput;
  };

  /**
   * BarberCountOutputType without action
   */
  export type BarberCountOutputTypeCountSchedulesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberScheduleWhereInput;
  };

  /**
   * BarberCountOutputType without action
   */
  export type BarberCountOutputTypeCountQueuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueWhereInput;
  };

  /**
   * BarberCountOutputType without action
   */
  export type BarberCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    barbers: number;
    queues: number;
  };

  export type ServiceCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbers?: boolean | ServiceCountOutputTypeCountBarbersArgs;
    queues?: boolean | ServiceCountOutputTypeCountQueuesArgs;
  };

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountBarbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberServiceWhereInput;
  };

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountQueuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueWhereInput;
  };

  /**
   * Count Type QueueCountOutputType
   */

  export type QueueCountOutputType = {
    history: number;
    reviews: number;
  };

  export type QueueCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    history?: boolean | QueueCountOutputTypeCountHistoryArgs;
    reviews?: boolean | QueueCountOutputTypeCountReviewsArgs;
  };

  // Custom InputTypes
  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueCountOutputType
     */
    select?: QueueCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountHistoryArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueHistoryWhereInput;
  };

  /**
   * QueueCountOutputType without action
   */
  export type QueueCountOutputTypeCountReviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model Barbershop
   */

  export type AggregateBarbershop = {
    _count: BarbershopCountAggregateOutputType | null;
    _min: BarbershopMinAggregateOutputType | null;
    _max: BarbershopMaxAggregateOutputType | null;
  };

  export type BarbershopMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    address: string | null;
    logoUrl: string | null;
    timezone: string | null;
    subscriptionStatus: $Enums.SubscriptionStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type BarbershopMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    slug: string | null;
    address: string | null;
    logoUrl: string | null;
    timezone: string | null;
    subscriptionStatus: $Enums.SubscriptionStatus | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type BarbershopCountAggregateOutputType = {
    id: number;
    name: number;
    slug: number;
    address: number;
    logoUrl: number;
    timezone: number;
    subscriptionStatus: number;
    settings: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type BarbershopMinAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    address?: true;
    logoUrl?: true;
    timezone?: true;
    subscriptionStatus?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type BarbershopMaxAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    address?: true;
    logoUrl?: true;
    timezone?: true;
    subscriptionStatus?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type BarbershopCountAggregateInputType = {
    id?: true;
    name?: true;
    slug?: true;
    address?: true;
    logoUrl?: true;
    timezone?: true;
    subscriptionStatus?: true;
    settings?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type BarbershopAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Barbershop to aggregate.
     */
    where?: BarbershopWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbershops to fetch.
     */
    orderBy?:
      | BarbershopOrderByWithRelationInput
      | BarbershopOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BarbershopWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbershops from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbershops.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Barbershops
     **/
    _count?: true | BarbershopCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BarbershopMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BarbershopMaxAggregateInputType;
  };

  export type GetBarbershopAggregateType<T extends BarbershopAggregateArgs> = {
    [P in keyof T & keyof AggregateBarbershop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarbershop[P]>
      : GetScalarType<T[P], AggregateBarbershop[P]>;
  };

  export type BarbershopGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarbershopWhereInput;
    orderBy?:
      | BarbershopOrderByWithAggregationInput
      | BarbershopOrderByWithAggregationInput[];
    by: BarbershopScalarFieldEnum[] | BarbershopScalarFieldEnum;
    having?: BarbershopScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BarbershopCountAggregateInputType | true;
    _min?: BarbershopMinAggregateInputType;
    _max?: BarbershopMaxAggregateInputType;
  };

  export type BarbershopGroupByOutputType = {
    id: string;
    name: string;
    slug: string;
    address: string | null;
    logoUrl: string | null;
    timezone: string;
    subscriptionStatus: $Enums.SubscriptionStatus;
    settings: JsonValue;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: BarbershopCountAggregateOutputType | null;
    _min: BarbershopMinAggregateOutputType | null;
    _max: BarbershopMaxAggregateOutputType | null;
  };

  type GetBarbershopGroupByPayload<T extends BarbershopGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BarbershopGroupByOutputType, T['by']> & {
          [P in keyof T & keyof BarbershopGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarbershopGroupByOutputType[P]>
            : GetScalarType<T[P], BarbershopGroupByOutputType[P]>;
        }
      >
    >;

  export type BarbershopSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      address?: boolean;
      logoUrl?: boolean;
      timezone?: boolean;
      subscriptionStatus?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      users?: boolean | Barbershop$usersArgs<ExtArgs>;
      barbers?: boolean | Barbershop$barbersArgs<ExtArgs>;
      services?: boolean | Barbershop$servicesArgs<ExtArgs>;
      subscriptions?: boolean | Barbershop$subscriptionsArgs<ExtArgs>;
      queues?: boolean | Barbershop$queuesArgs<ExtArgs>;
      reviews?: boolean | Barbershop$reviewsArgs<ExtArgs>;
      analytics?: boolean | Barbershop$analyticsArgs<ExtArgs>;
      _count?: boolean | BarbershopCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barbershop']
  >;

  export type BarbershopSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      address?: boolean;
      logoUrl?: boolean;
      timezone?: boolean;
      subscriptionStatus?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['barbershop']
  >;

  export type BarbershopSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      slug?: boolean;
      address?: boolean;
      logoUrl?: boolean;
      timezone?: boolean;
      subscriptionStatus?: boolean;
      settings?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
    },
    ExtArgs['result']['barbershop']
  >;

  export type BarbershopSelectScalar = {
    id?: boolean;
    name?: boolean;
    slug?: boolean;
    address?: boolean;
    logoUrl?: boolean;
    timezone?: boolean;
    subscriptionStatus?: boolean;
    settings?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type BarbershopOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'slug'
    | 'address'
    | 'logoUrl'
    | 'timezone'
    | 'subscriptionStatus'
    | 'settings'
    | 'createdAt'
    | 'updatedAt'
    | 'deletedAt',
    ExtArgs['result']['barbershop']
  >;
  export type BarbershopInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    users?: boolean | Barbershop$usersArgs<ExtArgs>;
    barbers?: boolean | Barbershop$barbersArgs<ExtArgs>;
    services?: boolean | Barbershop$servicesArgs<ExtArgs>;
    subscriptions?: boolean | Barbershop$subscriptionsArgs<ExtArgs>;
    queues?: boolean | Barbershop$queuesArgs<ExtArgs>;
    reviews?: boolean | Barbershop$reviewsArgs<ExtArgs>;
    analytics?: boolean | Barbershop$analyticsArgs<ExtArgs>;
    _count?: boolean | BarbershopCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type BarbershopIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};
  export type BarbershopIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {};

  export type $BarbershopPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Barbershop';
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[];
      barbers: Prisma.$BarberPayload<ExtArgs>[];
      services: Prisma.$ServicePayload<ExtArgs>[];
      subscriptions: Prisma.$BarbershopSubscriptionPayload<ExtArgs>[];
      queues: Prisma.$QueuePayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
      analytics: Prisma.$AnalyticsDailyPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        slug: string;
        address: string | null;
        logoUrl: string | null;
        timezone: string;
        subscriptionStatus: $Enums.SubscriptionStatus;
        settings: Prisma.JsonValue;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['barbershop']
    >;
    composites: {};
  };

  type BarbershopGetPayload<
    S extends boolean | null | undefined | BarbershopDefaultArgs,
  > = $Result.GetResult<Prisma.$BarbershopPayload, S>;

  type BarbershopCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    BarbershopFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: BarbershopCountAggregateInputType | true;
  };

  export interface BarbershopDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Barbershop'];
      meta: { name: 'Barbershop' };
    };
    /**
     * Find zero or one Barbershop that matches the filter.
     * @param {BarbershopFindUniqueArgs} args - Arguments to find a Barbershop
     * @example
     * // Get one Barbershop
     * const barbershop = await prisma.barbershop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarbershopFindUniqueArgs>(
      args: SelectSubset<T, BarbershopFindUniqueArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Barbershop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarbershopFindUniqueOrThrowArgs} args - Arguments to find a Barbershop
     * @example
     * // Get one Barbershop
     * const barbershop = await prisma.barbershop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarbershopFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BarbershopFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Barbershop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopFindFirstArgs} args - Arguments to find a Barbershop
     * @example
     * // Get one Barbershop
     * const barbershop = await prisma.barbershop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarbershopFindFirstArgs>(
      args?: SelectSubset<T, BarbershopFindFirstArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Barbershop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopFindFirstOrThrowArgs} args - Arguments to find a Barbershop
     * @example
     * // Get one Barbershop
     * const barbershop = await prisma.barbershop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarbershopFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BarbershopFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Barbershops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barbershops
     * const barbershops = await prisma.barbershop.findMany()
     *
     * // Get first 10 Barbershops
     * const barbershops = await prisma.barbershop.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const barbershopWithIdOnly = await prisma.barbershop.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BarbershopFindManyArgs>(
      args?: SelectSubset<T, BarbershopFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Barbershop.
     * @param {BarbershopCreateArgs} args - Arguments to create a Barbershop.
     * @example
     * // Create one Barbershop
     * const Barbershop = await prisma.barbershop.create({
     *   data: {
     *     // ... data to create a Barbershop
     *   }
     * })
     *
     */
    create<T extends BarbershopCreateArgs>(
      args: SelectSubset<T, BarbershopCreateArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Barbershops.
     * @param {BarbershopCreateManyArgs} args - Arguments to create many Barbershops.
     * @example
     * // Create many Barbershops
     * const barbershop = await prisma.barbershop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BarbershopCreateManyArgs>(
      args?: SelectSubset<T, BarbershopCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Barbershops and returns the data saved in the database.
     * @param {BarbershopCreateManyAndReturnArgs} args - Arguments to create many Barbershops.
     * @example
     * // Create many Barbershops
     * const barbershop = await prisma.barbershop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Barbershops and only return the `id`
     * const barbershopWithIdOnly = await prisma.barbershop.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BarbershopCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BarbershopCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Barbershop.
     * @param {BarbershopDeleteArgs} args - Arguments to delete one Barbershop.
     * @example
     * // Delete one Barbershop
     * const Barbershop = await prisma.barbershop.delete({
     *   where: {
     *     // ... filter to delete one Barbershop
     *   }
     * })
     *
     */
    delete<T extends BarbershopDeleteArgs>(
      args: SelectSubset<T, BarbershopDeleteArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Barbershop.
     * @param {BarbershopUpdateArgs} args - Arguments to update one Barbershop.
     * @example
     * // Update one Barbershop
     * const barbershop = await prisma.barbershop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BarbershopUpdateArgs>(
      args: SelectSubset<T, BarbershopUpdateArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Barbershops.
     * @param {BarbershopDeleteManyArgs} args - Arguments to filter Barbershops to delete.
     * @example
     * // Delete a few Barbershops
     * const { count } = await prisma.barbershop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BarbershopDeleteManyArgs>(
      args?: SelectSubset<T, BarbershopDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Barbershops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barbershops
     * const barbershop = await prisma.barbershop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BarbershopUpdateManyArgs>(
      args: SelectSubset<T, BarbershopUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Barbershops and returns the data updated in the database.
     * @param {BarbershopUpdateManyAndReturnArgs} args - Arguments to update many Barbershops.
     * @example
     * // Update many Barbershops
     * const barbershop = await prisma.barbershop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Barbershops and only return the `id`
     * const barbershopWithIdOnly = await prisma.barbershop.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BarbershopUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BarbershopUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Barbershop.
     * @param {BarbershopUpsertArgs} args - Arguments to update or create a Barbershop.
     * @example
     * // Update or create a Barbershop
     * const barbershop = await prisma.barbershop.upsert({
     *   create: {
     *     // ... data to create a Barbershop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barbershop we want to update
     *   }
     * })
     */
    upsert<T extends BarbershopUpsertArgs>(
      args: SelectSubset<T, BarbershopUpsertArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Barbershops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopCountArgs} args - Arguments to filter Barbershops to count.
     * @example
     * // Count the number of Barbershops
     * const count = await prisma.barbershop.count({
     *   where: {
     *     // ... the filter for the Barbershops we want to count
     *   }
     * })
     **/
    count<T extends BarbershopCountArgs>(
      args?: Subset<T, BarbershopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarbershopCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Barbershop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BarbershopAggregateArgs>(
      args: Subset<T, BarbershopAggregateArgs>,
    ): Prisma.PrismaPromise<GetBarbershopAggregateType<T>>;

    /**
     * Group by Barbershop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BarbershopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarbershopGroupByArgs['orderBy'] }
        : { orderBy?: BarbershopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BarbershopGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetBarbershopGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Barbershop model
     */
    readonly fields: BarbershopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Barbershop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarbershopClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    users<T extends Barbershop$usersArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$usersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    barbers<T extends Barbershop$barbersArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$barbersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BarberPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    services<T extends Barbershop$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$servicesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    subscriptions<T extends Barbershop$subscriptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$subscriptionsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    queues<T extends Barbershop$queuesArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$queuesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends Barbershop$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    analytics<T extends Barbershop$analyticsArgs<ExtArgs> = {}>(
      args?: Subset<T, Barbershop$analyticsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnalyticsDailyPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Barbershop model
   */
  interface BarbershopFieldRefs {
    readonly id: FieldRef<'Barbershop', 'String'>;
    readonly name: FieldRef<'Barbershop', 'String'>;
    readonly slug: FieldRef<'Barbershop', 'String'>;
    readonly address: FieldRef<'Barbershop', 'String'>;
    readonly logoUrl: FieldRef<'Barbershop', 'String'>;
    readonly timezone: FieldRef<'Barbershop', 'String'>;
    readonly subscriptionStatus: FieldRef<'Barbershop', 'SubscriptionStatus'>;
    readonly settings: FieldRef<'Barbershop', 'Json'>;
    readonly createdAt: FieldRef<'Barbershop', 'DateTime'>;
    readonly updatedAt: FieldRef<'Barbershop', 'DateTime'>;
    readonly deletedAt: FieldRef<'Barbershop', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Barbershop findUnique
   */
  export type BarbershopFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter, which Barbershop to fetch.
     */
    where: BarbershopWhereUniqueInput;
  };

  /**
   * Barbershop findUniqueOrThrow
   */
  export type BarbershopFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter, which Barbershop to fetch.
     */
    where: BarbershopWhereUniqueInput;
  };

  /**
   * Barbershop findFirst
   */
  export type BarbershopFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter, which Barbershop to fetch.
     */
    where?: BarbershopWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbershops to fetch.
     */
    orderBy?:
      | BarbershopOrderByWithRelationInput
      | BarbershopOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Barbershops.
     */
    cursor?: BarbershopWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbershops from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbershops.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Barbershops.
     */
    distinct?: BarbershopScalarFieldEnum | BarbershopScalarFieldEnum[];
  };

  /**
   * Barbershop findFirstOrThrow
   */
  export type BarbershopFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter, which Barbershop to fetch.
     */
    where?: BarbershopWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbershops to fetch.
     */
    orderBy?:
      | BarbershopOrderByWithRelationInput
      | BarbershopOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Barbershops.
     */
    cursor?: BarbershopWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbershops from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbershops.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Barbershops.
     */
    distinct?: BarbershopScalarFieldEnum | BarbershopScalarFieldEnum[];
  };

  /**
   * Barbershop findMany
   */
  export type BarbershopFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter, which Barbershops to fetch.
     */
    where?: BarbershopWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbershops to fetch.
     */
    orderBy?:
      | BarbershopOrderByWithRelationInput
      | BarbershopOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Barbershops.
     */
    cursor?: BarbershopWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbershops from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbershops.
     */
    skip?: number;
    distinct?: BarbershopScalarFieldEnum | BarbershopScalarFieldEnum[];
  };

  /**
   * Barbershop create
   */
  export type BarbershopCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * The data needed to create a Barbershop.
     */
    data: XOR<BarbershopCreateInput, BarbershopUncheckedCreateInput>;
  };

  /**
   * Barbershop createMany
   */
  export type BarbershopCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Barbershops.
     */
    data: BarbershopCreateManyInput | BarbershopCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Barbershop createManyAndReturn
   */
  export type BarbershopCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * The data used to create many Barbershops.
     */
    data: BarbershopCreateManyInput | BarbershopCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Barbershop update
   */
  export type BarbershopUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * The data needed to update a Barbershop.
     */
    data: XOR<BarbershopUpdateInput, BarbershopUncheckedUpdateInput>;
    /**
     * Choose, which Barbershop to update.
     */
    where: BarbershopWhereUniqueInput;
  };

  /**
   * Barbershop updateMany
   */
  export type BarbershopUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Barbershops.
     */
    data: XOR<
      BarbershopUpdateManyMutationInput,
      BarbershopUncheckedUpdateManyInput
    >;
    /**
     * Filter which Barbershops to update
     */
    where?: BarbershopWhereInput;
    /**
     * Limit how many Barbershops to update.
     */
    limit?: number;
  };

  /**
   * Barbershop updateManyAndReturn
   */
  export type BarbershopUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * The data used to update Barbershops.
     */
    data: XOR<
      BarbershopUpdateManyMutationInput,
      BarbershopUncheckedUpdateManyInput
    >;
    /**
     * Filter which Barbershops to update
     */
    where?: BarbershopWhereInput;
    /**
     * Limit how many Barbershops to update.
     */
    limit?: number;
  };

  /**
   * Barbershop upsert
   */
  export type BarbershopUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * The filter to search for the Barbershop to update in case it exists.
     */
    where: BarbershopWhereUniqueInput;
    /**
     * In case the Barbershop found by the `where` argument doesn't exist, create a new Barbershop with this data.
     */
    create: XOR<BarbershopCreateInput, BarbershopUncheckedCreateInput>;
    /**
     * In case the Barbershop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarbershopUpdateInput, BarbershopUncheckedUpdateInput>;
  };

  /**
   * Barbershop delete
   */
  export type BarbershopDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    /**
     * Filter which Barbershop to delete.
     */
    where: BarbershopWhereUniqueInput;
  };

  /**
   * Barbershop deleteMany
   */
  export type BarbershopDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Barbershops to delete
     */
    where?: BarbershopWhereInput;
    /**
     * Limit how many Barbershops to delete.
     */
    limit?: number;
  };

  /**
   * Barbershop.users
   */
  export type Barbershop$usersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * Barbershop.barbers
   */
  export type Barbershop$barbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    where?: BarberWhereInput;
    orderBy?: BarberOrderByWithRelationInput | BarberOrderByWithRelationInput[];
    cursor?: BarberWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BarberScalarFieldEnum | BarberScalarFieldEnum[];
  };

  /**
   * Barbershop.services
   */
  export type Barbershop$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    where?: ServiceWhereInput;
    orderBy?:
      | ServiceOrderByWithRelationInput
      | ServiceOrderByWithRelationInput[];
    cursor?: ServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Barbershop.subscriptions
   */
  export type Barbershop$subscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    where?: BarbershopSubscriptionWhereInput;
    orderBy?:
      | BarbershopSubscriptionOrderByWithRelationInput
      | BarbershopSubscriptionOrderByWithRelationInput[];
    cursor?: BarbershopSubscriptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | BarbershopSubscriptionScalarFieldEnum
      | BarbershopSubscriptionScalarFieldEnum[];
  };

  /**
   * Barbershop.queues
   */
  export type Barbershop$queuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    where?: QueueWhereInput;
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    cursor?: QueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Barbershop.reviews
   */
  export type Barbershop$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Barbershop.analytics
   */
  export type Barbershop$analyticsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    where?: AnalyticsDailyWhereInput;
    orderBy?:
      | AnalyticsDailyOrderByWithRelationInput
      | AnalyticsDailyOrderByWithRelationInput[];
    cursor?: AnalyticsDailyWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnalyticsDailyScalarFieldEnum | AnalyticsDailyScalarFieldEnum[];
  };

  /**
   * Barbershop without action
   */
  export type BarbershopDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
  };

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    fullName: string | null;
    email: string | null;
    phoneNumber: string | null;
    passwordHash: string | null;
    role: $Enums.UserRole | null;
    fcmToken: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    fullName: string | null;
    email: string | null;
    phoneNumber: string | null;
    passwordHash: string | null;
    role: $Enums.UserRole | null;
    fcmToken: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    fullName: number;
    email: number;
    phoneNumber: number;
    passwordHash: number;
    role: number;
    fcmToken: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    fullName?: true;
    email?: true;
    phoneNumber?: true;
    passwordHash?: true;
    role?: true;
    fcmToken?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    fullName?: true;
    email?: true;
    phoneNumber?: true;
    passwordHash?: true;
    role?: true;
    fcmToken?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    fullName?: true;
    email?: true;
    phoneNumber?: true;
    passwordHash?: true;
    role?: true;
    fcmToken?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    barbershopId: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken: string | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      fullName?: boolean;
      email?: boolean;
      phoneNumber?: boolean;
      passwordHash?: boolean;
      role?: boolean;
      fcmToken?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | User$barbershopArgs<ExtArgs>;
      barberInfo?: boolean | User$barberInfoArgs<ExtArgs>;
      queues?: boolean | User$queuesArgs<ExtArgs>;
      reviews?: boolean | User$reviewsArgs<ExtArgs>;
      changedLogs?: boolean | User$changedLogsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      fullName?: boolean;
      email?: boolean;
      phoneNumber?: boolean;
      passwordHash?: boolean;
      role?: boolean;
      fcmToken?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | User$barbershopArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      fullName?: boolean;
      email?: boolean;
      phoneNumber?: boolean;
      passwordHash?: boolean;
      role?: boolean;
      fcmToken?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | User$barbershopArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    fullName?: boolean;
    email?: boolean;
    phoneNumber?: boolean;
    passwordHash?: boolean;
    role?: boolean;
    fcmToken?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'fullName'
    | 'email'
    | 'phoneNumber'
    | 'passwordHash'
    | 'role'
    | 'fcmToken'
    | 'createdAt'
    | 'updatedAt'
    | 'deletedAt',
    ExtArgs['result']['user']
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | User$barbershopArgs<ExtArgs>;
    barberInfo?: boolean | User$barberInfoArgs<ExtArgs>;
    queues?: boolean | User$queuesArgs<ExtArgs>;
    reviews?: boolean | User$reviewsArgs<ExtArgs>;
    changedLogs?: boolean | User$changedLogsArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type UserIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | User$barbershopArgs<ExtArgs>;
  };
  export type UserIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | User$barbershopArgs<ExtArgs>;
  };

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'User';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs> | null;
      barberInfo: Prisma.$BarberPayload<ExtArgs> | null;
      queues: Prisma.$QueuePayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
      changedLogs: Prisma.$QueueHistoryPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string | null;
        fullName: string;
        email: string;
        phoneNumber: string;
        passwordHash: string;
        role: $Enums.UserRole;
        fcmToken: string | null;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
      args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
      args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>,
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends User$barbershopArgs<ExtArgs> = {}>(
      args?: Subset<T, User$barbershopArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      $Result.GetResult<
        Prisma.$BarbershopPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    barberInfo<T extends User$barberInfoArgs<ExtArgs> = {}>(
      args?: Subset<T, User$barberInfoArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    queues<T extends User$queuesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$queuesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    changedLogs<T extends User$changedLogsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$changedLogsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueueHistoryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly barbershopId: FieldRef<'User', 'String'>;
    readonly fullName: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly phoneNumber: FieldRef<'User', 'String'>;
    readonly passwordHash: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'UserRole'>;
    readonly fcmToken: FieldRef<'User', 'String'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly deletedAt: FieldRef<'User', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User.barbershop
   */
  export type User$barbershopArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barbershop
     */
    select?: BarbershopSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barbershop
     */
    omit?: BarbershopOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopInclude<ExtArgs> | null;
    where?: BarbershopWhereInput;
  };

  /**
   * User.barberInfo
   */
  export type User$barberInfoArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    where?: BarberWhereInput;
  };

  /**
   * User.queues
   */
  export type User$queuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    where?: QueueWhereInput;
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    cursor?: QueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * User.reviews
   */
  export type User$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * User.changedLogs
   */
  export type User$changedLogsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    where?: QueueHistoryWhereInput;
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    cursor?: QueueHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueHistoryScalarFieldEnum | QueueHistoryScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model Barber
   */

  export type AggregateBarber = {
    _count: BarberCountAggregateOutputType | null;
    _avg: BarberAvgAggregateOutputType | null;
    _sum: BarberSumAggregateOutputType | null;
    _min: BarberMinAggregateOutputType | null;
    _max: BarberMaxAggregateOutputType | null;
  };

  export type BarberAvgAggregateOutputType = {
    commissionRate: number | null;
  };

  export type BarberSumAggregateOutputType = {
    commissionRate: number | null;
  };

  export type BarberMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    userId: string | null;
    displayName: string | null;
    specialization: string | null;
    status: $Enums.BarberStatus | null;
    commissionRate: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type BarberMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    userId: string | null;
    displayName: string | null;
    specialization: string | null;
    status: $Enums.BarberStatus | null;
    commissionRate: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type BarberCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    userId: number;
    displayName: number;
    specialization: number;
    status: number;
    commissionRate: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type BarberAvgAggregateInputType = {
    commissionRate?: true;
  };

  export type BarberSumAggregateInputType = {
    commissionRate?: true;
  };

  export type BarberMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    userId?: true;
    displayName?: true;
    specialization?: true;
    status?: true;
    commissionRate?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type BarberMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    userId?: true;
    displayName?: true;
    specialization?: true;
    status?: true;
    commissionRate?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type BarberCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    userId?: true;
    displayName?: true;
    specialization?: true;
    status?: true;
    commissionRate?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type BarberAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Barber to aggregate.
     */
    where?: BarberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbers to fetch.
     */
    orderBy?: BarberOrderByWithRelationInput | BarberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BarberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Barbers
     **/
    _count?: true | BarberCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BarberAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BarberSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BarberMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BarberMaxAggregateInputType;
  };

  export type GetBarberAggregateType<T extends BarberAggregateArgs> = {
    [P in keyof T & keyof AggregateBarber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarber[P]>
      : GetScalarType<T[P], AggregateBarber[P]>;
  };

  export type BarberGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberWhereInput;
    orderBy?:
      | BarberOrderByWithAggregationInput
      | BarberOrderByWithAggregationInput[];
    by: BarberScalarFieldEnum[] | BarberScalarFieldEnum;
    having?: BarberScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BarberCountAggregateInputType | true;
    _avg?: BarberAvgAggregateInputType;
    _sum?: BarberSumAggregateInputType;
    _min?: BarberMinAggregateInputType;
    _max?: BarberMaxAggregateInputType;
  };

  export type BarberGroupByOutputType = {
    id: string;
    barbershopId: string;
    userId: string;
    displayName: string | null;
    specialization: string | null;
    status: $Enums.BarberStatus;
    commissionRate: number | null;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: BarberCountAggregateOutputType | null;
    _avg: BarberAvgAggregateOutputType | null;
    _sum: BarberSumAggregateOutputType | null;
    _min: BarberMinAggregateOutputType | null;
    _max: BarberMaxAggregateOutputType | null;
  };

  type GetBarberGroupByPayload<T extends BarberGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BarberGroupByOutputType, T['by']> & {
          [P in keyof T & keyof BarberGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarberGroupByOutputType[P]>
            : GetScalarType<T[P], BarberGroupByOutputType[P]>;
        }
      >
    >;

  export type BarberSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      userId?: boolean;
      displayName?: boolean;
      specialization?: boolean;
      status?: boolean;
      commissionRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      services?: boolean | Barber$servicesArgs<ExtArgs>;
      schedules?: boolean | Barber$schedulesArgs<ExtArgs>;
      queues?: boolean | Barber$queuesArgs<ExtArgs>;
      reviews?: boolean | Barber$reviewsArgs<ExtArgs>;
      _count?: boolean | BarberCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barber']
  >;

  export type BarberSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      userId?: boolean;
      displayName?: boolean;
      specialization?: boolean;
      status?: boolean;
      commissionRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barber']
  >;

  export type BarberSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      userId?: boolean;
      displayName?: boolean;
      specialization?: boolean;
      status?: boolean;
      commissionRate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barber']
  >;

  export type BarberSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    userId?: boolean;
    displayName?: boolean;
    specialization?: boolean;
    status?: boolean;
    commissionRate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type BarberOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'userId'
    | 'displayName'
    | 'specialization'
    | 'status'
    | 'commissionRate'
    | 'createdAt'
    | 'updatedAt'
    | 'deletedAt',
    ExtArgs['result']['barber']
  >;
  export type BarberInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
    services?: boolean | Barber$servicesArgs<ExtArgs>;
    schedules?: boolean | Barber$schedulesArgs<ExtArgs>;
    queues?: boolean | Barber$queuesArgs<ExtArgs>;
    reviews?: boolean | Barber$reviewsArgs<ExtArgs>;
    _count?: boolean | BarberCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type BarberIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };
  export type BarberIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $BarberPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Barber';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
      services: Prisma.$BarberServicePayload<ExtArgs>[];
      schedules: Prisma.$BarberSchedulePayload<ExtArgs>[];
      queues: Prisma.$QueuePayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        userId: string;
        displayName: string | null;
        specialization: string | null;
        status: $Enums.BarberStatus;
        commissionRate: number | null;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['barber']
    >;
    composites: {};
  };

  type BarberGetPayload<
    S extends boolean | null | undefined | BarberDefaultArgs,
  > = $Result.GetResult<Prisma.$BarberPayload, S>;

  type BarberCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<BarberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: BarberCountAggregateInputType | true;
  };

  export interface BarberDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Barber'];
      meta: { name: 'Barber' };
    };
    /**
     * Find zero or one Barber that matches the filter.
     * @param {BarberFindUniqueArgs} args - Arguments to find a Barber
     * @example
     * // Get one Barber
     * const barber = await prisma.barber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarberFindUniqueArgs>(
      args: SelectSubset<T, BarberFindUniqueArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Barber that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarberFindUniqueOrThrowArgs} args - Arguments to find a Barber
     * @example
     * // Get one Barber
     * const barber = await prisma.barber.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarberFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BarberFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Barber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberFindFirstArgs} args - Arguments to find a Barber
     * @example
     * // Get one Barber
     * const barber = await prisma.barber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarberFindFirstArgs>(
      args?: SelectSubset<T, BarberFindFirstArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Barber that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberFindFirstOrThrowArgs} args - Arguments to find a Barber
     * @example
     * // Get one Barber
     * const barber = await prisma.barber.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BarberFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Barbers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Barbers
     * const barbers = await prisma.barber.findMany()
     *
     * // Get first 10 Barbers
     * const barbers = await prisma.barber.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const barberWithIdOnly = await prisma.barber.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BarberFindManyArgs>(
      args?: SelectSubset<T, BarberFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Barber.
     * @param {BarberCreateArgs} args - Arguments to create a Barber.
     * @example
     * // Create one Barber
     * const Barber = await prisma.barber.create({
     *   data: {
     *     // ... data to create a Barber
     *   }
     * })
     *
     */
    create<T extends BarberCreateArgs>(
      args: SelectSubset<T, BarberCreateArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Barbers.
     * @param {BarberCreateManyArgs} args - Arguments to create many Barbers.
     * @example
     * // Create many Barbers
     * const barber = await prisma.barber.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BarberCreateManyArgs>(
      args?: SelectSubset<T, BarberCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Barbers and returns the data saved in the database.
     * @param {BarberCreateManyAndReturnArgs} args - Arguments to create many Barbers.
     * @example
     * // Create many Barbers
     * const barber = await prisma.barber.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Barbers and only return the `id`
     * const barberWithIdOnly = await prisma.barber.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BarberCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BarberCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Barber.
     * @param {BarberDeleteArgs} args - Arguments to delete one Barber.
     * @example
     * // Delete one Barber
     * const Barber = await prisma.barber.delete({
     *   where: {
     *     // ... filter to delete one Barber
     *   }
     * })
     *
     */
    delete<T extends BarberDeleteArgs>(
      args: SelectSubset<T, BarberDeleteArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Barber.
     * @param {BarberUpdateArgs} args - Arguments to update one Barber.
     * @example
     * // Update one Barber
     * const barber = await prisma.barber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BarberUpdateArgs>(
      args: SelectSubset<T, BarberUpdateArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Barbers.
     * @param {BarberDeleteManyArgs} args - Arguments to filter Barbers to delete.
     * @example
     * // Delete a few Barbers
     * const { count } = await prisma.barber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BarberDeleteManyArgs>(
      args?: SelectSubset<T, BarberDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Barbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Barbers
     * const barber = await prisma.barber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BarberUpdateManyArgs>(
      args: SelectSubset<T, BarberUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Barbers and returns the data updated in the database.
     * @param {BarberUpdateManyAndReturnArgs} args - Arguments to update many Barbers.
     * @example
     * // Update many Barbers
     * const barber = await prisma.barber.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Barbers and only return the `id`
     * const barberWithIdOnly = await prisma.barber.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BarberUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BarberUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Barber.
     * @param {BarberUpsertArgs} args - Arguments to update or create a Barber.
     * @example
     * // Update or create a Barber
     * const barber = await prisma.barber.upsert({
     *   create: {
     *     // ... data to create a Barber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Barber we want to update
     *   }
     * })
     */
    upsert<T extends BarberUpsertArgs>(
      args: SelectSubset<T, BarberUpsertArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Barbers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberCountArgs} args - Arguments to filter Barbers to count.
     * @example
     * // Count the number of Barbers
     * const count = await prisma.barber.count({
     *   where: {
     *     // ... the filter for the Barbers we want to count
     *   }
     * })
     **/
    count<T extends BarberCountArgs>(
      args?: Subset<T, BarberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarberCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Barber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BarberAggregateArgs>(
      args: Subset<T, BarberAggregateArgs>,
    ): Prisma.PrismaPromise<GetBarberAggregateType<T>>;

    /**
     * Group by Barber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BarberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarberGroupByArgs['orderBy'] }
        : { orderBy?: BarberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BarberGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetBarberGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Barber model
     */
    readonly fields: BarberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Barber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarberClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    services<T extends Barber$servicesArgs<ExtArgs> = {}>(
      args?: Subset<T, Barber$servicesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BarberServicePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    schedules<T extends Barber$schedulesArgs<ExtArgs> = {}>(
      args?: Subset<T, Barber$schedulesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BarberSchedulePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    queues<T extends Barber$queuesArgs<ExtArgs> = {}>(
      args?: Subset<T, Barber$queuesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends Barber$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Barber$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Barber model
   */
  interface BarberFieldRefs {
    readonly id: FieldRef<'Barber', 'String'>;
    readonly barbershopId: FieldRef<'Barber', 'String'>;
    readonly userId: FieldRef<'Barber', 'String'>;
    readonly displayName: FieldRef<'Barber', 'String'>;
    readonly specialization: FieldRef<'Barber', 'String'>;
    readonly status: FieldRef<'Barber', 'BarberStatus'>;
    readonly commissionRate: FieldRef<'Barber', 'Float'>;
    readonly createdAt: FieldRef<'Barber', 'DateTime'>;
    readonly updatedAt: FieldRef<'Barber', 'DateTime'>;
    readonly deletedAt: FieldRef<'Barber', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Barber findUnique
   */
  export type BarberFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter, which Barber to fetch.
     */
    where: BarberWhereUniqueInput;
  };

  /**
   * Barber findUniqueOrThrow
   */
  export type BarberFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter, which Barber to fetch.
     */
    where: BarberWhereUniqueInput;
  };

  /**
   * Barber findFirst
   */
  export type BarberFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter, which Barber to fetch.
     */
    where?: BarberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbers to fetch.
     */
    orderBy?: BarberOrderByWithRelationInput | BarberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Barbers.
     */
    cursor?: BarberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Barbers.
     */
    distinct?: BarberScalarFieldEnum | BarberScalarFieldEnum[];
  };

  /**
   * Barber findFirstOrThrow
   */
  export type BarberFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter, which Barber to fetch.
     */
    where?: BarberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbers to fetch.
     */
    orderBy?: BarberOrderByWithRelationInput | BarberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Barbers.
     */
    cursor?: BarberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbers.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Barbers.
     */
    distinct?: BarberScalarFieldEnum | BarberScalarFieldEnum[];
  };

  /**
   * Barber findMany
   */
  export type BarberFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter, which Barbers to fetch.
     */
    where?: BarberWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Barbers to fetch.
     */
    orderBy?: BarberOrderByWithRelationInput | BarberOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Barbers.
     */
    cursor?: BarberWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Barbers from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Barbers.
     */
    skip?: number;
    distinct?: BarberScalarFieldEnum | BarberScalarFieldEnum[];
  };

  /**
   * Barber create
   */
  export type BarberCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * The data needed to create a Barber.
     */
    data: XOR<BarberCreateInput, BarberUncheckedCreateInput>;
  };

  /**
   * Barber createMany
   */
  export type BarberCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Barbers.
     */
    data: BarberCreateManyInput | BarberCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Barber createManyAndReturn
   */
  export type BarberCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * The data used to create many Barbers.
     */
    data: BarberCreateManyInput | BarberCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Barber update
   */
  export type BarberUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * The data needed to update a Barber.
     */
    data: XOR<BarberUpdateInput, BarberUncheckedUpdateInput>;
    /**
     * Choose, which Barber to update.
     */
    where: BarberWhereUniqueInput;
  };

  /**
   * Barber updateMany
   */
  export type BarberUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Barbers.
     */
    data: XOR<BarberUpdateManyMutationInput, BarberUncheckedUpdateManyInput>;
    /**
     * Filter which Barbers to update
     */
    where?: BarberWhereInput;
    /**
     * Limit how many Barbers to update.
     */
    limit?: number;
  };

  /**
   * Barber updateManyAndReturn
   */
  export type BarberUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * The data used to update Barbers.
     */
    data: XOR<BarberUpdateManyMutationInput, BarberUncheckedUpdateManyInput>;
    /**
     * Filter which Barbers to update
     */
    where?: BarberWhereInput;
    /**
     * Limit how many Barbers to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Barber upsert
   */
  export type BarberUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * The filter to search for the Barber to update in case it exists.
     */
    where: BarberWhereUniqueInput;
    /**
     * In case the Barber found by the `where` argument doesn't exist, create a new Barber with this data.
     */
    create: XOR<BarberCreateInput, BarberUncheckedCreateInput>;
    /**
     * In case the Barber was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarberUpdateInput, BarberUncheckedUpdateInput>;
  };

  /**
   * Barber delete
   */
  export type BarberDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    /**
     * Filter which Barber to delete.
     */
    where: BarberWhereUniqueInput;
  };

  /**
   * Barber deleteMany
   */
  export type BarberDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Barbers to delete
     */
    where?: BarberWhereInput;
    /**
     * Limit how many Barbers to delete.
     */
    limit?: number;
  };

  /**
   * Barber.services
   */
  export type Barber$servicesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    where?: BarberServiceWhereInput;
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    cursor?: BarberServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BarberServiceScalarFieldEnum | BarberServiceScalarFieldEnum[];
  };

  /**
   * Barber.schedules
   */
  export type Barber$schedulesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    where?: BarberScheduleWhereInput;
    orderBy?:
      | BarberScheduleOrderByWithRelationInput
      | BarberScheduleOrderByWithRelationInput[];
    cursor?: BarberScheduleWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BarberScheduleScalarFieldEnum | BarberScheduleScalarFieldEnum[];
  };

  /**
   * Barber.queues
   */
  export type Barber$queuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    where?: QueueWhereInput;
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    cursor?: QueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Barber.reviews
   */
  export type Barber$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Barber without action
   */
  export type BarberDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
  };

  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  export type ServiceAvgAggregateOutputType = {
    durationMinutes: number | null;
    price: number | null;
  };

  export type ServiceSumAggregateOutputType = {
    durationMinutes: number | null;
    price: number | null;
  };

  export type ServiceMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    name: string | null;
    description: string | null;
    durationMinutes: number | null;
    price: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ServiceMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    name: string | null;
    description: string | null;
    durationMinutes: number | null;
    price: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type ServiceCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    name: number;
    description: number;
    durationMinutes: number;
    price: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type ServiceAvgAggregateInputType = {
    durationMinutes?: true;
    price?: true;
  };

  export type ServiceSumAggregateInputType = {
    durationMinutes?: true;
    price?: true;
  };

  export type ServiceMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    name?: true;
    description?: true;
    durationMinutes?: true;
    price?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ServiceMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    name?: true;
    description?: true;
    durationMinutes?: true;
    price?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type ServiceCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    name?: true;
    description?: true;
    durationMinutes?: true;
    price?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type ServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?:
      | ServiceOrderByWithRelationInput
      | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Services
     **/
    _count?: true | ServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ServiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ServiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ServiceMaxAggregateInputType;
  };

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
    [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>;
  };

  export type ServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ServiceWhereInput;
    orderBy?:
      | ServiceOrderByWithAggregationInput
      | ServiceOrderByWithAggregationInput[];
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum;
    having?: ServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ServiceCountAggregateInputType | true;
    _avg?: ServiceAvgAggregateInputType;
    _sum?: ServiceSumAggregateInputType;
    _min?: ServiceMinAggregateInputType;
    _max?: ServiceMaxAggregateInputType;
  };

  export type ServiceGroupByOutputType = {
    id: string;
    barbershopId: string;
    name: string;
    description: string | null;
    durationMinutes: number;
    price: number;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: ServiceCountAggregateOutputType | null;
    _avg: ServiceAvgAggregateOutputType | null;
    _sum: ServiceSumAggregateOutputType | null;
    _min: ServiceMinAggregateOutputType | null;
    _max: ServiceMaxAggregateOutputType | null;
  };

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ServiceGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ServiceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>;
        }
      >
    >;

  export type ServiceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      name?: boolean;
      description?: boolean;
      durationMinutes?: boolean;
      price?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barbers?: boolean | Service$barbersArgs<ExtArgs>;
      queues?: boolean | Service$queuesArgs<ExtArgs>;
      _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      name?: boolean;
      description?: boolean;
      durationMinutes?: boolean;
      price?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      name?: boolean;
      description?: boolean;
      durationMinutes?: boolean;
      price?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['service']
  >;

  export type ServiceSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    name?: boolean;
    description?: boolean;
    durationMinutes?: boolean;
    price?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type ServiceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'name'
    | 'description'
    | 'durationMinutes'
    | 'price'
    | 'createdAt'
    | 'updatedAt'
    | 'deletedAt',
    ExtArgs['result']['service']
  >;
  export type ServiceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barbers?: boolean | Service$barbersArgs<ExtArgs>;
    queues?: boolean | Service$queuesArgs<ExtArgs>;
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };
  export type ServiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };

  export type $ServicePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Service';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
      barbers: Prisma.$BarberServicePayload<ExtArgs>[];
      queues: Prisma.$QueuePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        name: string;
        description: string | null;
        durationMinutes: number;
        price: number;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['service']
    >;
    composites: {};
  };

  type ServiceGetPayload<
    S extends boolean | null | undefined | ServiceDefaultArgs,
  > = $Result.GetResult<Prisma.$ServicePayload, S>;

  type ServiceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ServiceCountAggregateInputType | true;
  };

  export interface ServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Service'];
      meta: { name: 'Service' };
    };
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     *
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ServiceFindManyArgs>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     *
     */
    create<T extends ServiceCreateArgs>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ServiceCreateManyArgs>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     *
     */
    delete<T extends ServiceDeleteArgs>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ServiceUpdateArgs>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ServiceDeleteManyArgs>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ServiceUpdateManyArgs>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      $Result.GetResult<
        Prisma.$ServicePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
     **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ServiceAggregateArgs>(
      args: Subset<T, ServiceAggregateArgs>,
    ): Prisma.PrismaPromise<GetServiceAggregateType<T>>;

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetServiceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Service model
     */
    readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    barbers<T extends Service$barbersArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$barbersArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$BarberServicePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    queues<T extends Service$queuesArgs<ExtArgs> = {}>(
      args?: Subset<T, Service$queuesArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueuePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<'Service', 'String'>;
    readonly barbershopId: FieldRef<'Service', 'String'>;
    readonly name: FieldRef<'Service', 'String'>;
    readonly description: FieldRef<'Service', 'String'>;
    readonly durationMinutes: FieldRef<'Service', 'Int'>;
    readonly price: FieldRef<'Service', 'Float'>;
    readonly createdAt: FieldRef<'Service', 'DateTime'>;
    readonly updatedAt: FieldRef<'Service', 'DateTime'>;
    readonly deletedAt: FieldRef<'Service', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?:
      | ServiceOrderByWithRelationInput
      | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?:
      | ServiceOrderByWithRelationInput
      | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Services to fetch.
     */
    orderBy?:
      | ServiceOrderByWithRelationInput
      | ServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Services from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Services.
     */
    skip?: number;
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[];
  };

  /**
   * Service create
   */
  export type ServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
  };

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service update
   */
  export type ServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
  };

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>;
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput;
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>;
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>;
  };

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput;
  };

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput;
    /**
     * Limit how many Services to delete.
     */
    limit?: number;
  };

  /**
   * Service.barbers
   */
  export type Service$barbersArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    where?: BarberServiceWhereInput;
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    cursor?: BarberServiceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: BarberServiceScalarFieldEnum | BarberServiceScalarFieldEnum[];
  };

  /**
   * Service.queues
   */
  export type Service$queuesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    where?: QueueWhereInput;
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    cursor?: QueueWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null;
  };

  /**
   * Model BarberService
   */

  export type AggregateBarberService = {
    _count: BarberServiceCountAggregateOutputType | null;
    _avg: BarberServiceAvgAggregateOutputType | null;
    _sum: BarberServiceSumAggregateOutputType | null;
    _min: BarberServiceMinAggregateOutputType | null;
    _max: BarberServiceMaxAggregateOutputType | null;
  };

  export type BarberServiceAvgAggregateOutputType = {
    customDurationMinutes: number | null;
  };

  export type BarberServiceSumAggregateOutputType = {
    customDurationMinutes: number | null;
  };

  export type BarberServiceMinAggregateOutputType = {
    barberId: string | null;
    serviceId: string | null;
    customDurationMinutes: number | null;
  };

  export type BarberServiceMaxAggregateOutputType = {
    barberId: string | null;
    serviceId: string | null;
    customDurationMinutes: number | null;
  };

  export type BarberServiceCountAggregateOutputType = {
    barberId: number;
    serviceId: number;
    customDurationMinutes: number;
    _all: number;
  };

  export type BarberServiceAvgAggregateInputType = {
    customDurationMinutes?: true;
  };

  export type BarberServiceSumAggregateInputType = {
    customDurationMinutes?: true;
  };

  export type BarberServiceMinAggregateInputType = {
    barberId?: true;
    serviceId?: true;
    customDurationMinutes?: true;
  };

  export type BarberServiceMaxAggregateInputType = {
    barberId?: true;
    serviceId?: true;
    customDurationMinutes?: true;
  };

  export type BarberServiceCountAggregateInputType = {
    barberId?: true;
    serviceId?: true;
    customDurationMinutes?: true;
    _all?: true;
  };

  export type BarberServiceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarberService to aggregate.
     */
    where?: BarberServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberServices to fetch.
     */
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BarberServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberServices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberServices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BarberServices
     **/
    _count?: true | BarberServiceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BarberServiceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BarberServiceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BarberServiceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BarberServiceMaxAggregateInputType;
  };

  export type GetBarberServiceAggregateType<
    T extends BarberServiceAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateBarberService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarberService[P]>
      : GetScalarType<T[P], AggregateBarberService[P]>;
  };

  export type BarberServiceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberServiceWhereInput;
    orderBy?:
      | BarberServiceOrderByWithAggregationInput
      | BarberServiceOrderByWithAggregationInput[];
    by: BarberServiceScalarFieldEnum[] | BarberServiceScalarFieldEnum;
    having?: BarberServiceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BarberServiceCountAggregateInputType | true;
    _avg?: BarberServiceAvgAggregateInputType;
    _sum?: BarberServiceSumAggregateInputType;
    _min?: BarberServiceMinAggregateInputType;
    _max?: BarberServiceMaxAggregateInputType;
  };

  export type BarberServiceGroupByOutputType = {
    barberId: string;
    serviceId: string;
    customDurationMinutes: number | null;
    _count: BarberServiceCountAggregateOutputType | null;
    _avg: BarberServiceAvgAggregateOutputType | null;
    _sum: BarberServiceSumAggregateOutputType | null;
    _min: BarberServiceMinAggregateOutputType | null;
    _max: BarberServiceMaxAggregateOutputType | null;
  };

  type GetBarberServiceGroupByPayload<T extends BarberServiceGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BarberServiceGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof BarberServiceGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarberServiceGroupByOutputType[P]>
            : GetScalarType<T[P], BarberServiceGroupByOutputType[P]>;
        }
      >
    >;

  export type BarberServiceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      barberId?: boolean;
      serviceId?: boolean;
      customDurationMinutes?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberService']
  >;

  export type BarberServiceSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      barberId?: boolean;
      serviceId?: boolean;
      customDurationMinutes?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberService']
  >;

  export type BarberServiceSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      barberId?: boolean;
      serviceId?: boolean;
      customDurationMinutes?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberService']
  >;

  export type BarberServiceSelectScalar = {
    barberId?: boolean;
    serviceId?: boolean;
    customDurationMinutes?: boolean;
  };

  export type BarberServiceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'barberId' | 'serviceId' | 'customDurationMinutes',
    ExtArgs['result']['barberService']
  >;
  export type BarberServiceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type BarberServiceIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type BarberServiceIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $BarberServicePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'BarberService';
    objects: {
      barber: Prisma.$BarberPayload<ExtArgs>;
      service: Prisma.$ServicePayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        barberId: string;
        serviceId: string;
        customDurationMinutes: number | null;
      },
      ExtArgs['result']['barberService']
    >;
    composites: {};
  };

  type BarberServiceGetPayload<
    S extends boolean | null | undefined | BarberServiceDefaultArgs,
  > = $Result.GetResult<Prisma.$BarberServicePayload, S>;

  type BarberServiceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    BarberServiceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: BarberServiceCountAggregateInputType | true;
  };

  export interface BarberServiceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['BarberService'];
      meta: { name: 'BarberService' };
    };
    /**
     * Find zero or one BarberService that matches the filter.
     * @param {BarberServiceFindUniqueArgs} args - Arguments to find a BarberService
     * @example
     * // Get one BarberService
     * const barberService = await prisma.barberService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarberServiceFindUniqueArgs>(
      args: SelectSubset<T, BarberServiceFindUniqueArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one BarberService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarberServiceFindUniqueOrThrowArgs} args - Arguments to find a BarberService
     * @example
     * // Get one BarberService
     * const barberService = await prisma.barberService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarberServiceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BarberServiceFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarberService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceFindFirstArgs} args - Arguments to find a BarberService
     * @example
     * // Get one BarberService
     * const barberService = await prisma.barberService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarberServiceFindFirstArgs>(
      args?: SelectSubset<T, BarberServiceFindFirstArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarberService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceFindFirstOrThrowArgs} args - Arguments to find a BarberService
     * @example
     * // Get one BarberService
     * const barberService = await prisma.barberService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarberServiceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BarberServiceFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more BarberServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarberServices
     * const barberServices = await prisma.barberService.findMany()
     *
     * // Get first 10 BarberServices
     * const barberServices = await prisma.barberService.findMany({ take: 10 })
     *
     * // Only select the `barberId`
     * const barberServiceWithBarberIdOnly = await prisma.barberService.findMany({ select: { barberId: true } })
     *
     */
    findMany<T extends BarberServiceFindManyArgs>(
      args?: SelectSubset<T, BarberServiceFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a BarberService.
     * @param {BarberServiceCreateArgs} args - Arguments to create a BarberService.
     * @example
     * // Create one BarberService
     * const BarberService = await prisma.barberService.create({
     *   data: {
     *     // ... data to create a BarberService
     *   }
     * })
     *
     */
    create<T extends BarberServiceCreateArgs>(
      args: SelectSubset<T, BarberServiceCreateArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many BarberServices.
     * @param {BarberServiceCreateManyArgs} args - Arguments to create many BarberServices.
     * @example
     * // Create many BarberServices
     * const barberService = await prisma.barberService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BarberServiceCreateManyArgs>(
      args?: SelectSubset<T, BarberServiceCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many BarberServices and returns the data saved in the database.
     * @param {BarberServiceCreateManyAndReturnArgs} args - Arguments to create many BarberServices.
     * @example
     * // Create many BarberServices
     * const barberService = await prisma.barberService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many BarberServices and only return the `barberId`
     * const barberServiceWithBarberIdOnly = await prisma.barberService.createManyAndReturn({
     *   select: { barberId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BarberServiceCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BarberServiceCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a BarberService.
     * @param {BarberServiceDeleteArgs} args - Arguments to delete one BarberService.
     * @example
     * // Delete one BarberService
     * const BarberService = await prisma.barberService.delete({
     *   where: {
     *     // ... filter to delete one BarberService
     *   }
     * })
     *
     */
    delete<T extends BarberServiceDeleteArgs>(
      args: SelectSubset<T, BarberServiceDeleteArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one BarberService.
     * @param {BarberServiceUpdateArgs} args - Arguments to update one BarberService.
     * @example
     * // Update one BarberService
     * const barberService = await prisma.barberService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BarberServiceUpdateArgs>(
      args: SelectSubset<T, BarberServiceUpdateArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more BarberServices.
     * @param {BarberServiceDeleteManyArgs} args - Arguments to filter BarberServices to delete.
     * @example
     * // Delete a few BarberServices
     * const { count } = await prisma.barberService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BarberServiceDeleteManyArgs>(
      args?: SelectSubset<T, BarberServiceDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarberServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarberServices
     * const barberService = await prisma.barberService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BarberServiceUpdateManyArgs>(
      args: SelectSubset<T, BarberServiceUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarberServices and returns the data updated in the database.
     * @param {BarberServiceUpdateManyAndReturnArgs} args - Arguments to update many BarberServices.
     * @example
     * // Update many BarberServices
     * const barberService = await prisma.barberService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more BarberServices and only return the `barberId`
     * const barberServiceWithBarberIdOnly = await prisma.barberService.updateManyAndReturn({
     *   select: { barberId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BarberServiceUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BarberServiceUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one BarberService.
     * @param {BarberServiceUpsertArgs} args - Arguments to update or create a BarberService.
     * @example
     * // Update or create a BarberService
     * const barberService = await prisma.barberService.upsert({
     *   create: {
     *     // ... data to create a BarberService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarberService we want to update
     *   }
     * })
     */
    upsert<T extends BarberServiceUpsertArgs>(
      args: SelectSubset<T, BarberServiceUpsertArgs<ExtArgs>>,
    ): Prisma__BarberServiceClient<
      $Result.GetResult<
        Prisma.$BarberServicePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of BarberServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceCountArgs} args - Arguments to filter BarberServices to count.
     * @example
     * // Count the number of BarberServices
     * const count = await prisma.barberService.count({
     *   where: {
     *     // ... the filter for the BarberServices we want to count
     *   }
     * })
     **/
    count<T extends BarberServiceCountArgs>(
      args?: Subset<T, BarberServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarberServiceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a BarberService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BarberServiceAggregateArgs>(
      args: Subset<T, BarberServiceAggregateArgs>,
    ): Prisma.PrismaPromise<GetBarberServiceAggregateType<T>>;

    /**
     * Group by BarberService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BarberServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarberServiceGroupByArgs['orderBy'] }
        : { orderBy?: BarberServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BarberServiceGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetBarberServiceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the BarberService model
     */
    readonly fields: BarberServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarberService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarberServiceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barber<T extends BarberDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarberDefaultArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      | $Result.GetResult<
          Prisma.$BarberPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the BarberService model
   */
  interface BarberServiceFieldRefs {
    readonly barberId: FieldRef<'BarberService', 'String'>;
    readonly serviceId: FieldRef<'BarberService', 'String'>;
    readonly customDurationMinutes: FieldRef<'BarberService', 'Int'>;
  }

  // Custom InputTypes
  /**
   * BarberService findUnique
   */
  export type BarberServiceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter, which BarberService to fetch.
     */
    where: BarberServiceWhereUniqueInput;
  };

  /**
   * BarberService findUniqueOrThrow
   */
  export type BarberServiceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter, which BarberService to fetch.
     */
    where: BarberServiceWhereUniqueInput;
  };

  /**
   * BarberService findFirst
   */
  export type BarberServiceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter, which BarberService to fetch.
     */
    where?: BarberServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberServices to fetch.
     */
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarberServices.
     */
    cursor?: BarberServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberServices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberServices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarberServices.
     */
    distinct?: BarberServiceScalarFieldEnum | BarberServiceScalarFieldEnum[];
  };

  /**
   * BarberService findFirstOrThrow
   */
  export type BarberServiceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter, which BarberService to fetch.
     */
    where?: BarberServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberServices to fetch.
     */
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarberServices.
     */
    cursor?: BarberServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberServices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberServices.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarberServices.
     */
    distinct?: BarberServiceScalarFieldEnum | BarberServiceScalarFieldEnum[];
  };

  /**
   * BarberService findMany
   */
  export type BarberServiceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter, which BarberServices to fetch.
     */
    where?: BarberServiceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberServices to fetch.
     */
    orderBy?:
      | BarberServiceOrderByWithRelationInput
      | BarberServiceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BarberServices.
     */
    cursor?: BarberServiceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberServices from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberServices.
     */
    skip?: number;
    distinct?: BarberServiceScalarFieldEnum | BarberServiceScalarFieldEnum[];
  };

  /**
   * BarberService create
   */
  export type BarberServiceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * The data needed to create a BarberService.
     */
    data: XOR<BarberServiceCreateInput, BarberServiceUncheckedCreateInput>;
  };

  /**
   * BarberService createMany
   */
  export type BarberServiceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many BarberServices.
     */
    data: BarberServiceCreateManyInput | BarberServiceCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * BarberService createManyAndReturn
   */
  export type BarberServiceCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * The data used to create many BarberServices.
     */
    data: BarberServiceCreateManyInput | BarberServiceCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarberService update
   */
  export type BarberServiceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * The data needed to update a BarberService.
     */
    data: XOR<BarberServiceUpdateInput, BarberServiceUncheckedUpdateInput>;
    /**
     * Choose, which BarberService to update.
     */
    where: BarberServiceWhereUniqueInput;
  };

  /**
   * BarberService updateMany
   */
  export type BarberServiceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update BarberServices.
     */
    data: XOR<
      BarberServiceUpdateManyMutationInput,
      BarberServiceUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarberServices to update
     */
    where?: BarberServiceWhereInput;
    /**
     * Limit how many BarberServices to update.
     */
    limit?: number;
  };

  /**
   * BarberService updateManyAndReturn
   */
  export type BarberServiceUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * The data used to update BarberServices.
     */
    data: XOR<
      BarberServiceUpdateManyMutationInput,
      BarberServiceUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarberServices to update
     */
    where?: BarberServiceWhereInput;
    /**
     * Limit how many BarberServices to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarberService upsert
   */
  export type BarberServiceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * The filter to search for the BarberService to update in case it exists.
     */
    where: BarberServiceWhereUniqueInput;
    /**
     * In case the BarberService found by the `where` argument doesn't exist, create a new BarberService with this data.
     */
    create: XOR<BarberServiceCreateInput, BarberServiceUncheckedCreateInput>;
    /**
     * In case the BarberService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarberServiceUpdateInput, BarberServiceUncheckedUpdateInput>;
  };

  /**
   * BarberService delete
   */
  export type BarberServiceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
    /**
     * Filter which BarberService to delete.
     */
    where: BarberServiceWhereUniqueInput;
  };

  /**
   * BarberService deleteMany
   */
  export type BarberServiceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarberServices to delete
     */
    where?: BarberServiceWhereInput;
    /**
     * Limit how many BarberServices to delete.
     */
    limit?: number;
  };

  /**
   * BarberService without action
   */
  export type BarberServiceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberService
     */
    select?: BarberServiceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberService
     */
    omit?: BarberServiceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberServiceInclude<ExtArgs> | null;
  };

  /**
   * Model Queue
   */

  export type AggregateQueue = {
    _count: QueueCountAggregateOutputType | null;
    _min: QueueMinAggregateOutputType | null;
    _max: QueueMaxAggregateOutputType | null;
  };

  export type QueueMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    barberId: string | null;
    customerId: string | null;
    guestName: string | null;
    serviceId: string | null;
    status: $Enums.QueueStatus | null;
    bookingSource: string | null;
    scheduledTime: Date | null;
    estimatedStartTime: Date | null;
    estimatedEndTime: Date | null;
    actualStartTime: Date | null;
    actualEndTime: Date | null;
    notified30m: boolean | null;
    notified15m: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type QueueMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    barberId: string | null;
    customerId: string | null;
    guestName: string | null;
    serviceId: string | null;
    status: $Enums.QueueStatus | null;
    bookingSource: string | null;
    scheduledTime: Date | null;
    estimatedStartTime: Date | null;
    estimatedEndTime: Date | null;
    actualStartTime: Date | null;
    actualEndTime: Date | null;
    notified30m: boolean | null;
    notified15m: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    deletedAt: Date | null;
  };

  export type QueueCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    barberId: number;
    customerId: number;
    guestName: number;
    serviceId: number;
    status: number;
    bookingSource: number;
    scheduledTime: number;
    estimatedStartTime: number;
    estimatedEndTime: number;
    actualStartTime: number;
    actualEndTime: number;
    notified30m: number;
    notified15m: number;
    createdAt: number;
    updatedAt: number;
    deletedAt: number;
    _all: number;
  };

  export type QueueMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    guestName?: true;
    serviceId?: true;
    status?: true;
    bookingSource?: true;
    scheduledTime?: true;
    estimatedStartTime?: true;
    estimatedEndTime?: true;
    actualStartTime?: true;
    actualEndTime?: true;
    notified30m?: true;
    notified15m?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type QueueMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    guestName?: true;
    serviceId?: true;
    status?: true;
    bookingSource?: true;
    scheduledTime?: true;
    estimatedStartTime?: true;
    estimatedEndTime?: true;
    actualStartTime?: true;
    actualEndTime?: true;
    notified30m?: true;
    notified15m?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
  };

  export type QueueCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    guestName?: true;
    serviceId?: true;
    status?: true;
    bookingSource?: true;
    scheduledTime?: true;
    estimatedStartTime?: true;
    estimatedEndTime?: true;
    actualStartTime?: true;
    actualEndTime?: true;
    notified30m?: true;
    notified15m?: true;
    createdAt?: true;
    updatedAt?: true;
    deletedAt?: true;
    _all?: true;
  };

  export type QueueAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Queue to aggregate.
     */
    where?: QueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: QueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Queues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Queues
     **/
    _count?: true | QueueCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QueueMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QueueMaxAggregateInputType;
  };

  export type GetQueueAggregateType<T extends QueueAggregateArgs> = {
    [P in keyof T & keyof AggregateQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueue[P]>
      : GetScalarType<T[P], AggregateQueue[P]>;
  };

  export type QueueGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueWhereInput;
    orderBy?:
      | QueueOrderByWithAggregationInput
      | QueueOrderByWithAggregationInput[];
    by: QueueScalarFieldEnum[] | QueueScalarFieldEnum;
    having?: QueueScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QueueCountAggregateInputType | true;
    _min?: QueueMinAggregateInputType;
    _max?: QueueMaxAggregateInputType;
  };

  export type QueueGroupByOutputType = {
    id: string;
    barbershopId: string;
    barberId: string | null;
    customerId: string | null;
    guestName: string | null;
    serviceId: string;
    status: $Enums.QueueStatus;
    bookingSource: string;
    scheduledTime: Date | null;
    estimatedStartTime: Date | null;
    estimatedEndTime: Date | null;
    actualStartTime: Date | null;
    actualEndTime: Date | null;
    notified30m: boolean;
    notified15m: boolean;
    createdAt: Date;
    updatedAt: Date;
    deletedAt: Date | null;
    _count: QueueCountAggregateOutputType | null;
    _min: QueueMinAggregateOutputType | null;
    _max: QueueMaxAggregateOutputType | null;
  };

  type GetQueueGroupByPayload<T extends QueueGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QueueGroupByOutputType, T['by']> & {
          [P in keyof T & keyof QueueGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueGroupByOutputType[P]>
            : GetScalarType<T[P], QueueGroupByOutputType[P]>;
        }
      >
    >;

  export type QueueSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      guestName?: boolean;
      serviceId?: boolean;
      status?: boolean;
      bookingSource?: boolean;
      scheduledTime?: boolean;
      estimatedStartTime?: boolean;
      estimatedEndTime?: boolean;
      actualStartTime?: boolean;
      actualEndTime?: boolean;
      notified30m?: boolean;
      notified15m?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Queue$barberArgs<ExtArgs>;
      customer?: boolean | Queue$customerArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
      history?: boolean | Queue$historyArgs<ExtArgs>;
      reviews?: boolean | Queue$reviewsArgs<ExtArgs>;
      _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['queue']
  >;

  export type QueueSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      guestName?: boolean;
      serviceId?: boolean;
      status?: boolean;
      bookingSource?: boolean;
      scheduledTime?: boolean;
      estimatedStartTime?: boolean;
      estimatedEndTime?: boolean;
      actualStartTime?: boolean;
      actualEndTime?: boolean;
      notified30m?: boolean;
      notified15m?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Queue$barberArgs<ExtArgs>;
      customer?: boolean | Queue$customerArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['queue']
  >;

  export type QueueSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      guestName?: boolean;
      serviceId?: boolean;
      status?: boolean;
      bookingSource?: boolean;
      scheduledTime?: boolean;
      estimatedStartTime?: boolean;
      estimatedEndTime?: boolean;
      actualStartTime?: boolean;
      actualEndTime?: boolean;
      notified30m?: boolean;
      notified15m?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      deletedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Queue$barberArgs<ExtArgs>;
      customer?: boolean | Queue$customerArgs<ExtArgs>;
      service?: boolean | ServiceDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['queue']
  >;

  export type QueueSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    barberId?: boolean;
    customerId?: boolean;
    guestName?: boolean;
    serviceId?: boolean;
    status?: boolean;
    bookingSource?: boolean;
    scheduledTime?: boolean;
    estimatedStartTime?: boolean;
    estimatedEndTime?: boolean;
    actualStartTime?: boolean;
    actualEndTime?: boolean;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    deletedAt?: boolean;
  };

  export type QueueOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'barberId'
    | 'customerId'
    | 'guestName'
    | 'serviceId'
    | 'status'
    | 'bookingSource'
    | 'scheduledTime'
    | 'estimatedStartTime'
    | 'estimatedEndTime'
    | 'actualStartTime'
    | 'actualEndTime'
    | 'notified30m'
    | 'notified15m'
    | 'createdAt'
    | 'updatedAt'
    | 'deletedAt',
    ExtArgs['result']['queue']
  >;
  export type QueueInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Queue$barberArgs<ExtArgs>;
    customer?: boolean | Queue$customerArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
    history?: boolean | Queue$historyArgs<ExtArgs>;
    reviews?: boolean | Queue$reviewsArgs<ExtArgs>;
    _count?: boolean | QueueCountOutputTypeDefaultArgs<ExtArgs>;
  };
  export type QueueIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Queue$barberArgs<ExtArgs>;
    customer?: boolean | Queue$customerArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };
  export type QueueIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Queue$barberArgs<ExtArgs>;
    customer?: boolean | Queue$customerArgs<ExtArgs>;
    service?: boolean | ServiceDefaultArgs<ExtArgs>;
  };

  export type $QueuePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Queue';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
      barber: Prisma.$BarberPayload<ExtArgs> | null;
      customer: Prisma.$UserPayload<ExtArgs> | null;
      service: Prisma.$ServicePayload<ExtArgs>;
      history: Prisma.$QueueHistoryPayload<ExtArgs>[];
      reviews: Prisma.$ReviewPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        barberId: string | null;
        customerId: string | null;
        guestName: string | null;
        serviceId: string;
        status: $Enums.QueueStatus;
        bookingSource: string;
        scheduledTime: Date | null;
        estimatedStartTime: Date | null;
        estimatedEndTime: Date | null;
        actualStartTime: Date | null;
        actualEndTime: Date | null;
        notified30m: boolean;
        notified15m: boolean;
        createdAt: Date;
        updatedAt: Date;
        deletedAt: Date | null;
      },
      ExtArgs['result']['queue']
    >;
    composites: {};
  };

  type QueueGetPayload<
    S extends boolean | null | undefined | QueueDefaultArgs,
  > = $Result.GetResult<Prisma.$QueuePayload, S>;

  type QueueCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<QueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: QueueCountAggregateInputType | true;
  };

  export interface QueueDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Queue'];
      meta: { name: 'Queue' };
    };
    /**
     * Find zero or one Queue that matches the filter.
     * @param {QueueFindUniqueArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueFindUniqueArgs>(
      args: SelectSubset<T, QueueFindUniqueArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Queue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueFindUniqueOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueFindUniqueOrThrowArgs>(
      args: SelectSubset<T, QueueFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Queue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueFindFirstArgs>(
      args?: SelectSubset<T, QueueFindFirstArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Queue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindFirstOrThrowArgs} args - Arguments to find a Queue
     * @example
     * // Get one Queue
     * const queue = await prisma.queue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QueueFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Queues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Queues
     * const queues = await prisma.queue.findMany()
     *
     * // Get first 10 Queues
     * const queues = await prisma.queue.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const queueWithIdOnly = await prisma.queue.findMany({ select: { id: true } })
     *
     */
    findMany<T extends QueueFindManyArgs>(
      args?: SelectSubset<T, QueueFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Queue.
     * @param {QueueCreateArgs} args - Arguments to create a Queue.
     * @example
     * // Create one Queue
     * const Queue = await prisma.queue.create({
     *   data: {
     *     // ... data to create a Queue
     *   }
     * })
     *
     */
    create<T extends QueueCreateArgs>(
      args: SelectSubset<T, QueueCreateArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Queues.
     * @param {QueueCreateManyArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends QueueCreateManyArgs>(
      args?: SelectSubset<T, QueueCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Queues and returns the data saved in the database.
     * @param {QueueCreateManyAndReturnArgs} args - Arguments to create many Queues.
     * @example
     * // Create many Queues
     * const queue = await prisma.queue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends QueueCreateManyAndReturnArgs>(
      args?: SelectSubset<T, QueueCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Queue.
     * @param {QueueDeleteArgs} args - Arguments to delete one Queue.
     * @example
     * // Delete one Queue
     * const Queue = await prisma.queue.delete({
     *   where: {
     *     // ... filter to delete one Queue
     *   }
     * })
     *
     */
    delete<T extends QueueDeleteArgs>(
      args: SelectSubset<T, QueueDeleteArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Queue.
     * @param {QueueUpdateArgs} args - Arguments to update one Queue.
     * @example
     * // Update one Queue
     * const queue = await prisma.queue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends QueueUpdateArgs>(
      args: SelectSubset<T, QueueUpdateArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Queues.
     * @param {QueueDeleteManyArgs} args - Arguments to filter Queues to delete.
     * @example
     * // Delete a few Queues
     * const { count } = await prisma.queue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends QueueDeleteManyArgs>(
      args?: SelectSubset<T, QueueDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends QueueUpdateManyArgs>(
      args: SelectSubset<T, QueueUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Queues and returns the data updated in the database.
     * @param {QueueUpdateManyAndReturnArgs} args - Arguments to update many Queues.
     * @example
     * // Update many Queues
     * const queue = await prisma.queue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Queues and only return the `id`
     * const queueWithIdOnly = await prisma.queue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends QueueUpdateManyAndReturnArgs>(
      args: SelectSubset<T, QueueUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Queue.
     * @param {QueueUpsertArgs} args - Arguments to update or create a Queue.
     * @example
     * // Update or create a Queue
     * const queue = await prisma.queue.upsert({
     *   create: {
     *     // ... data to create a Queue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Queue we want to update
     *   }
     * })
     */
    upsert<T extends QueueUpsertArgs>(
      args: SelectSubset<T, QueueUpsertArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Queues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueCountArgs} args - Arguments to filter Queues to count.
     * @example
     * // Count the number of Queues
     * const count = await prisma.queue.count({
     *   where: {
     *     // ... the filter for the Queues we want to count
     *   }
     * })
     **/
    count<T extends QueueCountArgs>(
      args?: Subset<T, QueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QueueAggregateArgs>(
      args: Subset<T, QueueAggregateArgs>,
    ): Prisma.PrismaPromise<GetQueueAggregateType<T>>;

    /**
     * Group by Queue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends QueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueGroupByArgs['orderBy'] }
        : { orderBy?: QueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, QueueGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetQueueGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Queue model
     */
    readonly fields: QueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Queue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    barber<T extends Queue$barberArgs<ExtArgs> = {}>(
      args?: Subset<T, Queue$barberArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    customer<T extends Queue$customerArgs<ExtArgs> = {}>(
      args?: Subset<T, Queue$customerArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, ServiceDefaultArgs<ExtArgs>>,
    ): Prisma__ServiceClient<
      | $Result.GetResult<
          Prisma.$ServicePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    history<T extends Queue$historyArgs<ExtArgs> = {}>(
      args?: Subset<T, Queue$historyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$QueueHistoryPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    reviews<T extends Queue$reviewsArgs<ExtArgs> = {}>(
      args?: Subset<T, Queue$reviewsArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ReviewPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Queue model
   */
  interface QueueFieldRefs {
    readonly id: FieldRef<'Queue', 'String'>;
    readonly barbershopId: FieldRef<'Queue', 'String'>;
    readonly barberId: FieldRef<'Queue', 'String'>;
    readonly customerId: FieldRef<'Queue', 'String'>;
    readonly guestName: FieldRef<'Queue', 'String'>;
    readonly serviceId: FieldRef<'Queue', 'String'>;
    readonly status: FieldRef<'Queue', 'QueueStatus'>;
    readonly bookingSource: FieldRef<'Queue', 'String'>;
    readonly scheduledTime: FieldRef<'Queue', 'DateTime'>;
    readonly estimatedStartTime: FieldRef<'Queue', 'DateTime'>;
    readonly estimatedEndTime: FieldRef<'Queue', 'DateTime'>;
    readonly actualStartTime: FieldRef<'Queue', 'DateTime'>;
    readonly actualEndTime: FieldRef<'Queue', 'DateTime'>;
    readonly notified30m: FieldRef<'Queue', 'Boolean'>;
    readonly notified15m: FieldRef<'Queue', 'Boolean'>;
    readonly createdAt: FieldRef<'Queue', 'DateTime'>;
    readonly updatedAt: FieldRef<'Queue', 'DateTime'>;
    readonly deletedAt: FieldRef<'Queue', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Queue findUnique
   */
  export type QueueFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput;
  };

  /**
   * Queue findUniqueOrThrow
   */
  export type QueueFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter, which Queue to fetch.
     */
    where: QueueWhereUniqueInput;
  };

  /**
   * Queue findFirst
   */
  export type QueueFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Queues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Queue findFirstOrThrow
   */
  export type QueueFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter, which Queue to fetch.
     */
    where?: QueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Queues.
     */
    cursor?: QueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Queues.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Queues.
     */
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Queue findMany
   */
  export type QueueFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter, which Queues to fetch.
     */
    where?: QueueWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Queues to fetch.
     */
    orderBy?: QueueOrderByWithRelationInput | QueueOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Queues.
     */
    cursor?: QueueWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Queues from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Queues.
     */
    skip?: number;
    distinct?: QueueScalarFieldEnum | QueueScalarFieldEnum[];
  };

  /**
   * Queue create
   */
  export type QueueCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * The data needed to create a Queue.
     */
    data: XOR<QueueCreateInput, QueueUncheckedCreateInput>;
  };

  /**
   * Queue createMany
   */
  export type QueueCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Queue createManyAndReturn
   */
  export type QueueCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * The data used to create many Queues.
     */
    data: QueueCreateManyInput | QueueCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Queue update
   */
  export type QueueUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * The data needed to update a Queue.
     */
    data: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>;
    /**
     * Choose, which Queue to update.
     */
    where: QueueWhereUniqueInput;
  };

  /**
   * Queue updateMany
   */
  export type QueueUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>;
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput;
    /**
     * Limit how many Queues to update.
     */
    limit?: number;
  };

  /**
   * Queue updateManyAndReturn
   */
  export type QueueUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * The data used to update Queues.
     */
    data: XOR<QueueUpdateManyMutationInput, QueueUncheckedUpdateManyInput>;
    /**
     * Filter which Queues to update
     */
    where?: QueueWhereInput;
    /**
     * Limit how many Queues to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Queue upsert
   */
  export type QueueUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * The filter to search for the Queue to update in case it exists.
     */
    where: QueueWhereUniqueInput;
    /**
     * In case the Queue found by the `where` argument doesn't exist, create a new Queue with this data.
     */
    create: XOR<QueueCreateInput, QueueUncheckedCreateInput>;
    /**
     * In case the Queue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueUpdateInput, QueueUncheckedUpdateInput>;
  };

  /**
   * Queue delete
   */
  export type QueueDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    /**
     * Filter which Queue to delete.
     */
    where: QueueWhereUniqueInput;
  };

  /**
   * Queue deleteMany
   */
  export type QueueDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Queues to delete
     */
    where?: QueueWhereInput;
    /**
     * Limit how many Queues to delete.
     */
    limit?: number;
  };

  /**
   * Queue.barber
   */
  export type Queue$barberArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    where?: BarberWhereInput;
  };

  /**
   * Queue.customer
   */
  export type Queue$customerArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Queue.history
   */
  export type Queue$historyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    where?: QueueHistoryWhereInput;
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    cursor?: QueueHistoryWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: QueueHistoryScalarFieldEnum | QueueHistoryScalarFieldEnum[];
  };

  /**
   * Queue.reviews
   */
  export type Queue$reviewsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    where?: ReviewWhereInput;
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    cursor?: ReviewWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Queue without action
   */
  export type QueueDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
  };

  /**
   * Model QueueHistory
   */

  export type AggregateQueueHistory = {
    _count: QueueHistoryCountAggregateOutputType | null;
    _min: QueueHistoryMinAggregateOutputType | null;
    _max: QueueHistoryMaxAggregateOutputType | null;
  };

  export type QueueHistoryMinAggregateOutputType = {
    id: string | null;
    queueId: string | null;
    previousStatus: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus | null;
    changedById: string | null;
    notes: string | null;
    createdAt: Date | null;
  };

  export type QueueHistoryMaxAggregateOutputType = {
    id: string | null;
    queueId: string | null;
    previousStatus: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus | null;
    changedById: string | null;
    notes: string | null;
    createdAt: Date | null;
  };

  export type QueueHistoryCountAggregateOutputType = {
    id: number;
    queueId: number;
    previousStatus: number;
    newStatus: number;
    changedById: number;
    notes: number;
    createdAt: number;
    _all: number;
  };

  export type QueueHistoryMinAggregateInputType = {
    id?: true;
    queueId?: true;
    previousStatus?: true;
    newStatus?: true;
    changedById?: true;
    notes?: true;
    createdAt?: true;
  };

  export type QueueHistoryMaxAggregateInputType = {
    id?: true;
    queueId?: true;
    previousStatus?: true;
    newStatus?: true;
    changedById?: true;
    notes?: true;
    createdAt?: true;
  };

  export type QueueHistoryCountAggregateInputType = {
    id?: true;
    queueId?: true;
    previousStatus?: true;
    newStatus?: true;
    changedById?: true;
    notes?: true;
    createdAt?: true;
    _all?: true;
  };

  export type QueueHistoryAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which QueueHistory to aggregate.
     */
    where?: QueueHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QueueHistories to fetch.
     */
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: QueueHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QueueHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QueueHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned QueueHistories
     **/
    _count?: true | QueueHistoryCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: QueueHistoryMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: QueueHistoryMaxAggregateInputType;
  };

  export type GetQueueHistoryAggregateType<
    T extends QueueHistoryAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateQueueHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueHistory[P]>
      : GetScalarType<T[P], AggregateQueueHistory[P]>;
  };

  export type QueueHistoryGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: QueueHistoryWhereInput;
    orderBy?:
      | QueueHistoryOrderByWithAggregationInput
      | QueueHistoryOrderByWithAggregationInput[];
    by: QueueHistoryScalarFieldEnum[] | QueueHistoryScalarFieldEnum;
    having?: QueueHistoryScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: QueueHistoryCountAggregateInputType | true;
    _min?: QueueHistoryMinAggregateInputType;
    _max?: QueueHistoryMaxAggregateInputType;
  };

  export type QueueHistoryGroupByOutputType = {
    id: string;
    queueId: string;
    previousStatus: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    changedById: string | null;
    notes: string | null;
    createdAt: Date;
    _count: QueueHistoryCountAggregateOutputType | null;
    _min: QueueHistoryMinAggregateOutputType | null;
    _max: QueueHistoryMaxAggregateOutputType | null;
  };

  type GetQueueHistoryGroupByPayload<T extends QueueHistoryGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<QueueHistoryGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof QueueHistoryGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], QueueHistoryGroupByOutputType[P]>;
        }
      >
    >;

  export type QueueHistorySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      queueId?: boolean;
      previousStatus?: boolean;
      newStatus?: boolean;
      changedById?: boolean;
      notes?: boolean;
      createdAt?: boolean;
      queue?: boolean | QueueDefaultArgs<ExtArgs>;
      changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
    },
    ExtArgs['result']['queueHistory']
  >;

  export type QueueHistorySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      queueId?: boolean;
      previousStatus?: boolean;
      newStatus?: boolean;
      changedById?: boolean;
      notes?: boolean;
      createdAt?: boolean;
      queue?: boolean | QueueDefaultArgs<ExtArgs>;
      changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
    },
    ExtArgs['result']['queueHistory']
  >;

  export type QueueHistorySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      queueId?: boolean;
      previousStatus?: boolean;
      newStatus?: boolean;
      changedById?: boolean;
      notes?: boolean;
      createdAt?: boolean;
      queue?: boolean | QueueDefaultArgs<ExtArgs>;
      changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
    },
    ExtArgs['result']['queueHistory']
  >;

  export type QueueHistorySelectScalar = {
    id?: boolean;
    queueId?: boolean;
    previousStatus?: boolean;
    newStatus?: boolean;
    changedById?: boolean;
    notes?: boolean;
    createdAt?: boolean;
  };

  export type QueueHistoryOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'queueId'
    | 'previousStatus'
    | 'newStatus'
    | 'changedById'
    | 'notes'
    | 'createdAt',
    ExtArgs['result']['queueHistory']
  >;
  export type QueueHistoryInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    queue?: boolean | QueueDefaultArgs<ExtArgs>;
    changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
  };
  export type QueueHistoryIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    queue?: boolean | QueueDefaultArgs<ExtArgs>;
    changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
  };
  export type QueueHistoryIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    queue?: boolean | QueueDefaultArgs<ExtArgs>;
    changedBy?: boolean | QueueHistory$changedByArgs<ExtArgs>;
  };

  export type $QueueHistoryPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'QueueHistory';
    objects: {
      queue: Prisma.$QueuePayload<ExtArgs>;
      changedBy: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        queueId: string;
        previousStatus: $Enums.QueueStatus | null;
        newStatus: $Enums.QueueStatus;
        changedById: string | null;
        notes: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['queueHistory']
    >;
    composites: {};
  };

  type QueueHistoryGetPayload<
    S extends boolean | null | undefined | QueueHistoryDefaultArgs,
  > = $Result.GetResult<Prisma.$QueueHistoryPayload, S>;

  type QueueHistoryCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    QueueHistoryFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: QueueHistoryCountAggregateInputType | true;
  };

  export interface QueueHistoryDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['QueueHistory'];
      meta: { name: 'QueueHistory' };
    };
    /**
     * Find zero or one QueueHistory that matches the filter.
     * @param {QueueHistoryFindUniqueArgs} args - Arguments to find a QueueHistory
     * @example
     * // Get one QueueHistory
     * const queueHistory = await prisma.queueHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueHistoryFindUniqueArgs>(
      args: SelectSubset<T, QueueHistoryFindUniqueArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one QueueHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueHistoryFindUniqueOrThrowArgs} args - Arguments to find a QueueHistory
     * @example
     * // Get one QueueHistory
     * const queueHistory = await prisma.queueHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueHistoryFindUniqueOrThrowArgs>(
      args: SelectSubset<T, QueueHistoryFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first QueueHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryFindFirstArgs} args - Arguments to find a QueueHistory
     * @example
     * // Get one QueueHistory
     * const queueHistory = await prisma.queueHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueHistoryFindFirstArgs>(
      args?: SelectSubset<T, QueueHistoryFindFirstArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first QueueHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryFindFirstOrThrowArgs} args - Arguments to find a QueueHistory
     * @example
     * // Get one QueueHistory
     * const queueHistory = await prisma.queueHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueHistoryFindFirstOrThrowArgs>(
      args?: SelectSubset<T, QueueHistoryFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more QueueHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueHistories
     * const queueHistories = await prisma.queueHistory.findMany()
     *
     * // Get first 10 QueueHistories
     * const queueHistories = await prisma.queueHistory.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const queueHistoryWithIdOnly = await prisma.queueHistory.findMany({ select: { id: true } })
     *
     */
    findMany<T extends QueueHistoryFindManyArgs>(
      args?: SelectSubset<T, QueueHistoryFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a QueueHistory.
     * @param {QueueHistoryCreateArgs} args - Arguments to create a QueueHistory.
     * @example
     * // Create one QueueHistory
     * const QueueHistory = await prisma.queueHistory.create({
     *   data: {
     *     // ... data to create a QueueHistory
     *   }
     * })
     *
     */
    create<T extends QueueHistoryCreateArgs>(
      args: SelectSubset<T, QueueHistoryCreateArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many QueueHistories.
     * @param {QueueHistoryCreateManyArgs} args - Arguments to create many QueueHistories.
     * @example
     * // Create many QueueHistories
     * const queueHistory = await prisma.queueHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends QueueHistoryCreateManyArgs>(
      args?: SelectSubset<T, QueueHistoryCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many QueueHistories and returns the data saved in the database.
     * @param {QueueHistoryCreateManyAndReturnArgs} args - Arguments to create many QueueHistories.
     * @example
     * // Create many QueueHistories
     * const queueHistory = await prisma.queueHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many QueueHistories and only return the `id`
     * const queueHistoryWithIdOnly = await prisma.queueHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends QueueHistoryCreateManyAndReturnArgs>(
      args?: SelectSubset<T, QueueHistoryCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a QueueHistory.
     * @param {QueueHistoryDeleteArgs} args - Arguments to delete one QueueHistory.
     * @example
     * // Delete one QueueHistory
     * const QueueHistory = await prisma.queueHistory.delete({
     *   where: {
     *     // ... filter to delete one QueueHistory
     *   }
     * })
     *
     */
    delete<T extends QueueHistoryDeleteArgs>(
      args: SelectSubset<T, QueueHistoryDeleteArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one QueueHistory.
     * @param {QueueHistoryUpdateArgs} args - Arguments to update one QueueHistory.
     * @example
     * // Update one QueueHistory
     * const queueHistory = await prisma.queueHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends QueueHistoryUpdateArgs>(
      args: SelectSubset<T, QueueHistoryUpdateArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more QueueHistories.
     * @param {QueueHistoryDeleteManyArgs} args - Arguments to filter QueueHistories to delete.
     * @example
     * // Delete a few QueueHistories
     * const { count } = await prisma.queueHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends QueueHistoryDeleteManyArgs>(
      args?: SelectSubset<T, QueueHistoryDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more QueueHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueHistories
     * const queueHistory = await prisma.queueHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends QueueHistoryUpdateManyArgs>(
      args: SelectSubset<T, QueueHistoryUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more QueueHistories and returns the data updated in the database.
     * @param {QueueHistoryUpdateManyAndReturnArgs} args - Arguments to update many QueueHistories.
     * @example
     * // Update many QueueHistories
     * const queueHistory = await prisma.queueHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more QueueHistories and only return the `id`
     * const queueHistoryWithIdOnly = await prisma.queueHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends QueueHistoryUpdateManyAndReturnArgs>(
      args: SelectSubset<T, QueueHistoryUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one QueueHistory.
     * @param {QueueHistoryUpsertArgs} args - Arguments to update or create a QueueHistory.
     * @example
     * // Update or create a QueueHistory
     * const queueHistory = await prisma.queueHistory.upsert({
     *   create: {
     *     // ... data to create a QueueHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueHistory we want to update
     *   }
     * })
     */
    upsert<T extends QueueHistoryUpsertArgs>(
      args: SelectSubset<T, QueueHistoryUpsertArgs<ExtArgs>>,
    ): Prisma__QueueHistoryClient<
      $Result.GetResult<
        Prisma.$QueueHistoryPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of QueueHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryCountArgs} args - Arguments to filter QueueHistories to count.
     * @example
     * // Count the number of QueueHistories
     * const count = await prisma.queueHistory.count({
     *   where: {
     *     // ... the filter for the QueueHistories we want to count
     *   }
     * })
     **/
    count<T extends QueueHistoryCountArgs>(
      args?: Subset<T, QueueHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueHistoryCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a QueueHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends QueueHistoryAggregateArgs>(
      args: Subset<T, QueueHistoryAggregateArgs>,
    ): Prisma.PrismaPromise<GetQueueHistoryAggregateType<T>>;

    /**
     * Group by QueueHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends QueueHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueHistoryGroupByArgs['orderBy'] }
        : { orderBy?: QueueHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, QueueHistoryGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetQueueHistoryGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the QueueHistory model
     */
    readonly fields: QueueHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueHistoryClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    queue<T extends QueueDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, QueueDefaultArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      | $Result.GetResult<
          Prisma.$QueuePayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    changedBy<T extends QueueHistory$changedByArgs<ExtArgs> = {}>(
      args?: Subset<T, QueueHistory$changedByArgs<ExtArgs>>,
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the QueueHistory model
   */
  interface QueueHistoryFieldRefs {
    readonly id: FieldRef<'QueueHistory', 'String'>;
    readonly queueId: FieldRef<'QueueHistory', 'String'>;
    readonly previousStatus: FieldRef<'QueueHistory', 'QueueStatus'>;
    readonly newStatus: FieldRef<'QueueHistory', 'QueueStatus'>;
    readonly changedById: FieldRef<'QueueHistory', 'String'>;
    readonly notes: FieldRef<'QueueHistory', 'String'>;
    readonly createdAt: FieldRef<'QueueHistory', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * QueueHistory findUnique
   */
  export type QueueHistoryFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which QueueHistory to fetch.
     */
    where: QueueHistoryWhereUniqueInput;
  };

  /**
   * QueueHistory findUniqueOrThrow
   */
  export type QueueHistoryFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which QueueHistory to fetch.
     */
    where: QueueHistoryWhereUniqueInput;
  };

  /**
   * QueueHistory findFirst
   */
  export type QueueHistoryFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which QueueHistory to fetch.
     */
    where?: QueueHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QueueHistories to fetch.
     */
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for QueueHistories.
     */
    cursor?: QueueHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QueueHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QueueHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of QueueHistories.
     */
    distinct?: QueueHistoryScalarFieldEnum | QueueHistoryScalarFieldEnum[];
  };

  /**
   * QueueHistory findFirstOrThrow
   */
  export type QueueHistoryFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which QueueHistory to fetch.
     */
    where?: QueueHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QueueHistories to fetch.
     */
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for QueueHistories.
     */
    cursor?: QueueHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QueueHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QueueHistories.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of QueueHistories.
     */
    distinct?: QueueHistoryScalarFieldEnum | QueueHistoryScalarFieldEnum[];
  };

  /**
   * QueueHistory findMany
   */
  export type QueueHistoryFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter, which QueueHistories to fetch.
     */
    where?: QueueHistoryWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of QueueHistories to fetch.
     */
    orderBy?:
      | QueueHistoryOrderByWithRelationInput
      | QueueHistoryOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing QueueHistories.
     */
    cursor?: QueueHistoryWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` QueueHistories from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` QueueHistories.
     */
    skip?: number;
    distinct?: QueueHistoryScalarFieldEnum | QueueHistoryScalarFieldEnum[];
  };

  /**
   * QueueHistory create
   */
  export type QueueHistoryCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to create a QueueHistory.
     */
    data: XOR<QueueHistoryCreateInput, QueueHistoryUncheckedCreateInput>;
  };

  /**
   * QueueHistory createMany
   */
  export type QueueHistoryCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many QueueHistories.
     */
    data: QueueHistoryCreateManyInput | QueueHistoryCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * QueueHistory createManyAndReturn
   */
  export type QueueHistoryCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * The data used to create many QueueHistories.
     */
    data: QueueHistoryCreateManyInput | QueueHistoryCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * QueueHistory update
   */
  export type QueueHistoryUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * The data needed to update a QueueHistory.
     */
    data: XOR<QueueHistoryUpdateInput, QueueHistoryUncheckedUpdateInput>;
    /**
     * Choose, which QueueHistory to update.
     */
    where: QueueHistoryWhereUniqueInput;
  };

  /**
   * QueueHistory updateMany
   */
  export type QueueHistoryUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update QueueHistories.
     */
    data: XOR<
      QueueHistoryUpdateManyMutationInput,
      QueueHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which QueueHistories to update
     */
    where?: QueueHistoryWhereInput;
    /**
     * Limit how many QueueHistories to update.
     */
    limit?: number;
  };

  /**
   * QueueHistory updateManyAndReturn
   */
  export type QueueHistoryUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * The data used to update QueueHistories.
     */
    data: XOR<
      QueueHistoryUpdateManyMutationInput,
      QueueHistoryUncheckedUpdateManyInput
    >;
    /**
     * Filter which QueueHistories to update
     */
    where?: QueueHistoryWhereInput;
    /**
     * Limit how many QueueHistories to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * QueueHistory upsert
   */
  export type QueueHistoryUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * The filter to search for the QueueHistory to update in case it exists.
     */
    where: QueueHistoryWhereUniqueInput;
    /**
     * In case the QueueHistory found by the `where` argument doesn't exist, create a new QueueHistory with this data.
     */
    create: XOR<QueueHistoryCreateInput, QueueHistoryUncheckedCreateInput>;
    /**
     * In case the QueueHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueHistoryUpdateInput, QueueHistoryUncheckedUpdateInput>;
  };

  /**
   * QueueHistory delete
   */
  export type QueueHistoryDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
    /**
     * Filter which QueueHistory to delete.
     */
    where: QueueHistoryWhereUniqueInput;
  };

  /**
   * QueueHistory deleteMany
   */
  export type QueueHistoryDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which QueueHistories to delete
     */
    where?: QueueHistoryWhereInput;
    /**
     * Limit how many QueueHistories to delete.
     */
    limit?: number;
  };

  /**
   * QueueHistory.changedBy
   */
  export type QueueHistory$changedByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * QueueHistory without action
   */
  export type QueueHistoryDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the QueueHistory
     */
    select?: QueueHistorySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the QueueHistory
     */
    omit?: QueueHistoryOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueHistoryInclude<ExtArgs> | null;
  };

  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  export type ReviewAvgAggregateOutputType = {
    rating: number | null;
  };

  export type ReviewSumAggregateOutputType = {
    rating: number | null;
  };

  export type ReviewMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    barberId: string | null;
    customerId: string | null;
    queueId: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
  };

  export type ReviewMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    barberId: string | null;
    customerId: string | null;
    queueId: string | null;
    rating: number | null;
    comment: string | null;
    createdAt: Date | null;
  };

  export type ReviewCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    barberId: number;
    customerId: number;
    queueId: number;
    rating: number;
    comment: number;
    createdAt: number;
    _all: number;
  };

  export type ReviewAvgAggregateInputType = {
    rating?: true;
  };

  export type ReviewSumAggregateInputType = {
    rating?: true;
  };

  export type ReviewMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    queueId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
  };

  export type ReviewMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    queueId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
  };

  export type ReviewCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    barberId?: true;
    customerId?: true;
    queueId?: true;
    rating?: true;
    comment?: true;
    createdAt?: true;
    _all?: true;
  };

  export type ReviewAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Reviews
     **/
    _count?: true | ReviewCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ReviewAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ReviewSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ReviewMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ReviewMaxAggregateInputType;
  };

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
    [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>;
  };

  export type ReviewGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ReviewWhereInput;
    orderBy?:
      | ReviewOrderByWithAggregationInput
      | ReviewOrderByWithAggregationInput[];
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum;
    having?: ReviewScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ReviewCountAggregateInputType | true;
    _avg?: ReviewAvgAggregateInputType;
    _sum?: ReviewSumAggregateInputType;
    _min?: ReviewMinAggregateInputType;
    _max?: ReviewMaxAggregateInputType;
  };

  export type ReviewGroupByOutputType = {
    id: string;
    barbershopId: string;
    barberId: string | null;
    customerId: string;
    queueId: string | null;
    rating: number;
    comment: string | null;
    createdAt: Date;
    _count: ReviewCountAggregateOutputType | null;
    _avg: ReviewAvgAggregateOutputType | null;
    _sum: ReviewSumAggregateOutputType | null;
    _min: ReviewMinAggregateOutputType | null;
    _max: ReviewMaxAggregateOutputType | null;
  };

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ReviewGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ReviewGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>;
        }
      >
    >;

  export type ReviewSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      queueId?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Review$barberArgs<ExtArgs>;
      customer?: boolean | UserDefaultArgs<ExtArgs>;
      queue?: boolean | Review$queueArgs<ExtArgs>;
    },
    ExtArgs['result']['review']
  >;

  export type ReviewSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      queueId?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Review$barberArgs<ExtArgs>;
      customer?: boolean | UserDefaultArgs<ExtArgs>;
      queue?: boolean | Review$queueArgs<ExtArgs>;
    },
    ExtArgs['result']['review']
  >;

  export type ReviewSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      barberId?: boolean;
      customerId?: boolean;
      queueId?: boolean;
      rating?: boolean;
      comment?: boolean;
      createdAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
      barber?: boolean | Review$barberArgs<ExtArgs>;
      customer?: boolean | UserDefaultArgs<ExtArgs>;
      queue?: boolean | Review$queueArgs<ExtArgs>;
    },
    ExtArgs['result']['review']
  >;

  export type ReviewSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    barberId?: boolean;
    customerId?: boolean;
    queueId?: boolean;
    rating?: boolean;
    comment?: boolean;
    createdAt?: boolean;
  };

  export type ReviewOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'barberId'
    | 'customerId'
    | 'queueId'
    | 'rating'
    | 'comment'
    | 'createdAt',
    ExtArgs['result']['review']
  >;
  export type ReviewInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Review$barberArgs<ExtArgs>;
    customer?: boolean | UserDefaultArgs<ExtArgs>;
    queue?: boolean | Review$queueArgs<ExtArgs>;
  };
  export type ReviewIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Review$barberArgs<ExtArgs>;
    customer?: boolean | UserDefaultArgs<ExtArgs>;
    queue?: boolean | Review$queueArgs<ExtArgs>;
  };
  export type ReviewIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    barber?: boolean | Review$barberArgs<ExtArgs>;
    customer?: boolean | UserDefaultArgs<ExtArgs>;
    queue?: boolean | Review$queueArgs<ExtArgs>;
  };

  export type $ReviewPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Review';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
      barber: Prisma.$BarberPayload<ExtArgs> | null;
      customer: Prisma.$UserPayload<ExtArgs>;
      queue: Prisma.$QueuePayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        barberId: string | null;
        customerId: string;
        queueId: string | null;
        rating: number;
        comment: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['review']
    >;
    composites: {};
  };

  type ReviewGetPayload<
    S extends boolean | null | undefined | ReviewDefaultArgs,
  > = $Result.GetResult<Prisma.$ReviewPayload, S>;

  type ReviewCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: ReviewCountAggregateInputType | true;
  };

  export interface ReviewDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Review'];
      meta: { name: 'Review' };
    };
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     *
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReviewFindManyArgs>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     *
     */
    create<T extends ReviewCreateArgs>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReviewCreateManyArgs>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(
      args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     *
     */
    delete<T extends ReviewDeleteArgs>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReviewUpdateArgs>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReviewDeleteManyArgs>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReviewUpdateManyArgs>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(
      args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>,
    ): Prisma__ReviewClient<
      $Result.GetResult<
        Prisma.$ReviewPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
     **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ReviewAggregateArgs>(
      args: Subset<T, ReviewAggregateArgs>,
    ): Prisma.PrismaPromise<GetReviewAggregateType<T>>;

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors,
    ): {} extends InputErrors
      ? GetReviewGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Review model
     */
    readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    barber<T extends Review$barberArgs<ExtArgs> = {}>(
      args?: Subset<T, Review$barberArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      $Result.GetResult<
        Prisma.$BarberPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>,
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    queue<T extends Review$queueArgs<ExtArgs> = {}>(
      args?: Subset<T, Review$queueArgs<ExtArgs>>,
    ): Prisma__QueueClient<
      $Result.GetResult<
        Prisma.$QueuePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<'Review', 'String'>;
    readonly barbershopId: FieldRef<'Review', 'String'>;
    readonly barberId: FieldRef<'Review', 'String'>;
    readonly customerId: FieldRef<'Review', 'String'>;
    readonly queueId: FieldRef<'Review', 'String'>;
    readonly rating: FieldRef<'Review', 'Int'>;
    readonly comment: FieldRef<'Review', 'String'>;
    readonly createdAt: FieldRef<'Review', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Reviews.
     */
    skip?: number;
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[];
  };

  /**
   * Review create
   */
  export type ReviewCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
  };

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review update
   */
  export type ReviewUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
  };

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>;
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput;
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>;
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>;
  };

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput;
  };

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput;
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number;
  };

  /**
   * Review.barber
   */
  export type Review$barberArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Barber
     */
    select?: BarberSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Barber
     */
    omit?: BarberOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberInclude<ExtArgs> | null;
    where?: BarberWhereInput;
  };

  /**
   * Review.queue
   */
  export type Review$queueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Queue
     */
    select?: QueueSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Queue
     */
    omit?: QueueOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueInclude<ExtArgs> | null;
    where?: QueueWhereInput;
  };

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null;
  };

  /**
   * Model BarberSchedule
   */

  export type AggregateBarberSchedule = {
    _count: BarberScheduleCountAggregateOutputType | null;
    _avg: BarberScheduleAvgAggregateOutputType | null;
    _sum: BarberScheduleSumAggregateOutputType | null;
    _min: BarberScheduleMinAggregateOutputType | null;
    _max: BarberScheduleMaxAggregateOutputType | null;
  };

  export type BarberScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null;
  };

  export type BarberScheduleSumAggregateOutputType = {
    dayOfWeek: number | null;
  };

  export type BarberScheduleMinAggregateOutputType = {
    id: string | null;
    barberId: string | null;
    dayOfWeek: number | null;
    startTime: string | null;
    endTime: string | null;
    isActive: boolean | null;
  };

  export type BarberScheduleMaxAggregateOutputType = {
    id: string | null;
    barberId: string | null;
    dayOfWeek: number | null;
    startTime: string | null;
    endTime: string | null;
    isActive: boolean | null;
  };

  export type BarberScheduleCountAggregateOutputType = {
    id: number;
    barberId: number;
    dayOfWeek: number;
    startTime: number;
    endTime: number;
    isActive: number;
    _all: number;
  };

  export type BarberScheduleAvgAggregateInputType = {
    dayOfWeek?: true;
  };

  export type BarberScheduleSumAggregateInputType = {
    dayOfWeek?: true;
  };

  export type BarberScheduleMinAggregateInputType = {
    id?: true;
    barberId?: true;
    dayOfWeek?: true;
    startTime?: true;
    endTime?: true;
    isActive?: true;
  };

  export type BarberScheduleMaxAggregateInputType = {
    id?: true;
    barberId?: true;
    dayOfWeek?: true;
    startTime?: true;
    endTime?: true;
    isActive?: true;
  };

  export type BarberScheduleCountAggregateInputType = {
    id?: true;
    barberId?: true;
    dayOfWeek?: true;
    startTime?: true;
    endTime?: true;
    isActive?: true;
    _all?: true;
  };

  export type BarberScheduleAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarberSchedule to aggregate.
     */
    where?: BarberScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberSchedules to fetch.
     */
    orderBy?:
      | BarberScheduleOrderByWithRelationInput
      | BarberScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BarberScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberSchedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberSchedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BarberSchedules
     **/
    _count?: true | BarberScheduleCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: BarberScheduleAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: BarberScheduleSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BarberScheduleMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BarberScheduleMaxAggregateInputType;
  };

  export type GetBarberScheduleAggregateType<
    T extends BarberScheduleAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateBarberSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarberSchedule[P]>
      : GetScalarType<T[P], AggregateBarberSchedule[P]>;
  };

  export type BarberScheduleGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarberScheduleWhereInput;
    orderBy?:
      | BarberScheduleOrderByWithAggregationInput
      | BarberScheduleOrderByWithAggregationInput[];
    by: BarberScheduleScalarFieldEnum[] | BarberScheduleScalarFieldEnum;
    having?: BarberScheduleScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BarberScheduleCountAggregateInputType | true;
    _avg?: BarberScheduleAvgAggregateInputType;
    _sum?: BarberScheduleSumAggregateInputType;
    _min?: BarberScheduleMinAggregateInputType;
    _max?: BarberScheduleMaxAggregateInputType;
  };

  export type BarberScheduleGroupByOutputType = {
    id: string;
    barberId: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive: boolean;
    _count: BarberScheduleCountAggregateOutputType | null;
    _avg: BarberScheduleAvgAggregateOutputType | null;
    _sum: BarberScheduleSumAggregateOutputType | null;
    _min: BarberScheduleMinAggregateOutputType | null;
    _max: BarberScheduleMaxAggregateOutputType | null;
  };

  type GetBarberScheduleGroupByPayload<T extends BarberScheduleGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<BarberScheduleGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof BarberScheduleGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BarberScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], BarberScheduleGroupByOutputType[P]>;
        }
      >
    >;

  export type BarberScheduleSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barberId?: boolean;
      dayOfWeek?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      isActive?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberSchedule']
  >;

  export type BarberScheduleSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barberId?: boolean;
      dayOfWeek?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      isActive?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberSchedule']
  >;

  export type BarberScheduleSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barberId?: boolean;
      dayOfWeek?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      isActive?: boolean;
      barber?: boolean | BarberDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barberSchedule']
  >;

  export type BarberScheduleSelectScalar = {
    id?: boolean;
    barberId?: boolean;
    dayOfWeek?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    isActive?: boolean;
  };

  export type BarberScheduleOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'barberId' | 'dayOfWeek' | 'startTime' | 'endTime' | 'isActive',
    ExtArgs['result']['barberSchedule']
  >;
  export type BarberScheduleInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
  };
  export type BarberScheduleIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
  };
  export type BarberScheduleIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barber?: boolean | BarberDefaultArgs<ExtArgs>;
  };

  export type $BarberSchedulePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'BarberSchedule';
    objects: {
      barber: Prisma.$BarberPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barberId: string;
        dayOfWeek: number;
        startTime: string;
        endTime: string;
        isActive: boolean;
      },
      ExtArgs['result']['barberSchedule']
    >;
    composites: {};
  };

  type BarberScheduleGetPayload<
    S extends boolean | null | undefined | BarberScheduleDefaultArgs,
  > = $Result.GetResult<Prisma.$BarberSchedulePayload, S>;

  type BarberScheduleCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    BarberScheduleFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: BarberScheduleCountAggregateInputType | true;
  };

  export interface BarberScheduleDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['BarberSchedule'];
      meta: { name: 'BarberSchedule' };
    };
    /**
     * Find zero or one BarberSchedule that matches the filter.
     * @param {BarberScheduleFindUniqueArgs} args - Arguments to find a BarberSchedule
     * @example
     * // Get one BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarberScheduleFindUniqueArgs>(
      args: SelectSubset<T, BarberScheduleFindUniqueArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one BarberSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarberScheduleFindUniqueOrThrowArgs} args - Arguments to find a BarberSchedule
     * @example
     * // Get one BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarberScheduleFindUniqueOrThrowArgs>(
      args: SelectSubset<T, BarberScheduleFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarberSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleFindFirstArgs} args - Arguments to find a BarberSchedule
     * @example
     * // Get one BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarberScheduleFindFirstArgs>(
      args?: SelectSubset<T, BarberScheduleFindFirstArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarberSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleFindFirstOrThrowArgs} args - Arguments to find a BarberSchedule
     * @example
     * // Get one BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarberScheduleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, BarberScheduleFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more BarberSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarberSchedules
     * const barberSchedules = await prisma.barberSchedule.findMany()
     *
     * // Get first 10 BarberSchedules
     * const barberSchedules = await prisma.barberSchedule.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const barberScheduleWithIdOnly = await prisma.barberSchedule.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BarberScheduleFindManyArgs>(
      args?: SelectSubset<T, BarberScheduleFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a BarberSchedule.
     * @param {BarberScheduleCreateArgs} args - Arguments to create a BarberSchedule.
     * @example
     * // Create one BarberSchedule
     * const BarberSchedule = await prisma.barberSchedule.create({
     *   data: {
     *     // ... data to create a BarberSchedule
     *   }
     * })
     *
     */
    create<T extends BarberScheduleCreateArgs>(
      args: SelectSubset<T, BarberScheduleCreateArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many BarberSchedules.
     * @param {BarberScheduleCreateManyArgs} args - Arguments to create many BarberSchedules.
     * @example
     * // Create many BarberSchedules
     * const barberSchedule = await prisma.barberSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BarberScheduleCreateManyArgs>(
      args?: SelectSubset<T, BarberScheduleCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many BarberSchedules and returns the data saved in the database.
     * @param {BarberScheduleCreateManyAndReturnArgs} args - Arguments to create many BarberSchedules.
     * @example
     * // Create many BarberSchedules
     * const barberSchedule = await prisma.barberSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many BarberSchedules and only return the `id`
     * const barberScheduleWithIdOnly = await prisma.barberSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends BarberScheduleCreateManyAndReturnArgs>(
      args?: SelectSubset<T, BarberScheduleCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a BarberSchedule.
     * @param {BarberScheduleDeleteArgs} args - Arguments to delete one BarberSchedule.
     * @example
     * // Delete one BarberSchedule
     * const BarberSchedule = await prisma.barberSchedule.delete({
     *   where: {
     *     // ... filter to delete one BarberSchedule
     *   }
     * })
     *
     */
    delete<T extends BarberScheduleDeleteArgs>(
      args: SelectSubset<T, BarberScheduleDeleteArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one BarberSchedule.
     * @param {BarberScheduleUpdateArgs} args - Arguments to update one BarberSchedule.
     * @example
     * // Update one BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BarberScheduleUpdateArgs>(
      args: SelectSubset<T, BarberScheduleUpdateArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more BarberSchedules.
     * @param {BarberScheduleDeleteManyArgs} args - Arguments to filter BarberSchedules to delete.
     * @example
     * // Delete a few BarberSchedules
     * const { count } = await prisma.barberSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BarberScheduleDeleteManyArgs>(
      args?: SelectSubset<T, BarberScheduleDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarberSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarberSchedules
     * const barberSchedule = await prisma.barberSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BarberScheduleUpdateManyArgs>(
      args: SelectSubset<T, BarberScheduleUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarberSchedules and returns the data updated in the database.
     * @param {BarberScheduleUpdateManyAndReturnArgs} args - Arguments to update many BarberSchedules.
     * @example
     * // Update many BarberSchedules
     * const barberSchedule = await prisma.barberSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more BarberSchedules and only return the `id`
     * const barberScheduleWithIdOnly = await prisma.barberSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends BarberScheduleUpdateManyAndReturnArgs>(
      args: SelectSubset<T, BarberScheduleUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one BarberSchedule.
     * @param {BarberScheduleUpsertArgs} args - Arguments to update or create a BarberSchedule.
     * @example
     * // Update or create a BarberSchedule
     * const barberSchedule = await prisma.barberSchedule.upsert({
     *   create: {
     *     // ... data to create a BarberSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarberSchedule we want to update
     *   }
     * })
     */
    upsert<T extends BarberScheduleUpsertArgs>(
      args: SelectSubset<T, BarberScheduleUpsertArgs<ExtArgs>>,
    ): Prisma__BarberScheduleClient<
      $Result.GetResult<
        Prisma.$BarberSchedulePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of BarberSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleCountArgs} args - Arguments to filter BarberSchedules to count.
     * @example
     * // Count the number of BarberSchedules
     * const count = await prisma.barberSchedule.count({
     *   where: {
     *     // ... the filter for the BarberSchedules we want to count
     *   }
     * })
     **/
    count<T extends BarberScheduleCountArgs>(
      args?: Subset<T, BarberScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BarberScheduleCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a BarberSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BarberScheduleAggregateArgs>(
      args: Subset<T, BarberScheduleAggregateArgs>,
    ): Prisma.PrismaPromise<GetBarberScheduleAggregateType<T>>;

    /**
     * Group by BarberSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarberScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BarberScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarberScheduleGroupByArgs['orderBy'] }
        : { orderBy?: BarberScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, BarberScheduleGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetBarberScheduleGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the BarberSchedule model
     */
    readonly fields: BarberScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarberSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarberScheduleClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barber<T extends BarberDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarberDefaultArgs<ExtArgs>>,
    ): Prisma__BarberClient<
      | $Result.GetResult<
          Prisma.$BarberPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the BarberSchedule model
   */
  interface BarberScheduleFieldRefs {
    readonly id: FieldRef<'BarberSchedule', 'String'>;
    readonly barberId: FieldRef<'BarberSchedule', 'String'>;
    readonly dayOfWeek: FieldRef<'BarberSchedule', 'Int'>;
    readonly startTime: FieldRef<'BarberSchedule', 'String'>;
    readonly endTime: FieldRef<'BarberSchedule', 'String'>;
    readonly isActive: FieldRef<'BarberSchedule', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * BarberSchedule findUnique
   */
  export type BarberScheduleFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which BarberSchedule to fetch.
     */
    where: BarberScheduleWhereUniqueInput;
  };

  /**
   * BarberSchedule findUniqueOrThrow
   */
  export type BarberScheduleFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which BarberSchedule to fetch.
     */
    where: BarberScheduleWhereUniqueInput;
  };

  /**
   * BarberSchedule findFirst
   */
  export type BarberScheduleFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which BarberSchedule to fetch.
     */
    where?: BarberScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberSchedules to fetch.
     */
    orderBy?:
      | BarberScheduleOrderByWithRelationInput
      | BarberScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarberSchedules.
     */
    cursor?: BarberScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberSchedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberSchedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarberSchedules.
     */
    distinct?: BarberScheduleScalarFieldEnum | BarberScheduleScalarFieldEnum[];
  };

  /**
   * BarberSchedule findFirstOrThrow
   */
  export type BarberScheduleFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which BarberSchedule to fetch.
     */
    where?: BarberScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberSchedules to fetch.
     */
    orderBy?:
      | BarberScheduleOrderByWithRelationInput
      | BarberScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarberSchedules.
     */
    cursor?: BarberScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberSchedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberSchedules.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarberSchedules.
     */
    distinct?: BarberScheduleScalarFieldEnum | BarberScheduleScalarFieldEnum[];
  };

  /**
   * BarberSchedule findMany
   */
  export type BarberScheduleFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter, which BarberSchedules to fetch.
     */
    where?: BarberScheduleWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarberSchedules to fetch.
     */
    orderBy?:
      | BarberScheduleOrderByWithRelationInput
      | BarberScheduleOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BarberSchedules.
     */
    cursor?: BarberScheduleWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarberSchedules from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarberSchedules.
     */
    skip?: number;
    distinct?: BarberScheduleScalarFieldEnum | BarberScheduleScalarFieldEnum[];
  };

  /**
   * BarberSchedule create
   */
  export type BarberScheduleCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * The data needed to create a BarberSchedule.
     */
    data: XOR<BarberScheduleCreateInput, BarberScheduleUncheckedCreateInput>;
  };

  /**
   * BarberSchedule createMany
   */
  export type BarberScheduleCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many BarberSchedules.
     */
    data: BarberScheduleCreateManyInput | BarberScheduleCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * BarberSchedule createManyAndReturn
   */
  export type BarberScheduleCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * The data used to create many BarberSchedules.
     */
    data: BarberScheduleCreateManyInput | BarberScheduleCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarberSchedule update
   */
  export type BarberScheduleUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * The data needed to update a BarberSchedule.
     */
    data: XOR<BarberScheduleUpdateInput, BarberScheduleUncheckedUpdateInput>;
    /**
     * Choose, which BarberSchedule to update.
     */
    where: BarberScheduleWhereUniqueInput;
  };

  /**
   * BarberSchedule updateMany
   */
  export type BarberScheduleUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update BarberSchedules.
     */
    data: XOR<
      BarberScheduleUpdateManyMutationInput,
      BarberScheduleUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarberSchedules to update
     */
    where?: BarberScheduleWhereInput;
    /**
     * Limit how many BarberSchedules to update.
     */
    limit?: number;
  };

  /**
   * BarberSchedule updateManyAndReturn
   */
  export type BarberScheduleUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * The data used to update BarberSchedules.
     */
    data: XOR<
      BarberScheduleUpdateManyMutationInput,
      BarberScheduleUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarberSchedules to update
     */
    where?: BarberScheduleWhereInput;
    /**
     * Limit how many BarberSchedules to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarberSchedule upsert
   */
  export type BarberScheduleUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * The filter to search for the BarberSchedule to update in case it exists.
     */
    where: BarberScheduleWhereUniqueInput;
    /**
     * In case the BarberSchedule found by the `where` argument doesn't exist, create a new BarberSchedule with this data.
     */
    create: XOR<BarberScheduleCreateInput, BarberScheduleUncheckedCreateInput>;
    /**
     * In case the BarberSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BarberScheduleUpdateInput, BarberScheduleUncheckedUpdateInput>;
  };

  /**
   * BarberSchedule delete
   */
  export type BarberScheduleDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
    /**
     * Filter which BarberSchedule to delete.
     */
    where: BarberScheduleWhereUniqueInput;
  };

  /**
   * BarberSchedule deleteMany
   */
  export type BarberScheduleDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarberSchedules to delete
     */
    where?: BarberScheduleWhereInput;
    /**
     * Limit how many BarberSchedules to delete.
     */
    limit?: number;
  };

  /**
   * BarberSchedule without action
   */
  export type BarberScheduleDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarberSchedule
     */
    select?: BarberScheduleSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarberSchedule
     */
    omit?: BarberScheduleOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarberScheduleInclude<ExtArgs> | null;
  };

  /**
   * Model SubscriptionPlan
   */

  export type AggregateSubscriptionPlan = {
    _count: SubscriptionPlanCountAggregateOutputType | null;
    _avg: SubscriptionPlanAvgAggregateOutputType | null;
    _sum: SubscriptionPlanSumAggregateOutputType | null;
    _min: SubscriptionPlanMinAggregateOutputType | null;
    _max: SubscriptionPlanMaxAggregateOutputType | null;
  };

  export type SubscriptionPlanAvgAggregateOutputType = {
    price: number | null;
  };

  export type SubscriptionPlanSumAggregateOutputType = {
    price: number | null;
  };

  export type SubscriptionPlanMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    price: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SubscriptionPlanMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    price: number | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type SubscriptionPlanCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    price: number;
    features: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type SubscriptionPlanAvgAggregateInputType = {
    price?: true;
  };

  export type SubscriptionPlanSumAggregateInputType = {
    price?: true;
  };

  export type SubscriptionPlanMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    price?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SubscriptionPlanMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    price?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type SubscriptionPlanCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    price?: true;
    features?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type SubscriptionPlanAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SubscriptionPlan to aggregate.
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?:
      | SubscriptionPlanOrderByWithRelationInput
      | SubscriptionPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SubscriptionPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SubscriptionPlans
     **/
    _count?: true | SubscriptionPlanCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: SubscriptionPlanAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: SubscriptionPlanSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: SubscriptionPlanMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: SubscriptionPlanMaxAggregateInputType;
  };

  export type GetSubscriptionPlanAggregateType<
    T extends SubscriptionPlanAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateSubscriptionPlan]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptionPlan[P]>
      : GetScalarType<T[P], AggregateSubscriptionPlan[P]>;
  };

  export type SubscriptionPlanGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: SubscriptionPlanWhereInput;
    orderBy?:
      | SubscriptionPlanOrderByWithAggregationInput
      | SubscriptionPlanOrderByWithAggregationInput[];
    by: SubscriptionPlanScalarFieldEnum[] | SubscriptionPlanScalarFieldEnum;
    having?: SubscriptionPlanScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: SubscriptionPlanCountAggregateInputType | true;
    _avg?: SubscriptionPlanAvgAggregateInputType;
    _sum?: SubscriptionPlanSumAggregateInputType;
    _min?: SubscriptionPlanMinAggregateInputType;
    _max?: SubscriptionPlanMaxAggregateInputType;
  };

  export type SubscriptionPlanGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    price: number;
    features: JsonValue;
    createdAt: Date;
    updatedAt: Date;
    _count: SubscriptionPlanCountAggregateOutputType | null;
    _avg: SubscriptionPlanAvgAggregateOutputType | null;
    _sum: SubscriptionPlanSumAggregateOutputType | null;
    _min: SubscriptionPlanMinAggregateOutputType | null;
    _max: SubscriptionPlanMaxAggregateOutputType | null;
  };

  type GetSubscriptionPlanGroupByPayload<
    T extends SubscriptionPlanGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionPlanGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof SubscriptionPlanGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>
          : GetScalarType<T[P], SubscriptionPlanGroupByOutputType[P]>;
      }
    >
  >;

  export type SubscriptionPlanSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      price?: boolean;
      features?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['subscriptionPlan']
  >;

  export type SubscriptionPlanSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      price?: boolean;
      features?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['subscriptionPlan']
  >;

  export type SubscriptionPlanSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      price?: boolean;
      features?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['subscriptionPlan']
  >;

  export type SubscriptionPlanSelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    price?: boolean;
    features?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type SubscriptionPlanOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'description'
    | 'price'
    | 'features'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['subscriptionPlan']
  >;

  export type $SubscriptionPlanPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'SubscriptionPlan';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        price: number;
        features: Prisma.JsonValue;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['subscriptionPlan']
    >;
    composites: {};
  };

  type SubscriptionPlanGetPayload<
    S extends boolean | null | undefined | SubscriptionPlanDefaultArgs,
  > = $Result.GetResult<Prisma.$SubscriptionPlanPayload, S>;

  type SubscriptionPlanCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    SubscriptionPlanFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: SubscriptionPlanCountAggregateInputType | true;
  };

  export interface SubscriptionPlanDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['SubscriptionPlan'];
      meta: { name: 'SubscriptionPlan' };
    };
    /**
     * Find zero or one SubscriptionPlan that matches the filter.
     * @param {SubscriptionPlanFindUniqueArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionPlanFindUniqueArgs>(
      args: SelectSubset<T, SubscriptionPlanFindUniqueArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one SubscriptionPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionPlanFindUniqueOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionPlanFindUniqueOrThrowArgs>(
      args: SelectSubset<T, SubscriptionPlanFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SubscriptionPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionPlanFindFirstArgs>(
      args?: SelectSubset<T, SubscriptionPlanFindFirstArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first SubscriptionPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindFirstOrThrowArgs} args - Arguments to find a SubscriptionPlan
     * @example
     * // Get one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionPlanFindFirstOrThrowArgs>(
      args?: SelectSubset<T, SubscriptionPlanFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more SubscriptionPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany()
     *
     * // Get first 10 SubscriptionPlans
     * const subscriptionPlans = await prisma.subscriptionPlan.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SubscriptionPlanFindManyArgs>(
      args?: SelectSubset<T, SubscriptionPlanFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a SubscriptionPlan.
     * @param {SubscriptionPlanCreateArgs} args - Arguments to create a SubscriptionPlan.
     * @example
     * // Create one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.create({
     *   data: {
     *     // ... data to create a SubscriptionPlan
     *   }
     * })
     *
     */
    create<T extends SubscriptionPlanCreateArgs>(
      args: SelectSubset<T, SubscriptionPlanCreateArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many SubscriptionPlans.
     * @param {SubscriptionPlanCreateManyArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SubscriptionPlanCreateManyArgs>(
      args?: SelectSubset<T, SubscriptionPlanCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many SubscriptionPlans and returns the data saved in the database.
     * @param {SubscriptionPlanCreateManyAndReturnArgs} args - Arguments to create many SubscriptionPlans.
     * @example
     * // Create many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SubscriptionPlanCreateManyAndReturnArgs>(
      args?: SelectSubset<T, SubscriptionPlanCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a SubscriptionPlan.
     * @param {SubscriptionPlanDeleteArgs} args - Arguments to delete one SubscriptionPlan.
     * @example
     * // Delete one SubscriptionPlan
     * const SubscriptionPlan = await prisma.subscriptionPlan.delete({
     *   where: {
     *     // ... filter to delete one SubscriptionPlan
     *   }
     * })
     *
     */
    delete<T extends SubscriptionPlanDeleteArgs>(
      args: SelectSubset<T, SubscriptionPlanDeleteArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one SubscriptionPlan.
     * @param {SubscriptionPlanUpdateArgs} args - Arguments to update one SubscriptionPlan.
     * @example
     * // Update one SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SubscriptionPlanUpdateArgs>(
      args: SelectSubset<T, SubscriptionPlanUpdateArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more SubscriptionPlans.
     * @param {SubscriptionPlanDeleteManyArgs} args - Arguments to filter SubscriptionPlans to delete.
     * @example
     * // Delete a few SubscriptionPlans
     * const { count } = await prisma.subscriptionPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SubscriptionPlanDeleteManyArgs>(
      args?: SelectSubset<T, SubscriptionPlanDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SubscriptionPlanUpdateManyArgs>(
      args: SelectSubset<T, SubscriptionPlanUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more SubscriptionPlans and returns the data updated in the database.
     * @param {SubscriptionPlanUpdateManyAndReturnArgs} args - Arguments to update many SubscriptionPlans.
     * @example
     * // Update many SubscriptionPlans
     * const subscriptionPlan = await prisma.subscriptionPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SubscriptionPlans and only return the `id`
     * const subscriptionPlanWithIdOnly = await prisma.subscriptionPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SubscriptionPlanUpdateManyAndReturnArgs>(
      args: SelectSubset<T, SubscriptionPlanUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one SubscriptionPlan.
     * @param {SubscriptionPlanUpsertArgs} args - Arguments to update or create a SubscriptionPlan.
     * @example
     * // Update or create a SubscriptionPlan
     * const subscriptionPlan = await prisma.subscriptionPlan.upsert({
     *   create: {
     *     // ... data to create a SubscriptionPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubscriptionPlan we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionPlanUpsertArgs>(
      args: SelectSubset<T, SubscriptionPlanUpsertArgs<ExtArgs>>,
    ): Prisma__SubscriptionPlanClient<
      $Result.GetResult<
        Prisma.$SubscriptionPlanPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of SubscriptionPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanCountArgs} args - Arguments to filter SubscriptionPlans to count.
     * @example
     * // Count the number of SubscriptionPlans
     * const count = await prisma.subscriptionPlan.count({
     *   where: {
     *     // ... the filter for the SubscriptionPlans we want to count
     *   }
     * })
     **/
    count<T extends SubscriptionPlanCountArgs>(
      args?: Subset<T, SubscriptionPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionPlanCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends SubscriptionPlanAggregateArgs>(
      args: Subset<T, SubscriptionPlanAggregateArgs>,
    ): Prisma.PrismaPromise<GetSubscriptionPlanAggregateType<T>>;

    /**
     * Group by SubscriptionPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends SubscriptionPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionPlanGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, SubscriptionPlanGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetSubscriptionPlanGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the SubscriptionPlan model
     */
    readonly fields: SubscriptionPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubscriptionPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionPlanClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the SubscriptionPlan model
   */
  interface SubscriptionPlanFieldRefs {
    readonly id: FieldRef<'SubscriptionPlan', 'String'>;
    readonly name: FieldRef<'SubscriptionPlan', 'String'>;
    readonly description: FieldRef<'SubscriptionPlan', 'String'>;
    readonly price: FieldRef<'SubscriptionPlan', 'Float'>;
    readonly features: FieldRef<'SubscriptionPlan', 'Json'>;
    readonly createdAt: FieldRef<'SubscriptionPlan', 'DateTime'>;
    readonly updatedAt: FieldRef<'SubscriptionPlan', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * SubscriptionPlan findUnique
   */
  export type SubscriptionPlanFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput;
  };

  /**
   * SubscriptionPlan findUniqueOrThrow
   */
  export type SubscriptionPlanFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where: SubscriptionPlanWhereUniqueInput;
  };

  /**
   * SubscriptionPlan findFirst
   */
  export type SubscriptionPlanFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?:
      | SubscriptionPlanOrderByWithRelationInput
      | SubscriptionPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?:
      | SubscriptionPlanScalarFieldEnum
      | SubscriptionPlanScalarFieldEnum[];
  };

  /**
   * SubscriptionPlan findFirstOrThrow
   */
  export type SubscriptionPlanFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter, which SubscriptionPlan to fetch.
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?:
      | SubscriptionPlanOrderByWithRelationInput
      | SubscriptionPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SubscriptionPlans.
     */
    distinct?:
      | SubscriptionPlanScalarFieldEnum
      | SubscriptionPlanScalarFieldEnum[];
  };

  /**
   * SubscriptionPlan findMany
   */
  export type SubscriptionPlanFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter, which SubscriptionPlans to fetch.
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SubscriptionPlans to fetch.
     */
    orderBy?:
      | SubscriptionPlanOrderByWithRelationInput
      | SubscriptionPlanOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SubscriptionPlans.
     */
    cursor?: SubscriptionPlanWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SubscriptionPlans from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SubscriptionPlans.
     */
    skip?: number;
    distinct?:
      | SubscriptionPlanScalarFieldEnum
      | SubscriptionPlanScalarFieldEnum[];
  };

  /**
   * SubscriptionPlan create
   */
  export type SubscriptionPlanCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * The data needed to create a SubscriptionPlan.
     */
    data: XOR<
      SubscriptionPlanCreateInput,
      SubscriptionPlanUncheckedCreateInput
    >;
  };

  /**
   * SubscriptionPlan createMany
   */
  export type SubscriptionPlanCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SubscriptionPlan createManyAndReturn
   */
  export type SubscriptionPlanCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * The data used to create many SubscriptionPlans.
     */
    data: SubscriptionPlanCreateManyInput | SubscriptionPlanCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * SubscriptionPlan update
   */
  export type SubscriptionPlanUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * The data needed to update a SubscriptionPlan.
     */
    data: XOR<
      SubscriptionPlanUpdateInput,
      SubscriptionPlanUncheckedUpdateInput
    >;
    /**
     * Choose, which SubscriptionPlan to update.
     */
    where: SubscriptionPlanWhereUniqueInput;
  };

  /**
   * SubscriptionPlan updateMany
   */
  export type SubscriptionPlanUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<
      SubscriptionPlanUpdateManyMutationInput,
      SubscriptionPlanUncheckedUpdateManyInput
    >;
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number;
  };

  /**
   * SubscriptionPlan updateManyAndReturn
   */
  export type SubscriptionPlanUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * The data used to update SubscriptionPlans.
     */
    data: XOR<
      SubscriptionPlanUpdateManyMutationInput,
      SubscriptionPlanUncheckedUpdateManyInput
    >;
    /**
     * Filter which SubscriptionPlans to update
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * Limit how many SubscriptionPlans to update.
     */
    limit?: number;
  };

  /**
   * SubscriptionPlan upsert
   */
  export type SubscriptionPlanUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * The filter to search for the SubscriptionPlan to update in case it exists.
     */
    where: SubscriptionPlanWhereUniqueInput;
    /**
     * In case the SubscriptionPlan found by the `where` argument doesn't exist, create a new SubscriptionPlan with this data.
     */
    create: XOR<
      SubscriptionPlanCreateInput,
      SubscriptionPlanUncheckedCreateInput
    >;
    /**
     * In case the SubscriptionPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      SubscriptionPlanUpdateInput,
      SubscriptionPlanUncheckedUpdateInput
    >;
  };

  /**
   * SubscriptionPlan delete
   */
  export type SubscriptionPlanDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
    /**
     * Filter which SubscriptionPlan to delete.
     */
    where: SubscriptionPlanWhereUniqueInput;
  };

  /**
   * SubscriptionPlan deleteMany
   */
  export type SubscriptionPlanDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which SubscriptionPlans to delete
     */
    where?: SubscriptionPlanWhereInput;
    /**
     * Limit how many SubscriptionPlans to delete.
     */
    limit?: number;
  };

  /**
   * SubscriptionPlan without action
   */
  export type SubscriptionPlanDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the SubscriptionPlan
     */
    select?: SubscriptionPlanSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the SubscriptionPlan
     */
    omit?: SubscriptionPlanOmit<ExtArgs> | null;
  };

  /**
   * Model BarbershopSubscription
   */

  export type AggregateBarbershopSubscription = {
    _count: BarbershopSubscriptionCountAggregateOutputType | null;
    _min: BarbershopSubscriptionMinAggregateOutputType | null;
    _max: BarbershopSubscriptionMaxAggregateOutputType | null;
  };

  export type BarbershopSubscriptionMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    planId: string | null;
    status: $Enums.SubscriptionStatus | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type BarbershopSubscriptionMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    planId: string | null;
    status: $Enums.SubscriptionStatus | null;
    startDate: Date | null;
    endDate: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type BarbershopSubscriptionCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    planId: number;
    status: number;
    startDate: number;
    endDate: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type BarbershopSubscriptionMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    planId?: true;
    status?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type BarbershopSubscriptionMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    planId?: true;
    status?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type BarbershopSubscriptionCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    planId?: true;
    status?: true;
    startDate?: true;
    endDate?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type BarbershopSubscriptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarbershopSubscription to aggregate.
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarbershopSubscriptions to fetch.
     */
    orderBy?:
      | BarbershopSubscriptionOrderByWithRelationInput
      | BarbershopSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: BarbershopSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarbershopSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarbershopSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned BarbershopSubscriptions
     **/
    _count?: true | BarbershopSubscriptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: BarbershopSubscriptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: BarbershopSubscriptionMaxAggregateInputType;
  };

  export type GetBarbershopSubscriptionAggregateType<
    T extends BarbershopSubscriptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateBarbershopSubscription]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBarbershopSubscription[P]>
      : GetScalarType<T[P], AggregateBarbershopSubscription[P]>;
  };

  export type BarbershopSubscriptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: BarbershopSubscriptionWhereInput;
    orderBy?:
      | BarbershopSubscriptionOrderByWithAggregationInput
      | BarbershopSubscriptionOrderByWithAggregationInput[];
    by:
      | BarbershopSubscriptionScalarFieldEnum[]
      | BarbershopSubscriptionScalarFieldEnum;
    having?: BarbershopSubscriptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: BarbershopSubscriptionCountAggregateInputType | true;
    _min?: BarbershopSubscriptionMinAggregateInputType;
    _max?: BarbershopSubscriptionMaxAggregateInputType;
  };

  export type BarbershopSubscriptionGroupByOutputType = {
    id: string;
    barbershopId: string;
    planId: string;
    status: $Enums.SubscriptionStatus;
    startDate: Date;
    endDate: Date;
    createdAt: Date;
    updatedAt: Date;
    _count: BarbershopSubscriptionCountAggregateOutputType | null;
    _min: BarbershopSubscriptionMinAggregateOutputType | null;
    _max: BarbershopSubscriptionMaxAggregateOutputType | null;
  };

  type GetBarbershopSubscriptionGroupByPayload<
    T extends BarbershopSubscriptionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BarbershopSubscriptionGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof BarbershopSubscriptionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], BarbershopSubscriptionGroupByOutputType[P]>
          : GetScalarType<T[P], BarbershopSubscriptionGroupByOutputType[P]>;
      }
    >
  >;

  export type BarbershopSubscriptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      planId?: boolean;
      status?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barbershopSubscription']
  >;

  export type BarbershopSubscriptionSelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      planId?: boolean;
      status?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barbershopSubscription']
  >;

  export type BarbershopSubscriptionSelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      planId?: boolean;
      status?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['barbershopSubscription']
  >;

  export type BarbershopSubscriptionSelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    planId?: boolean;
    status?: boolean;
    startDate?: boolean;
    endDate?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type BarbershopSubscriptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'barbershopId'
    | 'planId'
    | 'status'
    | 'startDate'
    | 'endDate'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['barbershopSubscription']
  >;
  export type BarbershopSubscriptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };
  export type BarbershopSubscriptionIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };
  export type BarbershopSubscriptionIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };

  export type $BarbershopSubscriptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'BarbershopSubscription';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        planId: string;
        status: $Enums.SubscriptionStatus;
        startDate: Date;
        endDate: Date;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['barbershopSubscription']
    >;
    composites: {};
  };

  type BarbershopSubscriptionGetPayload<
    S extends boolean | null | undefined | BarbershopSubscriptionDefaultArgs,
  > = $Result.GetResult<Prisma.$BarbershopSubscriptionPayload, S>;

  type BarbershopSubscriptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    BarbershopSubscriptionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: BarbershopSubscriptionCountAggregateInputType | true;
  };

  export interface BarbershopSubscriptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['BarbershopSubscription'];
      meta: { name: 'BarbershopSubscription' };
    };
    /**
     * Find zero or one BarbershopSubscription that matches the filter.
     * @param {BarbershopSubscriptionFindUniqueArgs} args - Arguments to find a BarbershopSubscription
     * @example
     * // Get one BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BarbershopSubscriptionFindUniqueArgs>(
      args: SelectSubset<T, BarbershopSubscriptionFindUniqueArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one BarbershopSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BarbershopSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a BarbershopSubscription
     * @example
     * // Get one BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BarbershopSubscriptionFindUniqueOrThrowArgs>(
      args: SelectSubset<
        T,
        BarbershopSubscriptionFindUniqueOrThrowArgs<ExtArgs>
      >,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarbershopSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionFindFirstArgs} args - Arguments to find a BarbershopSubscription
     * @example
     * // Get one BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BarbershopSubscriptionFindFirstArgs>(
      args?: SelectSubset<T, BarbershopSubscriptionFindFirstArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first BarbershopSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionFindFirstOrThrowArgs} args - Arguments to find a BarbershopSubscription
     * @example
     * // Get one BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BarbershopSubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<
        T,
        BarbershopSubscriptionFindFirstOrThrowArgs<ExtArgs>
      >,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more BarbershopSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BarbershopSubscriptions
     * const barbershopSubscriptions = await prisma.barbershopSubscription.findMany()
     *
     * // Get first 10 BarbershopSubscriptions
     * const barbershopSubscriptions = await prisma.barbershopSubscription.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const barbershopSubscriptionWithIdOnly = await prisma.barbershopSubscription.findMany({ select: { id: true } })
     *
     */
    findMany<T extends BarbershopSubscriptionFindManyArgs>(
      args?: SelectSubset<T, BarbershopSubscriptionFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a BarbershopSubscription.
     * @param {BarbershopSubscriptionCreateArgs} args - Arguments to create a BarbershopSubscription.
     * @example
     * // Create one BarbershopSubscription
     * const BarbershopSubscription = await prisma.barbershopSubscription.create({
     *   data: {
     *     // ... data to create a BarbershopSubscription
     *   }
     * })
     *
     */
    create<T extends BarbershopSubscriptionCreateArgs>(
      args: SelectSubset<T, BarbershopSubscriptionCreateArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many BarbershopSubscriptions.
     * @param {BarbershopSubscriptionCreateManyArgs} args - Arguments to create many BarbershopSubscriptions.
     * @example
     * // Create many BarbershopSubscriptions
     * const barbershopSubscription = await prisma.barbershopSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends BarbershopSubscriptionCreateManyArgs>(
      args?: SelectSubset<T, BarbershopSubscriptionCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many BarbershopSubscriptions and returns the data saved in the database.
     * @param {BarbershopSubscriptionCreateManyAndReturnArgs} args - Arguments to create many BarbershopSubscriptions.
     * @example
     * // Create many BarbershopSubscriptions
     * const barbershopSubscription = await prisma.barbershopSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many BarbershopSubscriptions and only return the `id`
     * const barbershopSubscriptionWithIdOnly = await prisma.barbershopSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<
      T extends BarbershopSubscriptionCreateManyAndReturnArgs,
    >(
      args?: SelectSubset<
        T,
        BarbershopSubscriptionCreateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a BarbershopSubscription.
     * @param {BarbershopSubscriptionDeleteArgs} args - Arguments to delete one BarbershopSubscription.
     * @example
     * // Delete one BarbershopSubscription
     * const BarbershopSubscription = await prisma.barbershopSubscription.delete({
     *   where: {
     *     // ... filter to delete one BarbershopSubscription
     *   }
     * })
     *
     */
    delete<T extends BarbershopSubscriptionDeleteArgs>(
      args: SelectSubset<T, BarbershopSubscriptionDeleteArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one BarbershopSubscription.
     * @param {BarbershopSubscriptionUpdateArgs} args - Arguments to update one BarbershopSubscription.
     * @example
     * // Update one BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends BarbershopSubscriptionUpdateArgs>(
      args: SelectSubset<T, BarbershopSubscriptionUpdateArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more BarbershopSubscriptions.
     * @param {BarbershopSubscriptionDeleteManyArgs} args - Arguments to filter BarbershopSubscriptions to delete.
     * @example
     * // Delete a few BarbershopSubscriptions
     * const { count } = await prisma.barbershopSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends BarbershopSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, BarbershopSubscriptionDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarbershopSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BarbershopSubscriptions
     * const barbershopSubscription = await prisma.barbershopSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends BarbershopSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, BarbershopSubscriptionUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more BarbershopSubscriptions and returns the data updated in the database.
     * @param {BarbershopSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many BarbershopSubscriptions.
     * @example
     * // Update many BarbershopSubscriptions
     * const barbershopSubscription = await prisma.barbershopSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more BarbershopSubscriptions and only return the `id`
     * const barbershopSubscriptionWithIdOnly = await prisma.barbershopSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<
      T extends BarbershopSubscriptionUpdateManyAndReturnArgs,
    >(
      args: SelectSubset<
        T,
        BarbershopSubscriptionUpdateManyAndReturnArgs<ExtArgs>
      >,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one BarbershopSubscription.
     * @param {BarbershopSubscriptionUpsertArgs} args - Arguments to update or create a BarbershopSubscription.
     * @example
     * // Update or create a BarbershopSubscription
     * const barbershopSubscription = await prisma.barbershopSubscription.upsert({
     *   create: {
     *     // ... data to create a BarbershopSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BarbershopSubscription we want to update
     *   }
     * })
     */
    upsert<T extends BarbershopSubscriptionUpsertArgs>(
      args: SelectSubset<T, BarbershopSubscriptionUpsertArgs<ExtArgs>>,
    ): Prisma__BarbershopSubscriptionClient<
      $Result.GetResult<
        Prisma.$BarbershopSubscriptionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of BarbershopSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionCountArgs} args - Arguments to filter BarbershopSubscriptions to count.
     * @example
     * // Count the number of BarbershopSubscriptions
     * const count = await prisma.barbershopSubscription.count({
     *   where: {
     *     // ... the filter for the BarbershopSubscriptions we want to count
     *   }
     * })
     **/
    count<T extends BarbershopSubscriptionCountArgs>(
      args?: Subset<T, BarbershopSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              BarbershopSubscriptionCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a BarbershopSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends BarbershopSubscriptionAggregateArgs>(
      args: Subset<T, BarbershopSubscriptionAggregateArgs>,
    ): Prisma.PrismaPromise<GetBarbershopSubscriptionAggregateType<T>>;

    /**
     * Group by BarbershopSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BarbershopSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends BarbershopSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BarbershopSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: BarbershopSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<
        T,
        BarbershopSubscriptionGroupByArgs,
        OrderByArg
      > &
        InputErrors,
    ): {} extends InputErrors
      ? GetBarbershopSubscriptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the BarbershopSubscription model
     */
    readonly fields: BarbershopSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BarbershopSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BarbershopSubscriptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the BarbershopSubscription model
   */
  interface BarbershopSubscriptionFieldRefs {
    readonly id: FieldRef<'BarbershopSubscription', 'String'>;
    readonly barbershopId: FieldRef<'BarbershopSubscription', 'String'>;
    readonly planId: FieldRef<'BarbershopSubscription', 'String'>;
    readonly status: FieldRef<'BarbershopSubscription', 'SubscriptionStatus'>;
    readonly startDate: FieldRef<'BarbershopSubscription', 'DateTime'>;
    readonly endDate: FieldRef<'BarbershopSubscription', 'DateTime'>;
    readonly createdAt: FieldRef<'BarbershopSubscription', 'DateTime'>;
    readonly updatedAt: FieldRef<'BarbershopSubscription', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * BarbershopSubscription findUnique
   */
  export type BarbershopSubscriptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which BarbershopSubscription to fetch.
     */
    where: BarbershopSubscriptionWhereUniqueInput;
  };

  /**
   * BarbershopSubscription findUniqueOrThrow
   */
  export type BarbershopSubscriptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which BarbershopSubscription to fetch.
     */
    where: BarbershopSubscriptionWhereUniqueInput;
  };

  /**
   * BarbershopSubscription findFirst
   */
  export type BarbershopSubscriptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which BarbershopSubscription to fetch.
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarbershopSubscriptions to fetch.
     */
    orderBy?:
      | BarbershopSubscriptionOrderByWithRelationInput
      | BarbershopSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarbershopSubscriptions.
     */
    cursor?: BarbershopSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarbershopSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarbershopSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarbershopSubscriptions.
     */
    distinct?:
      | BarbershopSubscriptionScalarFieldEnum
      | BarbershopSubscriptionScalarFieldEnum[];
  };

  /**
   * BarbershopSubscription findFirstOrThrow
   */
  export type BarbershopSubscriptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which BarbershopSubscription to fetch.
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarbershopSubscriptions to fetch.
     */
    orderBy?:
      | BarbershopSubscriptionOrderByWithRelationInput
      | BarbershopSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for BarbershopSubscriptions.
     */
    cursor?: BarbershopSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarbershopSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarbershopSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of BarbershopSubscriptions.
     */
    distinct?:
      | BarbershopSubscriptionScalarFieldEnum
      | BarbershopSubscriptionScalarFieldEnum[];
  };

  /**
   * BarbershopSubscription findMany
   */
  export type BarbershopSubscriptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which BarbershopSubscriptions to fetch.
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of BarbershopSubscriptions to fetch.
     */
    orderBy?:
      | BarbershopSubscriptionOrderByWithRelationInput
      | BarbershopSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing BarbershopSubscriptions.
     */
    cursor?: BarbershopSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` BarbershopSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` BarbershopSubscriptions.
     */
    skip?: number;
    distinct?:
      | BarbershopSubscriptionScalarFieldEnum
      | BarbershopSubscriptionScalarFieldEnum[];
  };

  /**
   * BarbershopSubscription create
   */
  export type BarbershopSubscriptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a BarbershopSubscription.
     */
    data: XOR<
      BarbershopSubscriptionCreateInput,
      BarbershopSubscriptionUncheckedCreateInput
    >;
  };

  /**
   * BarbershopSubscription createMany
   */
  export type BarbershopSubscriptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many BarbershopSubscriptions.
     */
    data:
      | BarbershopSubscriptionCreateManyInput
      | BarbershopSubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * BarbershopSubscription createManyAndReturn
   */
  export type BarbershopSubscriptionCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to create many BarbershopSubscriptions.
     */
    data:
      | BarbershopSubscriptionCreateManyInput
      | BarbershopSubscriptionCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarbershopSubscription update
   */
  export type BarbershopSubscriptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a BarbershopSubscription.
     */
    data: XOR<
      BarbershopSubscriptionUpdateInput,
      BarbershopSubscriptionUncheckedUpdateInput
    >;
    /**
     * Choose, which BarbershopSubscription to update.
     */
    where: BarbershopSubscriptionWhereUniqueInput;
  };

  /**
   * BarbershopSubscription updateMany
   */
  export type BarbershopSubscriptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update BarbershopSubscriptions.
     */
    data: XOR<
      BarbershopSubscriptionUpdateManyMutationInput,
      BarbershopSubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarbershopSubscriptions to update
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * Limit how many BarbershopSubscriptions to update.
     */
    limit?: number;
  };

  /**
   * BarbershopSubscription updateManyAndReturn
   */
  export type BarbershopSubscriptionUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * The data used to update BarbershopSubscriptions.
     */
    data: XOR<
      BarbershopSubscriptionUpdateManyMutationInput,
      BarbershopSubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which BarbershopSubscriptions to update
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * Limit how many BarbershopSubscriptions to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * BarbershopSubscription upsert
   */
  export type BarbershopSubscriptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the BarbershopSubscription to update in case it exists.
     */
    where: BarbershopSubscriptionWhereUniqueInput;
    /**
     * In case the BarbershopSubscription found by the `where` argument doesn't exist, create a new BarbershopSubscription with this data.
     */
    create: XOR<
      BarbershopSubscriptionCreateInput,
      BarbershopSubscriptionUncheckedCreateInput
    >;
    /**
     * In case the BarbershopSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      BarbershopSubscriptionUpdateInput,
      BarbershopSubscriptionUncheckedUpdateInput
    >;
  };

  /**
   * BarbershopSubscription delete
   */
  export type BarbershopSubscriptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter which BarbershopSubscription to delete.
     */
    where: BarbershopSubscriptionWhereUniqueInput;
  };

  /**
   * BarbershopSubscription deleteMany
   */
  export type BarbershopSubscriptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which BarbershopSubscriptions to delete
     */
    where?: BarbershopSubscriptionWhereInput;
    /**
     * Limit how many BarbershopSubscriptions to delete.
     */
    limit?: number;
  };

  /**
   * BarbershopSubscription without action
   */
  export type BarbershopSubscriptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the BarbershopSubscription
     */
    select?: BarbershopSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the BarbershopSubscription
     */
    omit?: BarbershopSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BarbershopSubscriptionInclude<ExtArgs> | null;
  };

  /**
   * Model AnalyticsDaily
   */

  export type AggregateAnalyticsDaily = {
    _count: AnalyticsDailyCountAggregateOutputType | null;
    _avg: AnalyticsDailyAvgAggregateOutputType | null;
    _sum: AnalyticsDailySumAggregateOutputType | null;
    _min: AnalyticsDailyMinAggregateOutputType | null;
    _max: AnalyticsDailyMaxAggregateOutputType | null;
  };

  export type AnalyticsDailyAvgAggregateOutputType = {
    totalQueues: number | null;
    totalRevenue: number | null;
  };

  export type AnalyticsDailySumAggregateOutputType = {
    totalQueues: number | null;
    totalRevenue: number | null;
  };

  export type AnalyticsDailyMinAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    date: Date | null;
    totalQueues: number | null;
    totalRevenue: number | null;
  };

  export type AnalyticsDailyMaxAggregateOutputType = {
    id: string | null;
    barbershopId: string | null;
    date: Date | null;
    totalQueues: number | null;
    totalRevenue: number | null;
  };

  export type AnalyticsDailyCountAggregateOutputType = {
    id: number;
    barbershopId: number;
    date: number;
    totalQueues: number;
    totalRevenue: number;
    data: number;
    _all: number;
  };

  export type AnalyticsDailyAvgAggregateInputType = {
    totalQueues?: true;
    totalRevenue?: true;
  };

  export type AnalyticsDailySumAggregateInputType = {
    totalQueues?: true;
    totalRevenue?: true;
  };

  export type AnalyticsDailyMinAggregateInputType = {
    id?: true;
    barbershopId?: true;
    date?: true;
    totalQueues?: true;
    totalRevenue?: true;
  };

  export type AnalyticsDailyMaxAggregateInputType = {
    id?: true;
    barbershopId?: true;
    date?: true;
    totalQueues?: true;
    totalRevenue?: true;
  };

  export type AnalyticsDailyCountAggregateInputType = {
    id?: true;
    barbershopId?: true;
    date?: true;
    totalQueues?: true;
    totalRevenue?: true;
    data?: true;
    _all?: true;
  };

  export type AnalyticsDailyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnalyticsDaily to aggregate.
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnalyticsDailies to fetch.
     */
    orderBy?:
      | AnalyticsDailyOrderByWithRelationInput
      | AnalyticsDailyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnalyticsDailyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnalyticsDailies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnalyticsDailies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AnalyticsDailies
     **/
    _count?: true | AnalyticsDailyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: AnalyticsDailyAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: AnalyticsDailySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnalyticsDailyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnalyticsDailyMaxAggregateInputType;
  };

  export type GetAnalyticsDailyAggregateType<
    T extends AnalyticsDailyAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnalyticsDaily]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsDaily[P]>
      : GetScalarType<T[P], AggregateAnalyticsDaily[P]>;
  };

  export type AnalyticsDailyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnalyticsDailyWhereInput;
    orderBy?:
      | AnalyticsDailyOrderByWithAggregationInput
      | AnalyticsDailyOrderByWithAggregationInput[];
    by: AnalyticsDailyScalarFieldEnum[] | AnalyticsDailyScalarFieldEnum;
    having?: AnalyticsDailyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnalyticsDailyCountAggregateInputType | true;
    _avg?: AnalyticsDailyAvgAggregateInputType;
    _sum?: AnalyticsDailySumAggregateInputType;
    _min?: AnalyticsDailyMinAggregateInputType;
    _max?: AnalyticsDailyMaxAggregateInputType;
  };

  export type AnalyticsDailyGroupByOutputType = {
    id: string;
    barbershopId: string;
    date: Date;
    totalQueues: number;
    totalRevenue: number;
    data: JsonValue;
    _count: AnalyticsDailyCountAggregateOutputType | null;
    _avg: AnalyticsDailyAvgAggregateOutputType | null;
    _sum: AnalyticsDailySumAggregateOutputType | null;
    _min: AnalyticsDailyMinAggregateOutputType | null;
    _max: AnalyticsDailyMaxAggregateOutputType | null;
  };

  type GetAnalyticsDailyGroupByPayload<T extends AnalyticsDailyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AnalyticsDailyGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof AnalyticsDailyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsDailyGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsDailyGroupByOutputType[P]>;
        }
      >
    >;

  export type AnalyticsDailySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      date?: boolean;
      totalQueues?: boolean;
      totalRevenue?: boolean;
      data?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['analyticsDaily']
  >;

  export type AnalyticsDailySelectCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      date?: boolean;
      totalQueues?: boolean;
      totalRevenue?: boolean;
      data?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['analyticsDaily']
  >;

  export type AnalyticsDailySelectUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      barbershopId?: boolean;
      date?: boolean;
      totalQueues?: boolean;
      totalRevenue?: boolean;
      data?: boolean;
      barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['analyticsDaily']
  >;

  export type AnalyticsDailySelectScalar = {
    id?: boolean;
    barbershopId?: boolean;
    date?: boolean;
    totalQueues?: boolean;
    totalRevenue?: boolean;
    data?: boolean;
  };

  export type AnalyticsDailyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'barbershopId' | 'date' | 'totalQueues' | 'totalRevenue' | 'data',
    ExtArgs['result']['analyticsDaily']
  >;
  export type AnalyticsDailyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };
  export type AnalyticsDailyIncludeCreateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };
  export type AnalyticsDailyIncludeUpdateManyAndReturn<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    barbershop?: boolean | BarbershopDefaultArgs<ExtArgs>;
  };

  export type $AnalyticsDailyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AnalyticsDaily';
    objects: {
      barbershop: Prisma.$BarbershopPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        barbershopId: string;
        date: Date;
        totalQueues: number;
        totalRevenue: number;
        data: Prisma.JsonValue;
      },
      ExtArgs['result']['analyticsDaily']
    >;
    composites: {};
  };

  type AnalyticsDailyGetPayload<
    S extends boolean | null | undefined | AnalyticsDailyDefaultArgs,
  > = $Result.GetResult<Prisma.$AnalyticsDailyPayload, S>;

  type AnalyticsDailyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnalyticsDailyFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AnalyticsDailyCountAggregateInputType | true;
  };

  export interface AnalyticsDailyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsDaily'];
      meta: { name: 'AnalyticsDaily' };
    };
    /**
     * Find zero or one AnalyticsDaily that matches the filter.
     * @param {AnalyticsDailyFindUniqueArgs} args - Arguments to find a AnalyticsDaily
     * @example
     * // Get one AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsDailyFindUniqueArgs>(
      args: SelectSubset<T, AnalyticsDailyFindUniqueArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AnalyticsDaily that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsDailyFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsDaily
     * @example
     * // Get one AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsDailyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnalyticsDailyFindUniqueOrThrowArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnalyticsDaily that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyFindFirstArgs} args - Arguments to find a AnalyticsDaily
     * @example
     * // Get one AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsDailyFindFirstArgs>(
      args?: SelectSubset<T, AnalyticsDailyFindFirstArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnalyticsDaily that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyFindFirstOrThrowArgs} args - Arguments to find a AnalyticsDaily
     * @example
     * // Get one AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsDailyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnalyticsDailyFindFirstOrThrowArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnalyticsDailies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsDailies
     * const analyticsDailies = await prisma.analyticsDaily.findMany()
     *
     * // Get first 10 AnalyticsDailies
     * const analyticsDailies = await prisma.analyticsDaily.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const analyticsDailyWithIdOnly = await prisma.analyticsDaily.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnalyticsDailyFindManyArgs>(
      args?: SelectSubset<T, AnalyticsDailyFindManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AnalyticsDaily.
     * @param {AnalyticsDailyCreateArgs} args - Arguments to create a AnalyticsDaily.
     * @example
     * // Create one AnalyticsDaily
     * const AnalyticsDaily = await prisma.analyticsDaily.create({
     *   data: {
     *     // ... data to create a AnalyticsDaily
     *   }
     * })
     *
     */
    create<T extends AnalyticsDailyCreateArgs>(
      args: SelectSubset<T, AnalyticsDailyCreateArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AnalyticsDailies.
     * @param {AnalyticsDailyCreateManyArgs} args - Arguments to create many AnalyticsDailies.
     * @example
     * // Create many AnalyticsDailies
     * const analyticsDaily = await prisma.analyticsDaily.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnalyticsDailyCreateManyArgs>(
      args?: SelectSubset<T, AnalyticsDailyCreateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create many AnalyticsDailies and returns the data saved in the database.
     * @param {AnalyticsDailyCreateManyAndReturnArgs} args - Arguments to create many AnalyticsDailies.
     * @example
     * // Create many AnalyticsDailies
     * const analyticsDaily = await prisma.analyticsDaily.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AnalyticsDailies and only return the `id`
     * const analyticsDailyWithIdOnly = await prisma.analyticsDaily.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AnalyticsDailyCreateManyAndReturnArgs>(
      args?: SelectSubset<T, AnalyticsDailyCreateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'createManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Delete a AnalyticsDaily.
     * @param {AnalyticsDailyDeleteArgs} args - Arguments to delete one AnalyticsDaily.
     * @example
     * // Delete one AnalyticsDaily
     * const AnalyticsDaily = await prisma.analyticsDaily.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsDaily
     *   }
     * })
     *
     */
    delete<T extends AnalyticsDailyDeleteArgs>(
      args: SelectSubset<T, AnalyticsDailyDeleteArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AnalyticsDaily.
     * @param {AnalyticsDailyUpdateArgs} args - Arguments to update one AnalyticsDaily.
     * @example
     * // Update one AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnalyticsDailyUpdateArgs>(
      args: SelectSubset<T, AnalyticsDailyUpdateArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AnalyticsDailies.
     * @param {AnalyticsDailyDeleteManyArgs} args - Arguments to filter AnalyticsDailies to delete.
     * @example
     * // Delete a few AnalyticsDailies
     * const { count } = await prisma.analyticsDaily.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnalyticsDailyDeleteManyArgs>(
      args?: SelectSubset<T, AnalyticsDailyDeleteManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AnalyticsDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsDailies
     * const analyticsDaily = await prisma.analyticsDaily.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnalyticsDailyUpdateManyArgs>(
      args: SelectSubset<T, AnalyticsDailyUpdateManyArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AnalyticsDailies and returns the data updated in the database.
     * @param {AnalyticsDailyUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsDailies.
     * @example
     * // Update many AnalyticsDailies
     * const analyticsDaily = await prisma.analyticsDaily.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AnalyticsDailies and only return the `id`
     * const analyticsDailyWithIdOnly = await prisma.analyticsDaily.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AnalyticsDailyUpdateManyAndReturnArgs>(
      args: SelectSubset<T, AnalyticsDailyUpdateManyAndReturnArgs<ExtArgs>>,
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'updateManyAndReturn',
        GlobalOmitOptions
      >
    >;

    /**
     * Create or update one AnalyticsDaily.
     * @param {AnalyticsDailyUpsertArgs} args - Arguments to update or create a AnalyticsDaily.
     * @example
     * // Update or create a AnalyticsDaily
     * const analyticsDaily = await prisma.analyticsDaily.upsert({
     *   create: {
     *     // ... data to create a AnalyticsDaily
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsDaily we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsDailyUpsertArgs>(
      args: SelectSubset<T, AnalyticsDailyUpsertArgs<ExtArgs>>,
    ): Prisma__AnalyticsDailyClient<
      $Result.GetResult<
        Prisma.$AnalyticsDailyPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Count the number of AnalyticsDailies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyCountArgs} args - Arguments to filter AnalyticsDailies to count.
     * @example
     * // Count the number of AnalyticsDailies
     * const count = await prisma.analyticsDaily.count({
     *   where: {
     *     // ... the filter for the AnalyticsDailies we want to count
     *   }
     * })
     **/
    count<T extends AnalyticsDailyCountArgs>(
      args?: Subset<T, AnalyticsDailyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsDailyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AnalyticsDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnalyticsDailyAggregateArgs>(
      args: Subset<T, AnalyticsDailyAggregateArgs>,
    ): Prisma.PrismaPromise<GetAnalyticsDailyAggregateType<T>>;

    /**
     * Group by AnalyticsDaily.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsDailyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnalyticsDailyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsDailyGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsDailyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnalyticsDailyGroupByArgs, OrderByArg> &
        InputErrors,
    ): {} extends InputErrors
      ? GetAnalyticsDailyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AnalyticsDaily model
     */
    readonly fields: AnalyticsDailyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsDaily.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsDailyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    barbershop<T extends BarbershopDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, BarbershopDefaultArgs<ExtArgs>>,
    ): Prisma__BarbershopClient<
      | $Result.GetResult<
          Prisma.$BarbershopPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null,
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AnalyticsDaily model
   */
  interface AnalyticsDailyFieldRefs {
    readonly id: FieldRef<'AnalyticsDaily', 'String'>;
    readonly barbershopId: FieldRef<'AnalyticsDaily', 'String'>;
    readonly date: FieldRef<'AnalyticsDaily', 'DateTime'>;
    readonly totalQueues: FieldRef<'AnalyticsDaily', 'Int'>;
    readonly totalRevenue: FieldRef<'AnalyticsDaily', 'Float'>;
    readonly data: FieldRef<'AnalyticsDaily', 'Json'>;
  }

  // Custom InputTypes
  /**
   * AnalyticsDaily findUnique
   */
  export type AnalyticsDailyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter, which AnalyticsDaily to fetch.
     */
    where: AnalyticsDailyWhereUniqueInput;
  };

  /**
   * AnalyticsDaily findUniqueOrThrow
   */
  export type AnalyticsDailyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter, which AnalyticsDaily to fetch.
     */
    where: AnalyticsDailyWhereUniqueInput;
  };

  /**
   * AnalyticsDaily findFirst
   */
  export type AnalyticsDailyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter, which AnalyticsDaily to fetch.
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnalyticsDailies to fetch.
     */
    orderBy?:
      | AnalyticsDailyOrderByWithRelationInput
      | AnalyticsDailyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnalyticsDailies.
     */
    cursor?: AnalyticsDailyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnalyticsDailies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnalyticsDailies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnalyticsDailies.
     */
    distinct?: AnalyticsDailyScalarFieldEnum | AnalyticsDailyScalarFieldEnum[];
  };

  /**
   * AnalyticsDaily findFirstOrThrow
   */
  export type AnalyticsDailyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter, which AnalyticsDaily to fetch.
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnalyticsDailies to fetch.
     */
    orderBy?:
      | AnalyticsDailyOrderByWithRelationInput
      | AnalyticsDailyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnalyticsDailies.
     */
    cursor?: AnalyticsDailyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnalyticsDailies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnalyticsDailies.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnalyticsDailies.
     */
    distinct?: AnalyticsDailyScalarFieldEnum | AnalyticsDailyScalarFieldEnum[];
  };

  /**
   * AnalyticsDaily findMany
   */
  export type AnalyticsDailyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter, which AnalyticsDailies to fetch.
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnalyticsDailies to fetch.
     */
    orderBy?:
      | AnalyticsDailyOrderByWithRelationInput
      | AnalyticsDailyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AnalyticsDailies.
     */
    cursor?: AnalyticsDailyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnalyticsDailies from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnalyticsDailies.
     */
    skip?: number;
    distinct?: AnalyticsDailyScalarFieldEnum | AnalyticsDailyScalarFieldEnum[];
  };

  /**
   * AnalyticsDaily create
   */
  export type AnalyticsDailyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * The data needed to create a AnalyticsDaily.
     */
    data: XOR<AnalyticsDailyCreateInput, AnalyticsDailyUncheckedCreateInput>;
  };

  /**
   * AnalyticsDaily createMany
   */
  export type AnalyticsDailyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AnalyticsDailies.
     */
    data: AnalyticsDailyCreateManyInput | AnalyticsDailyCreateManyInput[];
    skipDuplicates?: boolean;
  };

  /**
   * AnalyticsDaily createManyAndReturn
   */
  export type AnalyticsDailyCreateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelectCreateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * The data used to create many AnalyticsDailies.
     */
    data: AnalyticsDailyCreateManyInput | AnalyticsDailyCreateManyInput[];
    skipDuplicates?: boolean;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyIncludeCreateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AnalyticsDaily update
   */
  export type AnalyticsDailyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * The data needed to update a AnalyticsDaily.
     */
    data: XOR<AnalyticsDailyUpdateInput, AnalyticsDailyUncheckedUpdateInput>;
    /**
     * Choose, which AnalyticsDaily to update.
     */
    where: AnalyticsDailyWhereUniqueInput;
  };

  /**
   * AnalyticsDaily updateMany
   */
  export type AnalyticsDailyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AnalyticsDailies.
     */
    data: XOR<
      AnalyticsDailyUpdateManyMutationInput,
      AnalyticsDailyUncheckedUpdateManyInput
    >;
    /**
     * Filter which AnalyticsDailies to update
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * Limit how many AnalyticsDailies to update.
     */
    limit?: number;
  };

  /**
   * AnalyticsDaily updateManyAndReturn
   */
  export type AnalyticsDailyUpdateManyAndReturnArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelectUpdateManyAndReturn<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * The data used to update AnalyticsDailies.
     */
    data: XOR<
      AnalyticsDailyUpdateManyMutationInput,
      AnalyticsDailyUncheckedUpdateManyInput
    >;
    /**
     * Filter which AnalyticsDailies to update
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * Limit how many AnalyticsDailies to update.
     */
    limit?: number;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyIncludeUpdateManyAndReturn<ExtArgs> | null;
  };

  /**
   * AnalyticsDaily upsert
   */
  export type AnalyticsDailyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * The filter to search for the AnalyticsDaily to update in case it exists.
     */
    where: AnalyticsDailyWhereUniqueInput;
    /**
     * In case the AnalyticsDaily found by the `where` argument doesn't exist, create a new AnalyticsDaily with this data.
     */
    create: XOR<AnalyticsDailyCreateInput, AnalyticsDailyUncheckedCreateInput>;
    /**
     * In case the AnalyticsDaily was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsDailyUpdateInput, AnalyticsDailyUncheckedUpdateInput>;
  };

  /**
   * AnalyticsDaily delete
   */
  export type AnalyticsDailyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
    /**
     * Filter which AnalyticsDaily to delete.
     */
    where: AnalyticsDailyWhereUniqueInput;
  };

  /**
   * AnalyticsDaily deleteMany
   */
  export type AnalyticsDailyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnalyticsDailies to delete
     */
    where?: AnalyticsDailyWhereInput;
    /**
     * Limit how many AnalyticsDailies to delete.
     */
    limit?: number;
  };

  /**
   * AnalyticsDaily without action
   */
  export type AnalyticsDailyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnalyticsDaily
     */
    select?: AnalyticsDailySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnalyticsDaily
     */
    omit?: AnalyticsDailyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsDailyInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted';
    ReadCommitted: 'ReadCommitted';
    RepeatableRead: 'RepeatableRead';
    Serializable: 'Serializable';
  };

  export type TransactionIsolationLevel =
    (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

  export const BarbershopScalarFieldEnum: {
    id: 'id';
    name: 'name';
    slug: 'slug';
    address: 'address';
    logoUrl: 'logoUrl';
    timezone: 'timezone';
    subscriptionStatus: 'subscriptionStatus';
    settings: 'settings';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type BarbershopScalarFieldEnum =
    (typeof BarbershopScalarFieldEnum)[keyof typeof BarbershopScalarFieldEnum];

  export const UserScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    fullName: 'fullName';
    email: 'email';
    phoneNumber: 'phoneNumber';
    passwordHash: 'passwordHash';
    role: 'role';
    fcmToken: 'fcmToken';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const BarberScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    userId: 'userId';
    displayName: 'displayName';
    specialization: 'specialization';
    status: 'status';
    commissionRate: 'commissionRate';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type BarberScalarFieldEnum =
    (typeof BarberScalarFieldEnum)[keyof typeof BarberScalarFieldEnum];

  export const ServiceScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    name: 'name';
    description: 'description';
    durationMinutes: 'durationMinutes';
    price: 'price';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type ServiceScalarFieldEnum =
    (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum];

  export const BarberServiceScalarFieldEnum: {
    barberId: 'barberId';
    serviceId: 'serviceId';
    customDurationMinutes: 'customDurationMinutes';
  };

  export type BarberServiceScalarFieldEnum =
    (typeof BarberServiceScalarFieldEnum)[keyof typeof BarberServiceScalarFieldEnum];

  export const QueueScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    barberId: 'barberId';
    customerId: 'customerId';
    guestName: 'guestName';
    serviceId: 'serviceId';
    status: 'status';
    bookingSource: 'bookingSource';
    scheduledTime: 'scheduledTime';
    estimatedStartTime: 'estimatedStartTime';
    estimatedEndTime: 'estimatedEndTime';
    actualStartTime: 'actualStartTime';
    actualEndTime: 'actualEndTime';
    notified30m: 'notified30m';
    notified15m: 'notified15m';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    deletedAt: 'deletedAt';
  };

  export type QueueScalarFieldEnum =
    (typeof QueueScalarFieldEnum)[keyof typeof QueueScalarFieldEnum];

  export const QueueHistoryScalarFieldEnum: {
    id: 'id';
    queueId: 'queueId';
    previousStatus: 'previousStatus';
    newStatus: 'newStatus';
    changedById: 'changedById';
    notes: 'notes';
    createdAt: 'createdAt';
  };

  export type QueueHistoryScalarFieldEnum =
    (typeof QueueHistoryScalarFieldEnum)[keyof typeof QueueHistoryScalarFieldEnum];

  export const ReviewScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    barberId: 'barberId';
    customerId: 'customerId';
    queueId: 'queueId';
    rating: 'rating';
    comment: 'comment';
    createdAt: 'createdAt';
  };

  export type ReviewScalarFieldEnum =
    (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum];

  export const BarberScheduleScalarFieldEnum: {
    id: 'id';
    barberId: 'barberId';
    dayOfWeek: 'dayOfWeek';
    startTime: 'startTime';
    endTime: 'endTime';
    isActive: 'isActive';
  };

  export type BarberScheduleScalarFieldEnum =
    (typeof BarberScheduleScalarFieldEnum)[keyof typeof BarberScheduleScalarFieldEnum];

  export const SubscriptionPlanScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    price: 'price';
    features: 'features';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type SubscriptionPlanScalarFieldEnum =
    (typeof SubscriptionPlanScalarFieldEnum)[keyof typeof SubscriptionPlanScalarFieldEnum];

  export const BarbershopSubscriptionScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    planId: 'planId';
    status: 'status';
    startDate: 'startDate';
    endDate: 'endDate';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type BarbershopSubscriptionScalarFieldEnum =
    (typeof BarbershopSubscriptionScalarFieldEnum)[keyof typeof BarbershopSubscriptionScalarFieldEnum];

  export const AnalyticsDailyScalarFieldEnum: {
    id: 'id';
    barbershopId: 'barbershopId';
    date: 'date';
    totalQueues: 'totalQueues';
    totalRevenue: 'totalRevenue';
    data: 'data';
  };

  export type AnalyticsDailyScalarFieldEnum =
    (typeof AnalyticsDailyScalarFieldEnum)[keyof typeof AnalyticsDailyScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull;
  };

  export type JsonNullValueInput =
    (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  export const JsonNullValueFilter: {
    DbNull: typeof DbNull;
    JsonNull: typeof JsonNull;
    AnyNull: typeof AnyNull;
  };

  export type JsonNullValueFilter =
    (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

  export const NullsOrder: {
    first: 'first';
    last: 'last';
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>;

  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>;

  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Json'
  >;

  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueryMode'
  >;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole'
  >;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole[]'
  >;

  /**
   * Reference to a field of type 'BarberStatus'
   */
  export type EnumBarberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'BarberStatus'
  >;

  /**
   * Reference to a field of type 'BarberStatus[]'
   */
  export type ListEnumBarberStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'BarberStatus[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'QueueStatus'
  >;

  /**
   * Reference to a field of type 'QueueStatus[]'
   */
  export type ListEnumQueueStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'QueueStatus[]'>;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Deep Input Types
   */

  export type BarbershopWhereInput = {
    AND?: BarbershopWhereInput | BarbershopWhereInput[];
    OR?: BarbershopWhereInput[];
    NOT?: BarbershopWhereInput | BarbershopWhereInput[];
    id?: StringFilter<'Barbershop'> | string;
    name?: StringFilter<'Barbershop'> | string;
    slug?: StringFilter<'Barbershop'> | string;
    address?: StringNullableFilter<'Barbershop'> | string | null;
    logoUrl?: StringNullableFilter<'Barbershop'> | string | null;
    timezone?: StringFilter<'Barbershop'> | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFilter<'Barbershop'>
      | $Enums.SubscriptionStatus;
    settings?: JsonFilter<'Barbershop'>;
    createdAt?: DateTimeFilter<'Barbershop'> | Date | string;
    updatedAt?: DateTimeFilter<'Barbershop'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Barbershop'> | Date | string | null;
    users?: UserListRelationFilter;
    barbers?: BarberListRelationFilter;
    services?: ServiceListRelationFilter;
    subscriptions?: BarbershopSubscriptionListRelationFilter;
    queues?: QueueListRelationFilter;
    reviews?: ReviewListRelationFilter;
    analytics?: AnalyticsDailyListRelationFilter;
  };

  export type BarbershopOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    address?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    timezone?: SortOrder;
    subscriptionStatus?: SortOrder;
    settings?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    users?: UserOrderByRelationAggregateInput;
    barbers?: BarberOrderByRelationAggregateInput;
    services?: ServiceOrderByRelationAggregateInput;
    subscriptions?: BarbershopSubscriptionOrderByRelationAggregateInput;
    queues?: QueueOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
    analytics?: AnalyticsDailyOrderByRelationAggregateInput;
  };

  export type BarbershopWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      slug?: string;
      AND?: BarbershopWhereInput | BarbershopWhereInput[];
      OR?: BarbershopWhereInput[];
      NOT?: BarbershopWhereInput | BarbershopWhereInput[];
      name?: StringFilter<'Barbershop'> | string;
      address?: StringNullableFilter<'Barbershop'> | string | null;
      logoUrl?: StringNullableFilter<'Barbershop'> | string | null;
      timezone?: StringFilter<'Barbershop'> | string;
      subscriptionStatus?:
        | EnumSubscriptionStatusFilter<'Barbershop'>
        | $Enums.SubscriptionStatus;
      settings?: JsonFilter<'Barbershop'>;
      createdAt?: DateTimeFilter<'Barbershop'> | Date | string;
      updatedAt?: DateTimeFilter<'Barbershop'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Barbershop'> | Date | string | null;
      users?: UserListRelationFilter;
      barbers?: BarberListRelationFilter;
      services?: ServiceListRelationFilter;
      subscriptions?: BarbershopSubscriptionListRelationFilter;
      queues?: QueueListRelationFilter;
      reviews?: ReviewListRelationFilter;
      analytics?: AnalyticsDailyListRelationFilter;
    },
    'id' | 'slug'
  >;

  export type BarbershopOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    address?: SortOrderInput | SortOrder;
    logoUrl?: SortOrderInput | SortOrder;
    timezone?: SortOrder;
    subscriptionStatus?: SortOrder;
    settings?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: BarbershopCountOrderByAggregateInput;
    _max?: BarbershopMaxOrderByAggregateInput;
    _min?: BarbershopMinOrderByAggregateInput;
  };

  export type BarbershopScalarWhereWithAggregatesInput = {
    AND?:
      | BarbershopScalarWhereWithAggregatesInput
      | BarbershopScalarWhereWithAggregatesInput[];
    OR?: BarbershopScalarWhereWithAggregatesInput[];
    NOT?:
      | BarbershopScalarWhereWithAggregatesInput
      | BarbershopScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Barbershop'> | string;
    name?: StringWithAggregatesFilter<'Barbershop'> | string;
    slug?: StringWithAggregatesFilter<'Barbershop'> | string;
    address?: StringNullableWithAggregatesFilter<'Barbershop'> | string | null;
    logoUrl?: StringNullableWithAggregatesFilter<'Barbershop'> | string | null;
    timezone?: StringWithAggregatesFilter<'Barbershop'> | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusWithAggregatesFilter<'Barbershop'>
      | $Enums.SubscriptionStatus;
    settings?: JsonWithAggregatesFilter<'Barbershop'>;
    createdAt?: DateTimeWithAggregatesFilter<'Barbershop'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Barbershop'> | Date | string;
    deletedAt?:
      | DateTimeNullableWithAggregatesFilter<'Barbershop'>
      | Date
      | string
      | null;
  };

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    barbershopId?: StringNullableFilter<'User'> | string | null;
    fullName?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    phoneNumber?: StringFilter<'User'> | string;
    passwordHash?: StringFilter<'User'> | string;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    fcmToken?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
    barbershop?: XOR<
      BarbershopNullableScalarRelationFilter,
      BarbershopWhereInput
    > | null;
    barberInfo?: XOR<
      BarberNullableScalarRelationFilter,
      BarberWhereInput
    > | null;
    queues?: QueueListRelationFilter;
    reviews?: ReviewListRelationFilter;
    changedLogs?: QueueHistoryListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrderInput | SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    phoneNumber?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    fcmToken?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
    barberInfo?: BarberOrderByWithRelationInput;
    queues?: QueueOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
    changedLogs?: QueueHistoryOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      phoneNumber?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      barbershopId?: StringNullableFilter<'User'> | string | null;
      fullName?: StringFilter<'User'> | string;
      passwordHash?: StringFilter<'User'> | string;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      fcmToken?: StringNullableFilter<'User'> | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
      barbershop?: XOR<
        BarbershopNullableScalarRelationFilter,
        BarbershopWhereInput
      > | null;
      barberInfo?: XOR<
        BarberNullableScalarRelationFilter,
        BarberWhereInput
      > | null;
      queues?: QueueListRelationFilter;
      reviews?: ReviewListRelationFilter;
      changedLogs?: QueueHistoryListRelationFilter;
    },
    'id' | 'email' | 'phoneNumber'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrderInput | SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    phoneNumber?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    fcmToken?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    barbershopId?: StringNullableWithAggregatesFilter<'User'> | string | null;
    fullName?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    phoneNumber?: StringWithAggregatesFilter<'User'> | string;
    passwordHash?: StringWithAggregatesFilter<'User'> | string;
    role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
    fcmToken?: StringNullableWithAggregatesFilter<'User'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    deletedAt?:
      | DateTimeNullableWithAggregatesFilter<'User'>
      | Date
      | string
      | null;
  };

  export type BarberWhereInput = {
    AND?: BarberWhereInput | BarberWhereInput[];
    OR?: BarberWhereInput[];
    NOT?: BarberWhereInput | BarberWhereInput[];
    id?: StringFilter<'Barber'> | string;
    barbershopId?: StringFilter<'Barber'> | string;
    userId?: StringFilter<'Barber'> | string;
    displayName?: StringNullableFilter<'Barber'> | string | null;
    specialization?: StringNullableFilter<'Barber'> | string | null;
    status?: EnumBarberStatusFilter<'Barber'> | $Enums.BarberStatus;
    commissionRate?: FloatNullableFilter<'Barber'> | number | null;
    createdAt?: DateTimeFilter<'Barber'> | Date | string;
    updatedAt?: DateTimeFilter<'Barber'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Barber'> | Date | string | null;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    services?: BarberServiceListRelationFilter;
    schedules?: BarberScheduleListRelationFilter;
    queues?: QueueListRelationFilter;
    reviews?: ReviewListRelationFilter;
  };

  export type BarberOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    userId?: SortOrder;
    displayName?: SortOrderInput | SortOrder;
    specialization?: SortOrderInput | SortOrder;
    status?: SortOrder;
    commissionRate?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
    services?: BarberServiceOrderByRelationAggregateInput;
    schedules?: BarberScheduleOrderByRelationAggregateInput;
    queues?: QueueOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
  };

  export type BarberWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      barbershopId_userId?: BarberBarbershopIdUserIdCompoundUniqueInput;
      AND?: BarberWhereInput | BarberWhereInput[];
      OR?: BarberWhereInput[];
      NOT?: BarberWhereInput | BarberWhereInput[];
      barbershopId?: StringFilter<'Barber'> | string;
      displayName?: StringNullableFilter<'Barber'> | string | null;
      specialization?: StringNullableFilter<'Barber'> | string | null;
      status?: EnumBarberStatusFilter<'Barber'> | $Enums.BarberStatus;
      commissionRate?: FloatNullableFilter<'Barber'> | number | null;
      createdAt?: DateTimeFilter<'Barber'> | Date | string;
      updatedAt?: DateTimeFilter<'Barber'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Barber'> | Date | string | null;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      services?: BarberServiceListRelationFilter;
      schedules?: BarberScheduleListRelationFilter;
      queues?: QueueListRelationFilter;
      reviews?: ReviewListRelationFilter;
    },
    'id' | 'userId' | 'barbershopId_userId'
  >;

  export type BarberOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    userId?: SortOrder;
    displayName?: SortOrderInput | SortOrder;
    specialization?: SortOrderInput | SortOrder;
    status?: SortOrder;
    commissionRate?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: BarberCountOrderByAggregateInput;
    _avg?: BarberAvgOrderByAggregateInput;
    _max?: BarberMaxOrderByAggregateInput;
    _min?: BarberMinOrderByAggregateInput;
    _sum?: BarberSumOrderByAggregateInput;
  };

  export type BarberScalarWhereWithAggregatesInput = {
    AND?:
      | BarberScalarWhereWithAggregatesInput
      | BarberScalarWhereWithAggregatesInput[];
    OR?: BarberScalarWhereWithAggregatesInput[];
    NOT?:
      | BarberScalarWhereWithAggregatesInput
      | BarberScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Barber'> | string;
    barbershopId?: StringWithAggregatesFilter<'Barber'> | string;
    userId?: StringWithAggregatesFilter<'Barber'> | string;
    displayName?: StringNullableWithAggregatesFilter<'Barber'> | string | null;
    specialization?:
      | StringNullableWithAggregatesFilter<'Barber'>
      | string
      | null;
    status?:
      | EnumBarberStatusWithAggregatesFilter<'Barber'>
      | $Enums.BarberStatus;
    commissionRate?:
      | FloatNullableWithAggregatesFilter<'Barber'>
      | number
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'Barber'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Barber'> | Date | string;
    deletedAt?:
      | DateTimeNullableWithAggregatesFilter<'Barber'>
      | Date
      | string
      | null;
  };

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[];
    OR?: ServiceWhereInput[];
    NOT?: ServiceWhereInput | ServiceWhereInput[];
    id?: StringFilter<'Service'> | string;
    barbershopId?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    description?: StringNullableFilter<'Service'> | string | null;
    durationMinutes?: IntFilter<'Service'> | number;
    price?: FloatFilter<'Service'> | number;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    barbers?: BarberServiceListRelationFilter;
    queues?: QueueListRelationFilter;
  };

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    durationMinutes?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
    barbers?: BarberServiceOrderByRelationAggregateInput;
    queues?: QueueOrderByRelationAggregateInput;
  };

  export type ServiceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ServiceWhereInput | ServiceWhereInput[];
      OR?: ServiceWhereInput[];
      NOT?: ServiceWhereInput | ServiceWhereInput[];
      barbershopId?: StringFilter<'Service'> | string;
      name?: StringFilter<'Service'> | string;
      description?: StringNullableFilter<'Service'> | string | null;
      durationMinutes?: IntFilter<'Service'> | number;
      price?: FloatFilter<'Service'> | number;
      createdAt?: DateTimeFilter<'Service'> | Date | string;
      updatedAt?: DateTimeFilter<'Service'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
      barbers?: BarberServiceListRelationFilter;
      queues?: QueueListRelationFilter;
    },
    'id'
  >;

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    durationMinutes?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: ServiceCountOrderByAggregateInput;
    _avg?: ServiceAvgOrderByAggregateInput;
    _max?: ServiceMaxOrderByAggregateInput;
    _min?: ServiceMinOrderByAggregateInput;
    _sum?: ServiceSumOrderByAggregateInput;
  };

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?:
      | ServiceScalarWhereWithAggregatesInput
      | ServiceScalarWhereWithAggregatesInput[];
    OR?: ServiceScalarWhereWithAggregatesInput[];
    NOT?:
      | ServiceScalarWhereWithAggregatesInput
      | ServiceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Service'> | string;
    barbershopId?: StringWithAggregatesFilter<'Service'> | string;
    name?: StringWithAggregatesFilter<'Service'> | string;
    description?: StringNullableWithAggregatesFilter<'Service'> | string | null;
    durationMinutes?: IntWithAggregatesFilter<'Service'> | number;
    price?: FloatWithAggregatesFilter<'Service'> | number;
    createdAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Service'> | Date | string;
    deletedAt?:
      | DateTimeNullableWithAggregatesFilter<'Service'>
      | Date
      | string
      | null;
  };

  export type BarberServiceWhereInput = {
    AND?: BarberServiceWhereInput | BarberServiceWhereInput[];
    OR?: BarberServiceWhereInput[];
    NOT?: BarberServiceWhereInput | BarberServiceWhereInput[];
    barberId?: StringFilter<'BarberService'> | string;
    serviceId?: StringFilter<'BarberService'> | string;
    customDurationMinutes?: IntNullableFilter<'BarberService'> | number | null;
    barber?: XOR<BarberScalarRelationFilter, BarberWhereInput>;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
  };

  export type BarberServiceOrderByWithRelationInput = {
    barberId?: SortOrder;
    serviceId?: SortOrder;
    customDurationMinutes?: SortOrderInput | SortOrder;
    barber?: BarberOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
  };

  export type BarberServiceWhereUniqueInput = Prisma.AtLeast<
    {
      barberId_serviceId?: BarberServiceBarberIdServiceIdCompoundUniqueInput;
      AND?: BarberServiceWhereInput | BarberServiceWhereInput[];
      OR?: BarberServiceWhereInput[];
      NOT?: BarberServiceWhereInput | BarberServiceWhereInput[];
      barberId?: StringFilter<'BarberService'> | string;
      serviceId?: StringFilter<'BarberService'> | string;
      customDurationMinutes?:
        | IntNullableFilter<'BarberService'>
        | number
        | null;
      barber?: XOR<BarberScalarRelationFilter, BarberWhereInput>;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    },
    'barberId_serviceId'
  >;

  export type BarberServiceOrderByWithAggregationInput = {
    barberId?: SortOrder;
    serviceId?: SortOrder;
    customDurationMinutes?: SortOrderInput | SortOrder;
    _count?: BarberServiceCountOrderByAggregateInput;
    _avg?: BarberServiceAvgOrderByAggregateInput;
    _max?: BarberServiceMaxOrderByAggregateInput;
    _min?: BarberServiceMinOrderByAggregateInput;
    _sum?: BarberServiceSumOrderByAggregateInput;
  };

  export type BarberServiceScalarWhereWithAggregatesInput = {
    AND?:
      | BarberServiceScalarWhereWithAggregatesInput
      | BarberServiceScalarWhereWithAggregatesInput[];
    OR?: BarberServiceScalarWhereWithAggregatesInput[];
    NOT?:
      | BarberServiceScalarWhereWithAggregatesInput
      | BarberServiceScalarWhereWithAggregatesInput[];
    barberId?: StringWithAggregatesFilter<'BarberService'> | string;
    serviceId?: StringWithAggregatesFilter<'BarberService'> | string;
    customDurationMinutes?:
      | IntNullableWithAggregatesFilter<'BarberService'>
      | number
      | null;
  };

  export type QueueWhereInput = {
    AND?: QueueWhereInput | QueueWhereInput[];
    OR?: QueueWhereInput[];
    NOT?: QueueWhereInput | QueueWhereInput[];
    id?: StringFilter<'Queue'> | string;
    barbershopId?: StringFilter<'Queue'> | string;
    barberId?: StringNullableFilter<'Queue'> | string | null;
    customerId?: StringNullableFilter<'Queue'> | string | null;
    guestName?: StringNullableFilter<'Queue'> | string | null;
    serviceId?: StringFilter<'Queue'> | string;
    status?: EnumQueueStatusFilter<'Queue'> | $Enums.QueueStatus;
    bookingSource?: StringFilter<'Queue'> | string;
    scheduledTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    estimatedStartTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    estimatedEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    actualStartTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    actualEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    notified30m?: BoolFilter<'Queue'> | boolean;
    notified15m?: BoolFilter<'Queue'> | boolean;
    createdAt?: DateTimeFilter<'Queue'> | Date | string;
    updatedAt?: DateTimeFilter<'Queue'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    barber?: XOR<BarberNullableScalarRelationFilter, BarberWhereInput> | null;
    customer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
    history?: QueueHistoryListRelationFilter;
    reviews?: ReviewListRelationFilter;
  };

  export type QueueOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrderInput | SortOrder;
    customerId?: SortOrderInput | SortOrder;
    guestName?: SortOrderInput | SortOrder;
    serviceId?: SortOrder;
    status?: SortOrder;
    bookingSource?: SortOrder;
    scheduledTime?: SortOrderInput | SortOrder;
    estimatedStartTime?: SortOrderInput | SortOrder;
    estimatedEndTime?: SortOrderInput | SortOrder;
    actualStartTime?: SortOrderInput | SortOrder;
    actualEndTime?: SortOrderInput | SortOrder;
    notified30m?: SortOrder;
    notified15m?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
    barber?: BarberOrderByWithRelationInput;
    customer?: UserOrderByWithRelationInput;
    service?: ServiceOrderByWithRelationInput;
    history?: QueueHistoryOrderByRelationAggregateInput;
    reviews?: ReviewOrderByRelationAggregateInput;
  };

  export type QueueWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: QueueWhereInput | QueueWhereInput[];
      OR?: QueueWhereInput[];
      NOT?: QueueWhereInput | QueueWhereInput[];
      barbershopId?: StringFilter<'Queue'> | string;
      barberId?: StringNullableFilter<'Queue'> | string | null;
      customerId?: StringNullableFilter<'Queue'> | string | null;
      guestName?: StringNullableFilter<'Queue'> | string | null;
      serviceId?: StringFilter<'Queue'> | string;
      status?: EnumQueueStatusFilter<'Queue'> | $Enums.QueueStatus;
      bookingSource?: StringFilter<'Queue'> | string;
      scheduledTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
      estimatedStartTime?:
        | DateTimeNullableFilter<'Queue'>
        | Date
        | string
        | null;
      estimatedEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
      actualStartTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
      actualEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
      notified30m?: BoolFilter<'Queue'> | boolean;
      notified15m?: BoolFilter<'Queue'> | boolean;
      createdAt?: DateTimeFilter<'Queue'> | Date | string;
      updatedAt?: DateTimeFilter<'Queue'> | Date | string;
      deletedAt?: DateTimeNullableFilter<'Queue'> | Date | string | null;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
      barber?: XOR<BarberNullableScalarRelationFilter, BarberWhereInput> | null;
      customer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>;
      history?: QueueHistoryListRelationFilter;
      reviews?: ReviewListRelationFilter;
    },
    'id'
  >;

  export type QueueOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrderInput | SortOrder;
    customerId?: SortOrderInput | SortOrder;
    guestName?: SortOrderInput | SortOrder;
    serviceId?: SortOrder;
    status?: SortOrder;
    bookingSource?: SortOrder;
    scheduledTime?: SortOrderInput | SortOrder;
    estimatedStartTime?: SortOrderInput | SortOrder;
    estimatedEndTime?: SortOrderInput | SortOrder;
    actualStartTime?: SortOrderInput | SortOrder;
    actualEndTime?: SortOrderInput | SortOrder;
    notified30m?: SortOrder;
    notified15m?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrderInput | SortOrder;
    _count?: QueueCountOrderByAggregateInput;
    _max?: QueueMaxOrderByAggregateInput;
    _min?: QueueMinOrderByAggregateInput;
  };

  export type QueueScalarWhereWithAggregatesInput = {
    AND?:
      | QueueScalarWhereWithAggregatesInput
      | QueueScalarWhereWithAggregatesInput[];
    OR?: QueueScalarWhereWithAggregatesInput[];
    NOT?:
      | QueueScalarWhereWithAggregatesInput
      | QueueScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Queue'> | string;
    barbershopId?: StringWithAggregatesFilter<'Queue'> | string;
    barberId?: StringNullableWithAggregatesFilter<'Queue'> | string | null;
    customerId?: StringNullableWithAggregatesFilter<'Queue'> | string | null;
    guestName?: StringNullableWithAggregatesFilter<'Queue'> | string | null;
    serviceId?: StringWithAggregatesFilter<'Queue'> | string;
    status?: EnumQueueStatusWithAggregatesFilter<'Queue'> | $Enums.QueueStatus;
    bookingSource?: StringWithAggregatesFilter<'Queue'> | string;
    scheduledTime?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
    estimatedStartTime?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
    estimatedEndTime?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
    actualStartTime?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
    actualEndTime?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
    notified30m?: BoolWithAggregatesFilter<'Queue'> | boolean;
    notified15m?: BoolWithAggregatesFilter<'Queue'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'Queue'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Queue'> | Date | string;
    deletedAt?:
      | DateTimeNullableWithAggregatesFilter<'Queue'>
      | Date
      | string
      | null;
  };

  export type QueueHistoryWhereInput = {
    AND?: QueueHistoryWhereInput | QueueHistoryWhereInput[];
    OR?: QueueHistoryWhereInput[];
    NOT?: QueueHistoryWhereInput | QueueHistoryWhereInput[];
    id?: StringFilter<'QueueHistory'> | string;
    queueId?: StringFilter<'QueueHistory'> | string;
    previousStatus?:
      | EnumQueueStatusNullableFilter<'QueueHistory'>
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFilter<'QueueHistory'> | $Enums.QueueStatus;
    changedById?: StringNullableFilter<'QueueHistory'> | string | null;
    notes?: StringNullableFilter<'QueueHistory'> | string | null;
    createdAt?: DateTimeFilter<'QueueHistory'> | Date | string;
    queue?: XOR<QueueScalarRelationFilter, QueueWhereInput>;
    changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type QueueHistoryOrderByWithRelationInput = {
    id?: SortOrder;
    queueId?: SortOrder;
    previousStatus?: SortOrderInput | SortOrder;
    newStatus?: SortOrder;
    changedById?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    queue?: QueueOrderByWithRelationInput;
    changedBy?: UserOrderByWithRelationInput;
  };

  export type QueueHistoryWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: QueueHistoryWhereInput | QueueHistoryWhereInput[];
      OR?: QueueHistoryWhereInput[];
      NOT?: QueueHistoryWhereInput | QueueHistoryWhereInput[];
      queueId?: StringFilter<'QueueHistory'> | string;
      previousStatus?:
        | EnumQueueStatusNullableFilter<'QueueHistory'>
        | $Enums.QueueStatus
        | null;
      newStatus?: EnumQueueStatusFilter<'QueueHistory'> | $Enums.QueueStatus;
      changedById?: StringNullableFilter<'QueueHistory'> | string | null;
      notes?: StringNullableFilter<'QueueHistory'> | string | null;
      createdAt?: DateTimeFilter<'QueueHistory'> | Date | string;
      queue?: XOR<QueueScalarRelationFilter, QueueWhereInput>;
      changedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id'
  >;

  export type QueueHistoryOrderByWithAggregationInput = {
    id?: SortOrder;
    queueId?: SortOrder;
    previousStatus?: SortOrderInput | SortOrder;
    newStatus?: SortOrder;
    changedById?: SortOrderInput | SortOrder;
    notes?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: QueueHistoryCountOrderByAggregateInput;
    _max?: QueueHistoryMaxOrderByAggregateInput;
    _min?: QueueHistoryMinOrderByAggregateInput;
  };

  export type QueueHistoryScalarWhereWithAggregatesInput = {
    AND?:
      | QueueHistoryScalarWhereWithAggregatesInput
      | QueueHistoryScalarWhereWithAggregatesInput[];
    OR?: QueueHistoryScalarWhereWithAggregatesInput[];
    NOT?:
      | QueueHistoryScalarWhereWithAggregatesInput
      | QueueHistoryScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'QueueHistory'> | string;
    queueId?: StringWithAggregatesFilter<'QueueHistory'> | string;
    previousStatus?:
      | EnumQueueStatusNullableWithAggregatesFilter<'QueueHistory'>
      | $Enums.QueueStatus
      | null;
    newStatus?:
      | EnumQueueStatusWithAggregatesFilter<'QueueHistory'>
      | $Enums.QueueStatus;
    changedById?:
      | StringNullableWithAggregatesFilter<'QueueHistory'>
      | string
      | null;
    notes?: StringNullableWithAggregatesFilter<'QueueHistory'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'QueueHistory'> | Date | string;
  };

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[];
    OR?: ReviewWhereInput[];
    NOT?: ReviewWhereInput | ReviewWhereInput[];
    id?: StringFilter<'Review'> | string;
    barbershopId?: StringFilter<'Review'> | string;
    barberId?: StringNullableFilter<'Review'> | string | null;
    customerId?: StringFilter<'Review'> | string;
    queueId?: StringNullableFilter<'Review'> | string | null;
    rating?: IntFilter<'Review'> | number;
    comment?: StringNullableFilter<'Review'> | string | null;
    createdAt?: DateTimeFilter<'Review'> | Date | string;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    barber?: XOR<BarberNullableScalarRelationFilter, BarberWhereInput> | null;
    customer?: XOR<UserScalarRelationFilter, UserWhereInput>;
    queue?: XOR<QueueNullableScalarRelationFilter, QueueWhereInput> | null;
  };

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrderInput | SortOrder;
    customerId?: SortOrder;
    queueId?: SortOrderInput | SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
    barber?: BarberOrderByWithRelationInput;
    customer?: UserOrderByWithRelationInput;
    queue?: QueueOrderByWithRelationInput;
  };

  export type ReviewWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      queueId?: string;
      AND?: ReviewWhereInput | ReviewWhereInput[];
      OR?: ReviewWhereInput[];
      NOT?: ReviewWhereInput | ReviewWhereInput[];
      barbershopId?: StringFilter<'Review'> | string;
      barberId?: StringNullableFilter<'Review'> | string | null;
      customerId?: StringFilter<'Review'> | string;
      rating?: IntFilter<'Review'> | number;
      comment?: StringNullableFilter<'Review'> | string | null;
      createdAt?: DateTimeFilter<'Review'> | Date | string;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
      barber?: XOR<BarberNullableScalarRelationFilter, BarberWhereInput> | null;
      customer?: XOR<UserScalarRelationFilter, UserWhereInput>;
      queue?: XOR<QueueNullableScalarRelationFilter, QueueWhereInput> | null;
    },
    'id' | 'queueId'
  >;

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrderInput | SortOrder;
    customerId?: SortOrder;
    queueId?: SortOrderInput | SortOrder;
    rating?: SortOrder;
    comment?: SortOrderInput | SortOrder;
    createdAt?: SortOrder;
    _count?: ReviewCountOrderByAggregateInput;
    _avg?: ReviewAvgOrderByAggregateInput;
    _max?: ReviewMaxOrderByAggregateInput;
    _min?: ReviewMinOrderByAggregateInput;
    _sum?: ReviewSumOrderByAggregateInput;
  };

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    OR?: ReviewScalarWhereWithAggregatesInput[];
    NOT?:
      | ReviewScalarWhereWithAggregatesInput
      | ReviewScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Review'> | string;
    barbershopId?: StringWithAggregatesFilter<'Review'> | string;
    barberId?: StringNullableWithAggregatesFilter<'Review'> | string | null;
    customerId?: StringWithAggregatesFilter<'Review'> | string;
    queueId?: StringNullableWithAggregatesFilter<'Review'> | string | null;
    rating?: IntWithAggregatesFilter<'Review'> | number;
    comment?: StringNullableWithAggregatesFilter<'Review'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Review'> | Date | string;
  };

  export type BarberScheduleWhereInput = {
    AND?: BarberScheduleWhereInput | BarberScheduleWhereInput[];
    OR?: BarberScheduleWhereInput[];
    NOT?: BarberScheduleWhereInput | BarberScheduleWhereInput[];
    id?: StringFilter<'BarberSchedule'> | string;
    barberId?: StringFilter<'BarberSchedule'> | string;
    dayOfWeek?: IntFilter<'BarberSchedule'> | number;
    startTime?: StringFilter<'BarberSchedule'> | string;
    endTime?: StringFilter<'BarberSchedule'> | string;
    isActive?: BoolFilter<'BarberSchedule'> | boolean;
    barber?: XOR<BarberScalarRelationFilter, BarberWhereInput>;
  };

  export type BarberScheduleOrderByWithRelationInput = {
    id?: SortOrder;
    barberId?: SortOrder;
    dayOfWeek?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    isActive?: SortOrder;
    barber?: BarberOrderByWithRelationInput;
  };

  export type BarberScheduleWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: BarberScheduleWhereInput | BarberScheduleWhereInput[];
      OR?: BarberScheduleWhereInput[];
      NOT?: BarberScheduleWhereInput | BarberScheduleWhereInput[];
      barberId?: StringFilter<'BarberSchedule'> | string;
      dayOfWeek?: IntFilter<'BarberSchedule'> | number;
      startTime?: StringFilter<'BarberSchedule'> | string;
      endTime?: StringFilter<'BarberSchedule'> | string;
      isActive?: BoolFilter<'BarberSchedule'> | boolean;
      barber?: XOR<BarberScalarRelationFilter, BarberWhereInput>;
    },
    'id'
  >;

  export type BarberScheduleOrderByWithAggregationInput = {
    id?: SortOrder;
    barberId?: SortOrder;
    dayOfWeek?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    isActive?: SortOrder;
    _count?: BarberScheduleCountOrderByAggregateInput;
    _avg?: BarberScheduleAvgOrderByAggregateInput;
    _max?: BarberScheduleMaxOrderByAggregateInput;
    _min?: BarberScheduleMinOrderByAggregateInput;
    _sum?: BarberScheduleSumOrderByAggregateInput;
  };

  export type BarberScheduleScalarWhereWithAggregatesInput = {
    AND?:
      | BarberScheduleScalarWhereWithAggregatesInput
      | BarberScheduleScalarWhereWithAggregatesInput[];
    OR?: BarberScheduleScalarWhereWithAggregatesInput[];
    NOT?:
      | BarberScheduleScalarWhereWithAggregatesInput
      | BarberScheduleScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'BarberSchedule'> | string;
    barberId?: StringWithAggregatesFilter<'BarberSchedule'> | string;
    dayOfWeek?: IntWithAggregatesFilter<'BarberSchedule'> | number;
    startTime?: StringWithAggregatesFilter<'BarberSchedule'> | string;
    endTime?: StringWithAggregatesFilter<'BarberSchedule'> | string;
    isActive?: BoolWithAggregatesFilter<'BarberSchedule'> | boolean;
  };

  export type SubscriptionPlanWhereInput = {
    AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[];
    OR?: SubscriptionPlanWhereInput[];
    NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[];
    id?: StringFilter<'SubscriptionPlan'> | string;
    name?: StringFilter<'SubscriptionPlan'> | string;
    description?: StringNullableFilter<'SubscriptionPlan'> | string | null;
    price?: FloatFilter<'SubscriptionPlan'> | number;
    features?: JsonFilter<'SubscriptionPlan'>;
    createdAt?: DateTimeFilter<'SubscriptionPlan'> | Date | string;
    updatedAt?: DateTimeFilter<'SubscriptionPlan'> | Date | string;
  };

  export type SubscriptionPlanOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    price?: SortOrder;
    features?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubscriptionPlanWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[];
      OR?: SubscriptionPlanWhereInput[];
      NOT?: SubscriptionPlanWhereInput | SubscriptionPlanWhereInput[];
      name?: StringFilter<'SubscriptionPlan'> | string;
      description?: StringNullableFilter<'SubscriptionPlan'> | string | null;
      price?: FloatFilter<'SubscriptionPlan'> | number;
      features?: JsonFilter<'SubscriptionPlan'>;
      createdAt?: DateTimeFilter<'SubscriptionPlan'> | Date | string;
      updatedAt?: DateTimeFilter<'SubscriptionPlan'> | Date | string;
    },
    'id'
  >;

  export type SubscriptionPlanOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrderInput | SortOrder;
    price?: SortOrder;
    features?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: SubscriptionPlanCountOrderByAggregateInput;
    _avg?: SubscriptionPlanAvgOrderByAggregateInput;
    _max?: SubscriptionPlanMaxOrderByAggregateInput;
    _min?: SubscriptionPlanMinOrderByAggregateInput;
    _sum?: SubscriptionPlanSumOrderByAggregateInput;
  };

  export type SubscriptionPlanScalarWhereWithAggregatesInput = {
    AND?:
      | SubscriptionPlanScalarWhereWithAggregatesInput
      | SubscriptionPlanScalarWhereWithAggregatesInput[];
    OR?: SubscriptionPlanScalarWhereWithAggregatesInput[];
    NOT?:
      | SubscriptionPlanScalarWhereWithAggregatesInput
      | SubscriptionPlanScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'SubscriptionPlan'> | string;
    name?: StringWithAggregatesFilter<'SubscriptionPlan'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'SubscriptionPlan'>
      | string
      | null;
    price?: FloatWithAggregatesFilter<'SubscriptionPlan'> | number;
    features?: JsonWithAggregatesFilter<'SubscriptionPlan'>;
    createdAt?:
      | DateTimeWithAggregatesFilter<'SubscriptionPlan'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'SubscriptionPlan'>
      | Date
      | string;
  };

  export type BarbershopSubscriptionWhereInput = {
    AND?: BarbershopSubscriptionWhereInput | BarbershopSubscriptionWhereInput[];
    OR?: BarbershopSubscriptionWhereInput[];
    NOT?: BarbershopSubscriptionWhereInput | BarbershopSubscriptionWhereInput[];
    id?: StringFilter<'BarbershopSubscription'> | string;
    barbershopId?: StringFilter<'BarbershopSubscription'> | string;
    planId?: StringFilter<'BarbershopSubscription'> | string;
    status?:
      | EnumSubscriptionStatusFilter<'BarbershopSubscription'>
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    endDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    createdAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    updatedAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
  };

  export type BarbershopSubscriptionOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    planId?: SortOrder;
    status?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
  };

  export type BarbershopSubscriptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?:
        | BarbershopSubscriptionWhereInput
        | BarbershopSubscriptionWhereInput[];
      OR?: BarbershopSubscriptionWhereInput[];
      NOT?:
        | BarbershopSubscriptionWhereInput
        | BarbershopSubscriptionWhereInput[];
      barbershopId?: StringFilter<'BarbershopSubscription'> | string;
      planId?: StringFilter<'BarbershopSubscription'> | string;
      status?:
        | EnumSubscriptionStatusFilter<'BarbershopSubscription'>
        | $Enums.SubscriptionStatus;
      startDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
      endDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
      createdAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
      updatedAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    },
    'id'
  >;

  export type BarbershopSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    planId?: SortOrder;
    status?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: BarbershopSubscriptionCountOrderByAggregateInput;
    _max?: BarbershopSubscriptionMaxOrderByAggregateInput;
    _min?: BarbershopSubscriptionMinOrderByAggregateInput;
  };

  export type BarbershopSubscriptionScalarWhereWithAggregatesInput = {
    AND?:
      | BarbershopSubscriptionScalarWhereWithAggregatesInput
      | BarbershopSubscriptionScalarWhereWithAggregatesInput[];
    OR?: BarbershopSubscriptionScalarWhereWithAggregatesInput[];
    NOT?:
      | BarbershopSubscriptionScalarWhereWithAggregatesInput
      | BarbershopSubscriptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'BarbershopSubscription'> | string;
    barbershopId?:
      | StringWithAggregatesFilter<'BarbershopSubscription'>
      | string;
    planId?: StringWithAggregatesFilter<'BarbershopSubscription'> | string;
    status?:
      | EnumSubscriptionStatusWithAggregatesFilter<'BarbershopSubscription'>
      | $Enums.SubscriptionStatus;
    startDate?:
      | DateTimeWithAggregatesFilter<'BarbershopSubscription'>
      | Date
      | string;
    endDate?:
      | DateTimeWithAggregatesFilter<'BarbershopSubscription'>
      | Date
      | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'BarbershopSubscription'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'BarbershopSubscription'>
      | Date
      | string;
  };

  export type AnalyticsDailyWhereInput = {
    AND?: AnalyticsDailyWhereInput | AnalyticsDailyWhereInput[];
    OR?: AnalyticsDailyWhereInput[];
    NOT?: AnalyticsDailyWhereInput | AnalyticsDailyWhereInput[];
    id?: StringFilter<'AnalyticsDaily'> | string;
    barbershopId?: StringFilter<'AnalyticsDaily'> | string;
    date?: DateTimeFilter<'AnalyticsDaily'> | Date | string;
    totalQueues?: IntFilter<'AnalyticsDaily'> | number;
    totalRevenue?: FloatFilter<'AnalyticsDaily'> | number;
    data?: JsonFilter<'AnalyticsDaily'>;
    barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
  };

  export type AnalyticsDailyOrderByWithRelationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    date?: SortOrder;
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
    data?: SortOrder;
    barbershop?: BarbershopOrderByWithRelationInput;
  };

  export type AnalyticsDailyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      barbershopId_date?: AnalyticsDailyBarbershopIdDateCompoundUniqueInput;
      AND?: AnalyticsDailyWhereInput | AnalyticsDailyWhereInput[];
      OR?: AnalyticsDailyWhereInput[];
      NOT?: AnalyticsDailyWhereInput | AnalyticsDailyWhereInput[];
      barbershopId?: StringFilter<'AnalyticsDaily'> | string;
      date?: DateTimeFilter<'AnalyticsDaily'> | Date | string;
      totalQueues?: IntFilter<'AnalyticsDaily'> | number;
      totalRevenue?: FloatFilter<'AnalyticsDaily'> | number;
      data?: JsonFilter<'AnalyticsDaily'>;
      barbershop?: XOR<BarbershopScalarRelationFilter, BarbershopWhereInput>;
    },
    'id' | 'barbershopId_date'
  >;

  export type AnalyticsDailyOrderByWithAggregationInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    date?: SortOrder;
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
    data?: SortOrder;
    _count?: AnalyticsDailyCountOrderByAggregateInput;
    _avg?: AnalyticsDailyAvgOrderByAggregateInput;
    _max?: AnalyticsDailyMaxOrderByAggregateInput;
    _min?: AnalyticsDailyMinOrderByAggregateInput;
    _sum?: AnalyticsDailySumOrderByAggregateInput;
  };

  export type AnalyticsDailyScalarWhereWithAggregatesInput = {
    AND?:
      | AnalyticsDailyScalarWhereWithAggregatesInput
      | AnalyticsDailyScalarWhereWithAggregatesInput[];
    OR?: AnalyticsDailyScalarWhereWithAggregatesInput[];
    NOT?:
      | AnalyticsDailyScalarWhereWithAggregatesInput
      | AnalyticsDailyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AnalyticsDaily'> | string;
    barbershopId?: StringWithAggregatesFilter<'AnalyticsDaily'> | string;
    date?: DateTimeWithAggregatesFilter<'AnalyticsDaily'> | Date | string;
    totalQueues?: IntWithAggregatesFilter<'AnalyticsDaily'> | number;
    totalRevenue?: FloatWithAggregatesFilter<'AnalyticsDaily'> | number;
    data?: JsonWithAggregatesFilter<'AnalyticsDaily'>;
  };

  export type BarbershopCreateInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopCreateManyInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type BarbershopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarbershopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserCreateInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop?: BarbershopCreateNestedOneWithoutUsersInput;
    barberInfo?: BarberCreateNestedOneWithoutUserInput;
    queues?: QueueCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryCreateNestedManyWithoutChangedByInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberUncheckedCreateNestedOneWithoutUserInput;
    queues?: QueueUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput;
  };

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneWithoutUsersNestedInput;
    barberInfo?: BarberUpdateOneWithoutUserNestedInput;
    queues?: QueueUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUncheckedUpdateOneWithoutUserNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarberCreateInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type BarberCreateManyInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type BarberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ServiceCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutServicesInput;
    barbers?: BarberServiceCreateNestedManyWithoutServiceInput;
    queues?: QueueCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberServiceUncheckedCreateNestedManyWithoutServiceInput;
    queues?: QueueUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutServicesNestedInput;
    barbers?: BarberServiceUpdateManyWithoutServiceNestedInput;
    queues?: QueueUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberServiceUncheckedUpdateManyWithoutServiceNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceCreateManyInput = {
    id?: string;
    barbershopId: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarberServiceCreateInput = {
    customDurationMinutes?: number | null;
    barber: BarberCreateNestedOneWithoutServicesInput;
    service: ServiceCreateNestedOneWithoutBarbersInput;
  };

  export type BarberServiceUncheckedCreateInput = {
    barberId: string;
    serviceId: string;
    customDurationMinutes?: number | null;
  };

  export type BarberServiceUpdateInput = {
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    barber?: BarberUpdateOneRequiredWithoutServicesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutBarbersNestedInput;
  };

  export type BarberServiceUncheckedUpdateInput = {
    barberId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type BarberServiceCreateManyInput = {
    barberId: string;
    serviceId: string;
    customDurationMinutes?: number | null;
  };

  export type BarberServiceUpdateManyMutationInput = {
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type BarberServiceUncheckedUpdateManyInput = {
    barberId?: StringFieldUpdateOperationsInput | string;
    serviceId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type QueueCreateInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type QueueCreateManyInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type QueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type QueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type QueueHistoryCreateInput = {
    id?: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    notes?: string | null;
    createdAt?: Date | string;
    queue: QueueCreateNestedOneWithoutHistoryInput;
    changedBy?: UserCreateNestedOneWithoutChangedLogsInput;
  };

  export type QueueHistoryUncheckedCreateInput = {
    id?: string;
    queueId: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    changedById?: string | null;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    queue?: QueueUpdateOneRequiredWithoutHistoryNestedInput;
    changedBy?: UserUpdateOneWithoutChangedLogsNestedInput;
  };

  export type QueueHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    queueId?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    changedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type QueueHistoryCreateManyInput = {
    id?: string;
    queueId: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    changedById?: string | null;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type QueueHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    queueId?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    changedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewCreateInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    barbershop: BarbershopCreateNestedOneWithoutReviewsInput;
    barber?: BarberCreateNestedOneWithoutReviewsInput;
    customer: UserCreateNestedOneWithoutReviewsInput;
    queue?: QueueCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barbershop?: BarbershopUpdateOneRequiredWithoutReviewsNestedInput;
    barber?: BarberUpdateOneWithoutReviewsNestedInput;
    customer?: UserUpdateOneRequiredWithoutReviewsNestedInput;
    queue?: QueueUpdateOneWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewCreateManyInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarberScheduleCreateInput = {
    id?: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
    barber: BarberCreateNestedOneWithoutSchedulesInput;
  };

  export type BarberScheduleUncheckedCreateInput = {
    id?: string;
    barberId: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
  };

  export type BarberScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    barber?: BarberUpdateOneRequiredWithoutSchedulesNestedInput;
  };

  export type BarberScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type BarberScheduleCreateManyInput = {
    id?: string;
    barberId: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
  };

  export type BarberScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type BarberScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type SubscriptionPlanCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    price: number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubscriptionPlanUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    price: number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubscriptionPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: FloatFieldUpdateOperationsInput | number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubscriptionPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: FloatFieldUpdateOperationsInput | number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubscriptionPlanCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    price: number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type SubscriptionPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: FloatFieldUpdateOperationsInput | number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type SubscriptionPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    price?: FloatFieldUpdateOperationsInput | number;
    features?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarbershopSubscriptionCreateInput = {
    id?: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    barbershop: BarbershopCreateNestedOneWithoutSubscriptionsInput;
  };

  export type BarbershopSubscriptionUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BarbershopSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barbershop?: BarbershopUpdateOneRequiredWithoutSubscriptionsNestedInput;
  };

  export type BarbershopSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarbershopSubscriptionCreateManyInput = {
    id?: string;
    barbershopId: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BarbershopSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarbershopSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnalyticsDailyCreateInput = {
    id?: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
    barbershop: BarbershopCreateNestedOneWithoutAnalyticsInput;
  };

  export type AnalyticsDailyUncheckedCreateInput = {
    id?: string;
    barbershopId: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
    barbershop?: BarbershopUpdateOneRequiredWithoutAnalyticsNestedInput;
  };

  export type AnalyticsDailyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyCreateManyInput = {
    id?: string;
    barbershopId: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubscriptionStatus
      | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionStatusFilter<$PrismaModel>
      | $Enums.SubscriptionStatus;
  };
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>;

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type BarberListRelationFilter = {
    every?: BarberWhereInput;
    some?: BarberWhereInput;
    none?: BarberWhereInput;
  };

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput;
    some?: ServiceWhereInput;
    none?: ServiceWhereInput;
  };

  export type BarbershopSubscriptionListRelationFilter = {
    every?: BarbershopSubscriptionWhereInput;
    some?: BarbershopSubscriptionWhereInput;
    none?: BarbershopSubscriptionWhereInput;
  };

  export type QueueListRelationFilter = {
    every?: QueueWhereInput;
    some?: QueueWhereInput;
    none?: QueueWhereInput;
  };

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput;
    some?: ReviewWhereInput;
    none?: ReviewWhereInput;
  };

  export type AnalyticsDailyListRelationFilter = {
    every?: AnalyticsDailyWhereInput;
    some?: AnalyticsDailyWhereInput;
    none?: AnalyticsDailyWhereInput;
  };

  export type SortOrderInput = {
    sort: SortOrder;
    nulls?: NullsOrder;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BarberOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BarbershopSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type QueueOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnalyticsDailyOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BarbershopCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    address?: SortOrder;
    logoUrl?: SortOrder;
    timezone?: SortOrder;
    subscriptionStatus?: SortOrder;
    settings?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type BarbershopMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    address?: SortOrder;
    logoUrl?: SortOrder;
    timezone?: SortOrder;
    subscriptionStatus?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type BarbershopMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    slug?: SortOrder;
    address?: SortOrder;
    logoUrl?: SortOrder;
    timezone?: SortOrder;
    subscriptionStatus?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.SubscriptionStatus
        | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.SubscriptionStatus[]
        | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.SubscriptionStatus[]
        | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.SubscriptionStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
      _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
    };
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
          Exclude<
            keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>,
            'path'
          >
        >,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<
        Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>
      >;

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedJsonFilter<$PrismaModel>;
    _max?: NestedJsonFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type BarbershopNullableScalarRelationFilter = {
    is?: BarbershopWhereInput | null;
    isNot?: BarbershopWhereInput | null;
  };

  export type BarberNullableScalarRelationFilter = {
    is?: BarberWhereInput | null;
    isNot?: BarberWhereInput | null;
  };

  export type QueueHistoryListRelationFilter = {
    every?: QueueHistoryWhereInput;
    some?: QueueHistoryWhereInput;
    none?: QueueHistoryWhereInput;
  };

  export type QueueHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    phoneNumber?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    fcmToken?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    phoneNumber?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    fcmToken?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    fullName?: SortOrder;
    email?: SortOrder;
    phoneNumber?: SortOrder;
    passwordHash?: SortOrder;
    role?: SortOrder;
    fcmToken?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type EnumBarberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BarberStatus | EnumBarberStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBarberStatusFilter<$PrismaModel> | $Enums.BarberStatus;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type BarbershopScalarRelationFilter = {
    is?: BarbershopWhereInput;
    isNot?: BarbershopWhereInput;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type BarberServiceListRelationFilter = {
    every?: BarberServiceWhereInput;
    some?: BarberServiceWhereInput;
    none?: BarberServiceWhereInput;
  };

  export type BarberScheduleListRelationFilter = {
    every?: BarberScheduleWhereInput;
    some?: BarberScheduleWhereInput;
    none?: BarberScheduleWhereInput;
  };

  export type BarberServiceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BarberScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type BarberBarbershopIdUserIdCompoundUniqueInput = {
    barbershopId: string;
    userId: string;
  };

  export type BarberCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    userId?: SortOrder;
    displayName?: SortOrder;
    specialization?: SortOrder;
    status?: SortOrder;
    commissionRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type BarberAvgOrderByAggregateInput = {
    commissionRate?: SortOrder;
  };

  export type BarberMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    userId?: SortOrder;
    displayName?: SortOrder;
    specialization?: SortOrder;
    status?: SortOrder;
    commissionRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type BarberMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    userId?: SortOrder;
    displayName?: SortOrder;
    specialization?: SortOrder;
    status?: SortOrder;
    commissionRate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type BarberSumOrderByAggregateInput = {
    commissionRate?: SortOrder;
  };

  export type EnumBarberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BarberStatus | EnumBarberStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBarberStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.BarberStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBarberStatusFilter<$PrismaModel>;
    _max?: NestedEnumBarberStatusFilter<$PrismaModel>;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    durationMinutes?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceAvgOrderByAggregateInput = {
    durationMinutes?: SortOrder;
    price?: SortOrder;
  };

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    durationMinutes?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    durationMinutes?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type ServiceSumOrderByAggregateInput = {
    durationMinutes?: SortOrder;
    price?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type BarberScalarRelationFilter = {
    is?: BarberWhereInput;
    isNot?: BarberWhereInput;
  };

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput;
    isNot?: ServiceWhereInput;
  };

  export type BarberServiceBarberIdServiceIdCompoundUniqueInput = {
    barberId: string;
    serviceId: string;
  };

  export type BarberServiceCountOrderByAggregateInput = {
    barberId?: SortOrder;
    serviceId?: SortOrder;
    customDurationMinutes?: SortOrder;
  };

  export type BarberServiceAvgOrderByAggregateInput = {
    customDurationMinutes?: SortOrder;
  };

  export type BarberServiceMaxOrderByAggregateInput = {
    barberId?: SortOrder;
    serviceId?: SortOrder;
    customDurationMinutes?: SortOrder;
  };

  export type BarberServiceMinOrderByAggregateInput = {
    barberId?: SortOrder;
    serviceId?: SortOrder;
    customDurationMinutes?: SortOrder;
  };

  export type BarberServiceSumOrderByAggregateInput = {
    customDurationMinutes?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type QueueCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    guestName?: SortOrder;
    serviceId?: SortOrder;
    status?: SortOrder;
    bookingSource?: SortOrder;
    scheduledTime?: SortOrder;
    estimatedStartTime?: SortOrder;
    estimatedEndTime?: SortOrder;
    actualStartTime?: SortOrder;
    actualEndTime?: SortOrder;
    notified30m?: SortOrder;
    notified15m?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type QueueMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    guestName?: SortOrder;
    serviceId?: SortOrder;
    status?: SortOrder;
    bookingSource?: SortOrder;
    scheduledTime?: SortOrder;
    estimatedStartTime?: SortOrder;
    estimatedEndTime?: SortOrder;
    actualStartTime?: SortOrder;
    actualEndTime?: SortOrder;
    notified30m?: SortOrder;
    notified15m?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type QueueMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    guestName?: SortOrder;
    serviceId?: SortOrder;
    status?: SortOrder;
    bookingSource?: SortOrder;
    scheduledTime?: SortOrder;
    estimatedStartTime?: SortOrder;
    estimatedEndTime?: SortOrder;
    actualStartTime?: SortOrder;
    actualEndTime?: SortOrder;
    notified30m?: SortOrder;
    notified15m?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    deletedAt?: SortOrder;
  };

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.QueueStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>;
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type EnumQueueStatusNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.QueueStatus
      | EnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumQueueStatusNullableFilter<$PrismaModel>
      | $Enums.QueueStatus
      | null;
  };

  export type QueueScalarRelationFilter = {
    is?: QueueWhereInput;
    isNot?: QueueWhereInput;
  };

  export type QueueHistoryCountOrderByAggregateInput = {
    id?: SortOrder;
    queueId?: SortOrder;
    previousStatus?: SortOrder;
    newStatus?: SortOrder;
    changedById?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
  };

  export type QueueHistoryMaxOrderByAggregateInput = {
    id?: SortOrder;
    queueId?: SortOrder;
    previousStatus?: SortOrder;
    newStatus?: SortOrder;
    changedById?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
  };

  export type QueueHistoryMinOrderByAggregateInput = {
    id?: SortOrder;
    queueId?: SortOrder;
    previousStatus?: SortOrder;
    newStatus?: SortOrder;
    changedById?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
  };

  export type EnumQueueStatusNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.QueueStatus
      | EnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumQueueStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.QueueStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumQueueStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumQueueStatusNullableFilter<$PrismaModel>;
  };

  export type QueueNullableScalarRelationFilter = {
    is?: QueueWhereInput | null;
    isNot?: QueueWhereInput | null;
  };

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    queueId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    queueId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    barberId?: SortOrder;
    customerId?: SortOrder;
    queueId?: SortOrder;
    rating?: SortOrder;
    comment?: SortOrder;
    createdAt?: SortOrder;
  };

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type BarberScheduleCountOrderByAggregateInput = {
    id?: SortOrder;
    barberId?: SortOrder;
    dayOfWeek?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    isActive?: SortOrder;
  };

  export type BarberScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder;
  };

  export type BarberScheduleMaxOrderByAggregateInput = {
    id?: SortOrder;
    barberId?: SortOrder;
    dayOfWeek?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    isActive?: SortOrder;
  };

  export type BarberScheduleMinOrderByAggregateInput = {
    id?: SortOrder;
    barberId?: SortOrder;
    dayOfWeek?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    isActive?: SortOrder;
  };

  export type BarberScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder;
  };

  export type SubscriptionPlanCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    features?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubscriptionPlanAvgOrderByAggregateInput = {
    price?: SortOrder;
  };

  export type SubscriptionPlanMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubscriptionPlanMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    price?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type SubscriptionPlanSumOrderByAggregateInput = {
    price?: SortOrder;
  };

  export type BarbershopSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    planId?: SortOrder;
    status?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type BarbershopSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    planId?: SortOrder;
    status?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type BarbershopSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    planId?: SortOrder;
    status?: SortOrder;
    startDate?: SortOrder;
    endDate?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnalyticsDailyBarbershopIdDateCompoundUniqueInput = {
    barbershopId: string;
    date: Date | string;
  };

  export type AnalyticsDailyCountOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    date?: SortOrder;
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
    data?: SortOrder;
  };

  export type AnalyticsDailyAvgOrderByAggregateInput = {
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
  };

  export type AnalyticsDailyMaxOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    date?: SortOrder;
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
  };

  export type AnalyticsDailyMinOrderByAggregateInput = {
    id?: SortOrder;
    barbershopId?: SortOrder;
    date?: SortOrder;
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
  };

  export type AnalyticsDailySumOrderByAggregateInput = {
    totalQueues?: SortOrder;
    totalRevenue?: SortOrder;
  };

  export type UserCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          UserCreateWithoutBarbershopInput,
          UserUncheckedCreateWithoutBarbershopInput
        >
      | UserCreateWithoutBarbershopInput[]
      | UserUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutBarbershopInput
      | UserCreateOrConnectWithoutBarbershopInput[];
    createMany?: UserCreateManyBarbershopInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type BarberCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          BarberCreateWithoutBarbershopInput,
          BarberUncheckedCreateWithoutBarbershopInput
        >
      | BarberCreateWithoutBarbershopInput[]
      | BarberUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarberCreateOrConnectWithoutBarbershopInput
      | BarberCreateOrConnectWithoutBarbershopInput[];
    createMany?: BarberCreateManyBarbershopInputEnvelope;
    connect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
  };

  export type ServiceCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          ServiceCreateWithoutBarbershopInput,
          ServiceUncheckedCreateWithoutBarbershopInput
        >
      | ServiceCreateWithoutBarbershopInput[]
      | ServiceUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutBarbershopInput
      | ServiceCreateOrConnectWithoutBarbershopInput[];
    createMany?: ServiceCreateManyBarbershopInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          BarbershopSubscriptionCreateWithoutBarbershopInput,
          BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
        >
      | BarbershopSubscriptionCreateWithoutBarbershopInput[]
      | BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput
      | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput[];
    createMany?: BarbershopSubscriptionCreateManyBarbershopInputEnvelope;
    connect?:
      | BarbershopSubscriptionWhereUniqueInput
      | BarbershopSubscriptionWhereUniqueInput[];
  };

  export type QueueCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarbershopInput,
          QueueUncheckedCreateWithoutBarbershopInput
        >
      | QueueCreateWithoutBarbershopInput[]
      | QueueUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarbershopInput
      | QueueCreateOrConnectWithoutBarbershopInput[];
    createMany?: QueueCreateManyBarbershopInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarbershopInput,
          ReviewUncheckedCreateWithoutBarbershopInput
        >
      | ReviewCreateWithoutBarbershopInput[]
      | ReviewUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarbershopInput
      | ReviewCreateOrConnectWithoutBarbershopInput[];
    createMany?: ReviewCreateManyBarbershopInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type AnalyticsDailyCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          AnalyticsDailyCreateWithoutBarbershopInput,
          AnalyticsDailyUncheckedCreateWithoutBarbershopInput
        >
      | AnalyticsDailyCreateWithoutBarbershopInput[]
      | AnalyticsDailyUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput[];
    createMany?: AnalyticsDailyCreateManyBarbershopInputEnvelope;
    connect?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
  };

  export type UserUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          UserCreateWithoutBarbershopInput,
          UserUncheckedCreateWithoutBarbershopInput
        >
      | UserCreateWithoutBarbershopInput[]
      | UserUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutBarbershopInput
      | UserCreateOrConnectWithoutBarbershopInput[];
    createMany?: UserCreateManyBarbershopInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type BarberUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          BarberCreateWithoutBarbershopInput,
          BarberUncheckedCreateWithoutBarbershopInput
        >
      | BarberCreateWithoutBarbershopInput[]
      | BarberUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarberCreateOrConnectWithoutBarbershopInput
      | BarberCreateOrConnectWithoutBarbershopInput[];
    createMany?: BarberCreateManyBarbershopInputEnvelope;
    connect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
  };

  export type ServiceUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          ServiceCreateWithoutBarbershopInput,
          ServiceUncheckedCreateWithoutBarbershopInput
        >
      | ServiceCreateWithoutBarbershopInput[]
      | ServiceUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutBarbershopInput
      | ServiceCreateOrConnectWithoutBarbershopInput[];
    createMany?: ServiceCreateManyBarbershopInputEnvelope;
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
  };

  export type BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput =
    {
      create?:
        | XOR<
            BarbershopSubscriptionCreateWithoutBarbershopInput,
            BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
          >
        | BarbershopSubscriptionCreateWithoutBarbershopInput[]
        | BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput[];
      connectOrCreate?:
        | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput
        | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput[];
      createMany?: BarbershopSubscriptionCreateManyBarbershopInputEnvelope;
      connect?:
        | BarbershopSubscriptionWhereUniqueInput
        | BarbershopSubscriptionWhereUniqueInput[];
    };

  export type QueueUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarbershopInput,
          QueueUncheckedCreateWithoutBarbershopInput
        >
      | QueueCreateWithoutBarbershopInput[]
      | QueueUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarbershopInput
      | QueueCreateOrConnectWithoutBarbershopInput[];
    createMany?: QueueCreateManyBarbershopInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarbershopInput,
          ReviewUncheckedCreateWithoutBarbershopInput
        >
      | ReviewCreateWithoutBarbershopInput[]
      | ReviewUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarbershopInput
      | ReviewCreateOrConnectWithoutBarbershopInput[];
    createMany?: ReviewCreateManyBarbershopInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput = {
    create?:
      | XOR<
          AnalyticsDailyCreateWithoutBarbershopInput,
          AnalyticsDailyUncheckedCreateWithoutBarbershopInput
        >
      | AnalyticsDailyCreateWithoutBarbershopInput[]
      | AnalyticsDailyUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput[];
    createMany?: AnalyticsDailyCreateManyBarbershopInputEnvelope;
    connect?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
  };

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
  };

  export type UserUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutBarbershopInput,
          UserUncheckedCreateWithoutBarbershopInput
        >
      | UserCreateWithoutBarbershopInput[]
      | UserUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutBarbershopInput
      | UserCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutBarbershopInput
      | UserUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: UserCreateManyBarbershopInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutBarbershopInput
      | UserUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutBarbershopInput
      | UserUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type BarberUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          BarberCreateWithoutBarbershopInput,
          BarberUncheckedCreateWithoutBarbershopInput
        >
      | BarberCreateWithoutBarbershopInput[]
      | BarberUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarberCreateOrConnectWithoutBarbershopInput
      | BarberCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | BarberUpsertWithWhereUniqueWithoutBarbershopInput
      | BarberUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: BarberCreateManyBarbershopInputEnvelope;
    set?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    disconnect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    delete?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    connect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    update?:
      | BarberUpdateWithWhereUniqueWithoutBarbershopInput
      | BarberUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | BarberUpdateManyWithWhereWithoutBarbershopInput
      | BarberUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: BarberScalarWhereInput | BarberScalarWhereInput[];
  };

  export type ServiceUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          ServiceCreateWithoutBarbershopInput,
          ServiceUncheckedCreateWithoutBarbershopInput
        >
      | ServiceCreateWithoutBarbershopInput[]
      | ServiceUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutBarbershopInput
      | ServiceCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutBarbershopInput
      | ServiceUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: ServiceCreateManyBarbershopInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutBarbershopInput
      | ServiceUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutBarbershopInput
      | ServiceUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          BarbershopSubscriptionCreateWithoutBarbershopInput,
          BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
        >
      | BarbershopSubscriptionCreateWithoutBarbershopInput[]
      | BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput
      | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | BarbershopSubscriptionUpsertWithWhereUniqueWithoutBarbershopInput
      | BarbershopSubscriptionUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: BarbershopSubscriptionCreateManyBarbershopInputEnvelope;
    set?:
      | BarbershopSubscriptionWhereUniqueInput
      | BarbershopSubscriptionWhereUniqueInput[];
    disconnect?:
      | BarbershopSubscriptionWhereUniqueInput
      | BarbershopSubscriptionWhereUniqueInput[];
    delete?:
      | BarbershopSubscriptionWhereUniqueInput
      | BarbershopSubscriptionWhereUniqueInput[];
    connect?:
      | BarbershopSubscriptionWhereUniqueInput
      | BarbershopSubscriptionWhereUniqueInput[];
    update?:
      | BarbershopSubscriptionUpdateWithWhereUniqueWithoutBarbershopInput
      | BarbershopSubscriptionUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | BarbershopSubscriptionUpdateManyWithWhereWithoutBarbershopInput
      | BarbershopSubscriptionUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?:
      | BarbershopSubscriptionScalarWhereInput
      | BarbershopSubscriptionScalarWhereInput[];
  };

  export type QueueUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarbershopInput,
          QueueUncheckedCreateWithoutBarbershopInput
        >
      | QueueCreateWithoutBarbershopInput[]
      | QueueUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarbershopInput
      | QueueCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutBarbershopInput
      | QueueUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: QueueCreateManyBarbershopInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutBarbershopInput
      | QueueUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutBarbershopInput
      | QueueUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarbershopInput,
          ReviewUncheckedCreateWithoutBarbershopInput
        >
      | ReviewCreateWithoutBarbershopInput[]
      | ReviewUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarbershopInput
      | ReviewCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutBarbershopInput
      | ReviewUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: ReviewCreateManyBarbershopInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutBarbershopInput
      | ReviewUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutBarbershopInput
      | ReviewUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type AnalyticsDailyUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          AnalyticsDailyCreateWithoutBarbershopInput,
          AnalyticsDailyUncheckedCreateWithoutBarbershopInput
        >
      | AnalyticsDailyCreateWithoutBarbershopInput[]
      | AnalyticsDailyUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | AnalyticsDailyUpsertWithWhereUniqueWithoutBarbershopInput
      | AnalyticsDailyUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: AnalyticsDailyCreateManyBarbershopInputEnvelope;
    set?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    disconnect?:
      | AnalyticsDailyWhereUniqueInput
      | AnalyticsDailyWhereUniqueInput[];
    delete?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    connect?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    update?:
      | AnalyticsDailyUpdateWithWhereUniqueWithoutBarbershopInput
      | AnalyticsDailyUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | AnalyticsDailyUpdateManyWithWhereWithoutBarbershopInput
      | AnalyticsDailyUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?:
      | AnalyticsDailyScalarWhereInput
      | AnalyticsDailyScalarWhereInput[];
  };

  export type UserUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutBarbershopInput,
          UserUncheckedCreateWithoutBarbershopInput
        >
      | UserCreateWithoutBarbershopInput[]
      | UserUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutBarbershopInput
      | UserCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutBarbershopInput
      | UserUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: UserCreateManyBarbershopInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutBarbershopInput
      | UserUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutBarbershopInput
      | UserUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type BarberUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          BarberCreateWithoutBarbershopInput,
          BarberUncheckedCreateWithoutBarbershopInput
        >
      | BarberCreateWithoutBarbershopInput[]
      | BarberUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | BarberCreateOrConnectWithoutBarbershopInput
      | BarberCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | BarberUpsertWithWhereUniqueWithoutBarbershopInput
      | BarberUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: BarberCreateManyBarbershopInputEnvelope;
    set?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    disconnect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    delete?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    connect?: BarberWhereUniqueInput | BarberWhereUniqueInput[];
    update?:
      | BarberUpdateWithWhereUniqueWithoutBarbershopInput
      | BarberUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | BarberUpdateManyWithWhereWithoutBarbershopInput
      | BarberUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: BarberScalarWhereInput | BarberScalarWhereInput[];
  };

  export type ServiceUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          ServiceCreateWithoutBarbershopInput,
          ServiceUncheckedCreateWithoutBarbershopInput
        >
      | ServiceCreateWithoutBarbershopInput[]
      | ServiceUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ServiceCreateOrConnectWithoutBarbershopInput
      | ServiceCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | ServiceUpsertWithWhereUniqueWithoutBarbershopInput
      | ServiceUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: ServiceCreateManyBarbershopInputEnvelope;
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[];
    update?:
      | ServiceUpdateWithWhereUniqueWithoutBarbershopInput
      | ServiceUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | ServiceUpdateManyWithWhereWithoutBarbershopInput
      | ServiceUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
  };

  export type BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput =
    {
      create?:
        | XOR<
            BarbershopSubscriptionCreateWithoutBarbershopInput,
            BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
          >
        | BarbershopSubscriptionCreateWithoutBarbershopInput[]
        | BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput[];
      connectOrCreate?:
        | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput
        | BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput[];
      upsert?:
        | BarbershopSubscriptionUpsertWithWhereUniqueWithoutBarbershopInput
        | BarbershopSubscriptionUpsertWithWhereUniqueWithoutBarbershopInput[];
      createMany?: BarbershopSubscriptionCreateManyBarbershopInputEnvelope;
      set?:
        | BarbershopSubscriptionWhereUniqueInput
        | BarbershopSubscriptionWhereUniqueInput[];
      disconnect?:
        | BarbershopSubscriptionWhereUniqueInput
        | BarbershopSubscriptionWhereUniqueInput[];
      delete?:
        | BarbershopSubscriptionWhereUniqueInput
        | BarbershopSubscriptionWhereUniqueInput[];
      connect?:
        | BarbershopSubscriptionWhereUniqueInput
        | BarbershopSubscriptionWhereUniqueInput[];
      update?:
        | BarbershopSubscriptionUpdateWithWhereUniqueWithoutBarbershopInput
        | BarbershopSubscriptionUpdateWithWhereUniqueWithoutBarbershopInput[];
      updateMany?:
        | BarbershopSubscriptionUpdateManyWithWhereWithoutBarbershopInput
        | BarbershopSubscriptionUpdateManyWithWhereWithoutBarbershopInput[];
      deleteMany?:
        | BarbershopSubscriptionScalarWhereInput
        | BarbershopSubscriptionScalarWhereInput[];
    };

  export type QueueUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarbershopInput,
          QueueUncheckedCreateWithoutBarbershopInput
        >
      | QueueCreateWithoutBarbershopInput[]
      | QueueUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarbershopInput
      | QueueCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutBarbershopInput
      | QueueUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: QueueCreateManyBarbershopInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutBarbershopInput
      | QueueUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutBarbershopInput
      | QueueUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarbershopInput,
          ReviewUncheckedCreateWithoutBarbershopInput
        >
      | ReviewCreateWithoutBarbershopInput[]
      | ReviewUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarbershopInput
      | ReviewCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutBarbershopInput
      | ReviewUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: ReviewCreateManyBarbershopInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutBarbershopInput
      | ReviewUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutBarbershopInput
      | ReviewUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput = {
    create?:
      | XOR<
          AnalyticsDailyCreateWithoutBarbershopInput,
          AnalyticsDailyUncheckedCreateWithoutBarbershopInput
        >
      | AnalyticsDailyCreateWithoutBarbershopInput[]
      | AnalyticsDailyUncheckedCreateWithoutBarbershopInput[];
    connectOrCreate?:
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput
      | AnalyticsDailyCreateOrConnectWithoutBarbershopInput[];
    upsert?:
      | AnalyticsDailyUpsertWithWhereUniqueWithoutBarbershopInput
      | AnalyticsDailyUpsertWithWhereUniqueWithoutBarbershopInput[];
    createMany?: AnalyticsDailyCreateManyBarbershopInputEnvelope;
    set?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    disconnect?:
      | AnalyticsDailyWhereUniqueInput
      | AnalyticsDailyWhereUniqueInput[];
    delete?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    connect?: AnalyticsDailyWhereUniqueInput | AnalyticsDailyWhereUniqueInput[];
    update?:
      | AnalyticsDailyUpdateWithWhereUniqueWithoutBarbershopInput
      | AnalyticsDailyUpdateWithWhereUniqueWithoutBarbershopInput[];
    updateMany?:
      | AnalyticsDailyUpdateManyWithWhereWithoutBarbershopInput
      | AnalyticsDailyUpdateManyWithWhereWithoutBarbershopInput[];
    deleteMany?:
      | AnalyticsDailyScalarWhereInput
      | AnalyticsDailyScalarWhereInput[];
  };

  export type BarbershopCreateNestedOneWithoutUsersInput = {
    create?: XOR<
      BarbershopCreateWithoutUsersInput,
      BarbershopUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutUsersInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarberCreateNestedOneWithoutUserInput = {
    create?: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutUserInput;
    connect?: BarberWhereUniqueInput;
  };

  export type QueueCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          QueueCreateWithoutCustomerInput,
          QueueUncheckedCreateWithoutCustomerInput
        >
      | QueueCreateWithoutCustomerInput[]
      | QueueUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutCustomerInput
      | QueueCreateOrConnectWithoutCustomerInput[];
    createMany?: QueueCreateManyCustomerInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCustomerInput,
          ReviewUncheckedCreateWithoutCustomerInput
        >
      | ReviewCreateWithoutCustomerInput[]
      | ReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCustomerInput
      | ReviewCreateOrConnectWithoutCustomerInput[];
    createMany?: ReviewCreateManyCustomerInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type QueueHistoryCreateNestedManyWithoutChangedByInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutChangedByInput,
          QueueHistoryUncheckedCreateWithoutChangedByInput
        >
      | QueueHistoryCreateWithoutChangedByInput[]
      | QueueHistoryUncheckedCreateWithoutChangedByInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutChangedByInput
      | QueueHistoryCreateOrConnectWithoutChangedByInput[];
    createMany?: QueueHistoryCreateManyChangedByInputEnvelope;
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
  };

  export type BarberUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutUserInput;
    connect?: BarberWhereUniqueInput;
  };

  export type QueueUncheckedCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          QueueCreateWithoutCustomerInput,
          QueueUncheckedCreateWithoutCustomerInput
        >
      | QueueCreateWithoutCustomerInput[]
      | QueueUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutCustomerInput
      | QueueCreateOrConnectWithoutCustomerInput[];
    createMany?: QueueCreateManyCustomerInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutCustomerInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCustomerInput,
          ReviewUncheckedCreateWithoutCustomerInput
        >
      | ReviewCreateWithoutCustomerInput[]
      | ReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCustomerInput
      | ReviewCreateOrConnectWithoutCustomerInput[];
    createMany?: ReviewCreateManyCustomerInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutChangedByInput,
          QueueHistoryUncheckedCreateWithoutChangedByInput
        >
      | QueueHistoryCreateWithoutChangedByInput[]
      | QueueHistoryUncheckedCreateWithoutChangedByInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutChangedByInput
      | QueueHistoryCreateOrConnectWithoutChangedByInput[];
    createMany?: QueueHistoryCreateManyChangedByInputEnvelope;
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type BarbershopUpdateOneWithoutUsersNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutUsersInput,
      BarbershopUncheckedCreateWithoutUsersInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutUsersInput;
    upsert?: BarbershopUpsertWithoutUsersInput;
    disconnect?: BarbershopWhereInput | boolean;
    delete?: BarbershopWhereInput | boolean;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutUsersInput,
        BarbershopUpdateWithoutUsersInput
      >,
      BarbershopUncheckedUpdateWithoutUsersInput
    >;
  };

  export type BarberUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutUserInput;
    upsert?: BarberUpsertWithoutUserInput;
    disconnect?: BarberWhereInput | boolean;
    delete?: BarberWhereInput | boolean;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutUserInput,
        BarberUpdateWithoutUserInput
      >,
      BarberUncheckedUpdateWithoutUserInput
    >;
  };

  export type QueueUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutCustomerInput,
          QueueUncheckedCreateWithoutCustomerInput
        >
      | QueueCreateWithoutCustomerInput[]
      | QueueUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutCustomerInput
      | QueueCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutCustomerInput
      | QueueUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: QueueCreateManyCustomerInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutCustomerInput
      | QueueUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutCustomerInput
      | QueueUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCustomerInput,
          ReviewUncheckedCreateWithoutCustomerInput
        >
      | ReviewCreateWithoutCustomerInput[]
      | ReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCustomerInput
      | ReviewCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutCustomerInput
      | ReviewUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: ReviewCreateManyCustomerInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutCustomerInput
      | ReviewUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutCustomerInput
      | ReviewUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type QueueHistoryUpdateManyWithoutChangedByNestedInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutChangedByInput,
          QueueHistoryUncheckedCreateWithoutChangedByInput
        >
      | QueueHistoryCreateWithoutChangedByInput[]
      | QueueHistoryUncheckedCreateWithoutChangedByInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutChangedByInput
      | QueueHistoryCreateOrConnectWithoutChangedByInput[];
    upsert?:
      | QueueHistoryUpsertWithWhereUniqueWithoutChangedByInput
      | QueueHistoryUpsertWithWhereUniqueWithoutChangedByInput[];
    createMany?: QueueHistoryCreateManyChangedByInputEnvelope;
    set?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    disconnect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    delete?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    update?:
      | QueueHistoryUpdateWithWhereUniqueWithoutChangedByInput
      | QueueHistoryUpdateWithWhereUniqueWithoutChangedByInput[];
    updateMany?:
      | QueueHistoryUpdateManyWithWhereWithoutChangedByInput
      | QueueHistoryUpdateManyWithWhereWithoutChangedByInput[];
    deleteMany?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
  };

  export type BarberUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutUserInput;
    upsert?: BarberUpsertWithoutUserInput;
    disconnect?: BarberWhereInput | boolean;
    delete?: BarberWhereInput | boolean;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutUserInput,
        BarberUpdateWithoutUserInput
      >,
      BarberUncheckedUpdateWithoutUserInput
    >;
  };

  export type QueueUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutCustomerInput,
          QueueUncheckedCreateWithoutCustomerInput
        >
      | QueueCreateWithoutCustomerInput[]
      | QueueUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutCustomerInput
      | QueueCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutCustomerInput
      | QueueUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: QueueCreateManyCustomerInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutCustomerInput
      | QueueUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutCustomerInput
      | QueueUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutCustomerInput,
          ReviewUncheckedCreateWithoutCustomerInput
        >
      | ReviewCreateWithoutCustomerInput[]
      | ReviewUncheckedCreateWithoutCustomerInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutCustomerInput
      | ReviewCreateOrConnectWithoutCustomerInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutCustomerInput
      | ReviewUpsertWithWhereUniqueWithoutCustomerInput[];
    createMany?: ReviewCreateManyCustomerInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutCustomerInput
      | ReviewUpdateWithWhereUniqueWithoutCustomerInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutCustomerInput
      | ReviewUpdateManyWithWhereWithoutCustomerInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutChangedByInput,
          QueueHistoryUncheckedCreateWithoutChangedByInput
        >
      | QueueHistoryCreateWithoutChangedByInput[]
      | QueueHistoryUncheckedCreateWithoutChangedByInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutChangedByInput
      | QueueHistoryCreateOrConnectWithoutChangedByInput[];
    upsert?:
      | QueueHistoryUpsertWithWhereUniqueWithoutChangedByInput
      | QueueHistoryUpsertWithWhereUniqueWithoutChangedByInput[];
    createMany?: QueueHistoryCreateManyChangedByInputEnvelope;
    set?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    disconnect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    delete?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    update?:
      | QueueHistoryUpdateWithWhereUniqueWithoutChangedByInput
      | QueueHistoryUpdateWithWhereUniqueWithoutChangedByInput[];
    updateMany?:
      | QueueHistoryUpdateManyWithWhereWithoutChangedByInput
      | QueueHistoryUpdateManyWithWhereWithoutChangedByInput[];
    deleteMany?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
  };

  export type BarbershopCreateNestedOneWithoutBarbersInput = {
    create?: XOR<
      BarbershopCreateWithoutBarbersInput,
      BarbershopUncheckedCreateWithoutBarbersInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutBarbersInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutBarberInfoInput = {
    create?: XOR<
      UserCreateWithoutBarberInfoInput,
      UserUncheckedCreateWithoutBarberInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutBarberInfoInput;
    connect?: UserWhereUniqueInput;
  };

  export type BarberServiceCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutBarberInput,
          BarberServiceUncheckedCreateWithoutBarberInput
        >
      | BarberServiceCreateWithoutBarberInput[]
      | BarberServiceUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutBarberInput
      | BarberServiceCreateOrConnectWithoutBarberInput[];
    createMany?: BarberServiceCreateManyBarberInputEnvelope;
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
  };

  export type BarberScheduleCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          BarberScheduleCreateWithoutBarberInput,
          BarberScheduleUncheckedCreateWithoutBarberInput
        >
      | BarberScheduleCreateWithoutBarberInput[]
      | BarberScheduleUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberScheduleCreateOrConnectWithoutBarberInput
      | BarberScheduleCreateOrConnectWithoutBarberInput[];
    createMany?: BarberScheduleCreateManyBarberInputEnvelope;
    connect?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
  };

  export type QueueCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarberInput,
          QueueUncheckedCreateWithoutBarberInput
        >
      | QueueCreateWithoutBarberInput[]
      | QueueUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarberInput
      | QueueCreateOrConnectWithoutBarberInput[];
    createMany?: QueueCreateManyBarberInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarberInput,
          ReviewUncheckedCreateWithoutBarberInput
        >
      | ReviewCreateWithoutBarberInput[]
      | ReviewUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarberInput
      | ReviewCreateOrConnectWithoutBarberInput[];
    createMany?: ReviewCreateManyBarberInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type BarberServiceUncheckedCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutBarberInput,
          BarberServiceUncheckedCreateWithoutBarberInput
        >
      | BarberServiceCreateWithoutBarberInput[]
      | BarberServiceUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutBarberInput
      | BarberServiceCreateOrConnectWithoutBarberInput[];
    createMany?: BarberServiceCreateManyBarberInputEnvelope;
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
  };

  export type BarberScheduleUncheckedCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          BarberScheduleCreateWithoutBarberInput,
          BarberScheduleUncheckedCreateWithoutBarberInput
        >
      | BarberScheduleCreateWithoutBarberInput[]
      | BarberScheduleUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberScheduleCreateOrConnectWithoutBarberInput
      | BarberScheduleCreateOrConnectWithoutBarberInput[];
    createMany?: BarberScheduleCreateManyBarberInputEnvelope;
    connect?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
  };

  export type QueueUncheckedCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarberInput,
          QueueUncheckedCreateWithoutBarberInput
        >
      | QueueCreateWithoutBarberInput[]
      | QueueUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarberInput
      | QueueCreateOrConnectWithoutBarberInput[];
    createMany?: QueueCreateManyBarberInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutBarberInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarberInput,
          ReviewUncheckedCreateWithoutBarberInput
        >
      | ReviewCreateWithoutBarberInput[]
      | ReviewUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarberInput
      | ReviewCreateOrConnectWithoutBarberInput[];
    createMany?: ReviewCreateManyBarberInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type EnumBarberStatusFieldUpdateOperationsInput = {
    set?: $Enums.BarberStatus;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type BarbershopUpdateOneRequiredWithoutBarbersNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutBarbersInput,
      BarbershopUncheckedCreateWithoutBarbersInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutBarbersInput;
    upsert?: BarbershopUpsertWithoutBarbersInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutBarbersInput,
        BarbershopUpdateWithoutBarbersInput
      >,
      BarbershopUncheckedUpdateWithoutBarbersInput
    >;
  };

  export type UserUpdateOneRequiredWithoutBarberInfoNestedInput = {
    create?: XOR<
      UserCreateWithoutBarberInfoInput,
      UserUncheckedCreateWithoutBarberInfoInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutBarberInfoInput;
    upsert?: UserUpsertWithoutBarberInfoInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutBarberInfoInput,
        UserUpdateWithoutBarberInfoInput
      >,
      UserUncheckedUpdateWithoutBarberInfoInput
    >;
  };

  export type BarberServiceUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutBarberInput,
          BarberServiceUncheckedCreateWithoutBarberInput
        >
      | BarberServiceCreateWithoutBarberInput[]
      | BarberServiceUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutBarberInput
      | BarberServiceCreateOrConnectWithoutBarberInput[];
    upsert?:
      | BarberServiceUpsertWithWhereUniqueWithoutBarberInput
      | BarberServiceUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: BarberServiceCreateManyBarberInputEnvelope;
    set?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    disconnect?:
      | BarberServiceWhereUniqueInput
      | BarberServiceWhereUniqueInput[];
    delete?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    update?:
      | BarberServiceUpdateWithWhereUniqueWithoutBarberInput
      | BarberServiceUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | BarberServiceUpdateManyWithWhereWithoutBarberInput
      | BarberServiceUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?:
      | BarberServiceScalarWhereInput
      | BarberServiceScalarWhereInput[];
  };

  export type BarberScheduleUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          BarberScheduleCreateWithoutBarberInput,
          BarberScheduleUncheckedCreateWithoutBarberInput
        >
      | BarberScheduleCreateWithoutBarberInput[]
      | BarberScheduleUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberScheduleCreateOrConnectWithoutBarberInput
      | BarberScheduleCreateOrConnectWithoutBarberInput[];
    upsert?:
      | BarberScheduleUpsertWithWhereUniqueWithoutBarberInput
      | BarberScheduleUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: BarberScheduleCreateManyBarberInputEnvelope;
    set?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    disconnect?:
      | BarberScheduleWhereUniqueInput
      | BarberScheduleWhereUniqueInput[];
    delete?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    connect?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    update?:
      | BarberScheduleUpdateWithWhereUniqueWithoutBarberInput
      | BarberScheduleUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | BarberScheduleUpdateManyWithWhereWithoutBarberInput
      | BarberScheduleUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?:
      | BarberScheduleScalarWhereInput
      | BarberScheduleScalarWhereInput[];
  };

  export type QueueUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarberInput,
          QueueUncheckedCreateWithoutBarberInput
        >
      | QueueCreateWithoutBarberInput[]
      | QueueUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarberInput
      | QueueCreateOrConnectWithoutBarberInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutBarberInput
      | QueueUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: QueueCreateManyBarberInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutBarberInput
      | QueueUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutBarberInput
      | QueueUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarberInput,
          ReviewUncheckedCreateWithoutBarberInput
        >
      | ReviewCreateWithoutBarberInput[]
      | ReviewUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarberInput
      | ReviewCreateOrConnectWithoutBarberInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutBarberInput
      | ReviewUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: ReviewCreateManyBarberInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutBarberInput
      | ReviewUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutBarberInput
      | ReviewUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type BarberServiceUncheckedUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutBarberInput,
          BarberServiceUncheckedCreateWithoutBarberInput
        >
      | BarberServiceCreateWithoutBarberInput[]
      | BarberServiceUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutBarberInput
      | BarberServiceCreateOrConnectWithoutBarberInput[];
    upsert?:
      | BarberServiceUpsertWithWhereUniqueWithoutBarberInput
      | BarberServiceUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: BarberServiceCreateManyBarberInputEnvelope;
    set?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    disconnect?:
      | BarberServiceWhereUniqueInput
      | BarberServiceWhereUniqueInput[];
    delete?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    update?:
      | BarberServiceUpdateWithWhereUniqueWithoutBarberInput
      | BarberServiceUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | BarberServiceUpdateManyWithWhereWithoutBarberInput
      | BarberServiceUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?:
      | BarberServiceScalarWhereInput
      | BarberServiceScalarWhereInput[];
  };

  export type BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          BarberScheduleCreateWithoutBarberInput,
          BarberScheduleUncheckedCreateWithoutBarberInput
        >
      | BarberScheduleCreateWithoutBarberInput[]
      | BarberScheduleUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | BarberScheduleCreateOrConnectWithoutBarberInput
      | BarberScheduleCreateOrConnectWithoutBarberInput[];
    upsert?:
      | BarberScheduleUpsertWithWhereUniqueWithoutBarberInput
      | BarberScheduleUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: BarberScheduleCreateManyBarberInputEnvelope;
    set?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    disconnect?:
      | BarberScheduleWhereUniqueInput
      | BarberScheduleWhereUniqueInput[];
    delete?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    connect?: BarberScheduleWhereUniqueInput | BarberScheduleWhereUniqueInput[];
    update?:
      | BarberScheduleUpdateWithWhereUniqueWithoutBarberInput
      | BarberScheduleUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | BarberScheduleUpdateManyWithWhereWithoutBarberInput
      | BarberScheduleUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?:
      | BarberScheduleScalarWhereInput
      | BarberScheduleScalarWhereInput[];
  };

  export type QueueUncheckedUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutBarberInput,
          QueueUncheckedCreateWithoutBarberInput
        >
      | QueueCreateWithoutBarberInput[]
      | QueueUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutBarberInput
      | QueueCreateOrConnectWithoutBarberInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutBarberInput
      | QueueUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: QueueCreateManyBarberInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutBarberInput
      | QueueUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutBarberInput
      | QueueUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutBarberNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutBarberInput,
          ReviewUncheckedCreateWithoutBarberInput
        >
      | ReviewCreateWithoutBarberInput[]
      | ReviewUncheckedCreateWithoutBarberInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutBarberInput
      | ReviewCreateOrConnectWithoutBarberInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutBarberInput
      | ReviewUpsertWithWhereUniqueWithoutBarberInput[];
    createMany?: ReviewCreateManyBarberInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutBarberInput
      | ReviewUpdateWithWhereUniqueWithoutBarberInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutBarberInput
      | ReviewUpdateManyWithWhereWithoutBarberInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type BarbershopCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      BarbershopCreateWithoutServicesInput,
      BarbershopUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutServicesInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarberServiceCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutServiceInput,
          BarberServiceUncheckedCreateWithoutServiceInput
        >
      | BarberServiceCreateWithoutServiceInput[]
      | BarberServiceUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutServiceInput
      | BarberServiceCreateOrConnectWithoutServiceInput[];
    createMany?: BarberServiceCreateManyServiceInputEnvelope;
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
  };

  export type QueueCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          QueueCreateWithoutServiceInput,
          QueueUncheckedCreateWithoutServiceInput
        >
      | QueueCreateWithoutServiceInput[]
      | QueueUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutServiceInput
      | QueueCreateOrConnectWithoutServiceInput[];
    createMany?: QueueCreateManyServiceInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type BarberServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutServiceInput,
          BarberServiceUncheckedCreateWithoutServiceInput
        >
      | BarberServiceCreateWithoutServiceInput[]
      | BarberServiceUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutServiceInput
      | BarberServiceCreateOrConnectWithoutServiceInput[];
    createMany?: BarberServiceCreateManyServiceInputEnvelope;
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
  };

  export type QueueUncheckedCreateNestedManyWithoutServiceInput = {
    create?:
      | XOR<
          QueueCreateWithoutServiceInput,
          QueueUncheckedCreateWithoutServiceInput
        >
      | QueueCreateWithoutServiceInput[]
      | QueueUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutServiceInput
      | QueueCreateOrConnectWithoutServiceInput[];
    createMany?: QueueCreateManyServiceInputEnvelope;
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type BarbershopUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutServicesInput,
      BarbershopUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutServicesInput;
    upsert?: BarbershopUpsertWithoutServicesInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutServicesInput,
        BarbershopUpdateWithoutServicesInput
      >,
      BarbershopUncheckedUpdateWithoutServicesInput
    >;
  };

  export type BarberServiceUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutServiceInput,
          BarberServiceUncheckedCreateWithoutServiceInput
        >
      | BarberServiceCreateWithoutServiceInput[]
      | BarberServiceUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutServiceInput
      | BarberServiceCreateOrConnectWithoutServiceInput[];
    upsert?:
      | BarberServiceUpsertWithWhereUniqueWithoutServiceInput
      | BarberServiceUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: BarberServiceCreateManyServiceInputEnvelope;
    set?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    disconnect?:
      | BarberServiceWhereUniqueInput
      | BarberServiceWhereUniqueInput[];
    delete?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    update?:
      | BarberServiceUpdateWithWhereUniqueWithoutServiceInput
      | BarberServiceUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | BarberServiceUpdateManyWithWhereWithoutServiceInput
      | BarberServiceUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?:
      | BarberServiceScalarWhereInput
      | BarberServiceScalarWhereInput[];
  };

  export type QueueUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutServiceInput,
          QueueUncheckedCreateWithoutServiceInput
        >
      | QueueCreateWithoutServiceInput[]
      | QueueUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutServiceInput
      | QueueCreateOrConnectWithoutServiceInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutServiceInput
      | QueueUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: QueueCreateManyServiceInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutServiceInput
      | QueueUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutServiceInput
      | QueueUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type BarberServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          BarberServiceCreateWithoutServiceInput,
          BarberServiceUncheckedCreateWithoutServiceInput
        >
      | BarberServiceCreateWithoutServiceInput[]
      | BarberServiceUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | BarberServiceCreateOrConnectWithoutServiceInput
      | BarberServiceCreateOrConnectWithoutServiceInput[];
    upsert?:
      | BarberServiceUpsertWithWhereUniqueWithoutServiceInput
      | BarberServiceUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: BarberServiceCreateManyServiceInputEnvelope;
    set?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    disconnect?:
      | BarberServiceWhereUniqueInput
      | BarberServiceWhereUniqueInput[];
    delete?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    connect?: BarberServiceWhereUniqueInput | BarberServiceWhereUniqueInput[];
    update?:
      | BarberServiceUpdateWithWhereUniqueWithoutServiceInput
      | BarberServiceUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | BarberServiceUpdateManyWithWhereWithoutServiceInput
      | BarberServiceUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?:
      | BarberServiceScalarWhereInput
      | BarberServiceScalarWhereInput[];
  };

  export type QueueUncheckedUpdateManyWithoutServiceNestedInput = {
    create?:
      | XOR<
          QueueCreateWithoutServiceInput,
          QueueUncheckedCreateWithoutServiceInput
        >
      | QueueCreateWithoutServiceInput[]
      | QueueUncheckedCreateWithoutServiceInput[];
    connectOrCreate?:
      | QueueCreateOrConnectWithoutServiceInput
      | QueueCreateOrConnectWithoutServiceInput[];
    upsert?:
      | QueueUpsertWithWhereUniqueWithoutServiceInput
      | QueueUpsertWithWhereUniqueWithoutServiceInput[];
    createMany?: QueueCreateManyServiceInputEnvelope;
    set?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    disconnect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    delete?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    connect?: QueueWhereUniqueInput | QueueWhereUniqueInput[];
    update?:
      | QueueUpdateWithWhereUniqueWithoutServiceInput
      | QueueUpdateWithWhereUniqueWithoutServiceInput[];
    updateMany?:
      | QueueUpdateManyWithWhereWithoutServiceInput
      | QueueUpdateManyWithWhereWithoutServiceInput[];
    deleteMany?: QueueScalarWhereInput | QueueScalarWhereInput[];
  };

  export type BarberCreateNestedOneWithoutServicesInput = {
    create?: XOR<
      BarberCreateWithoutServicesInput,
      BarberUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutServicesInput;
    connect?: BarberWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutBarbersInput = {
    create?: XOR<
      ServiceCreateWithoutBarbersInput,
      ServiceUncheckedCreateWithoutBarbersInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutBarbersInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type BarberUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<
      BarberCreateWithoutServicesInput,
      BarberUncheckedCreateWithoutServicesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutServicesInput;
    upsert?: BarberUpsertWithoutServicesInput;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutServicesInput,
        BarberUpdateWithoutServicesInput
      >,
      BarberUncheckedUpdateWithoutServicesInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutBarbersNestedInput = {
    create?: XOR<
      ServiceCreateWithoutBarbersInput,
      ServiceUncheckedCreateWithoutBarbersInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutBarbersInput;
    upsert?: ServiceUpsertWithoutBarbersInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutBarbersInput,
        ServiceUpdateWithoutBarbersInput
      >,
      ServiceUncheckedUpdateWithoutBarbersInput
    >;
  };

  export type BarbershopCreateNestedOneWithoutQueuesInput = {
    create?: XOR<
      BarbershopCreateWithoutQueuesInput,
      BarbershopUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutQueuesInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarberCreateNestedOneWithoutQueuesInput = {
    create?: XOR<
      BarberCreateWithoutQueuesInput,
      BarberUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutQueuesInput;
    connect?: BarberWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutQueuesInput = {
    create?: XOR<
      UserCreateWithoutQueuesInput,
      UserUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput;
    connect?: UserWhereUniqueInput;
  };

  export type ServiceCreateNestedOneWithoutQueuesInput = {
    create?: XOR<
      ServiceCreateWithoutQueuesInput,
      ServiceUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutQueuesInput;
    connect?: ServiceWhereUniqueInput;
  };

  export type QueueHistoryCreateNestedManyWithoutQueueInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutQueueInput,
          QueueHistoryUncheckedCreateWithoutQueueInput
        >
      | QueueHistoryCreateWithoutQueueInput[]
      | QueueHistoryUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutQueueInput
      | QueueHistoryCreateOrConnectWithoutQueueInput[];
    createMany?: QueueHistoryCreateManyQueueInputEnvelope;
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
  };

  export type ReviewCreateNestedManyWithoutQueueInput = {
    create?:
      | XOR<
          ReviewCreateWithoutQueueInput,
          ReviewUncheckedCreateWithoutQueueInput
        >
      | ReviewCreateWithoutQueueInput[]
      | ReviewUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutQueueInput
      | ReviewCreateOrConnectWithoutQueueInput[];
    createMany?: ReviewCreateManyQueueInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type QueueHistoryUncheckedCreateNestedManyWithoutQueueInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutQueueInput,
          QueueHistoryUncheckedCreateWithoutQueueInput
        >
      | QueueHistoryCreateWithoutQueueInput[]
      | QueueHistoryUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutQueueInput
      | QueueHistoryCreateOrConnectWithoutQueueInput[];
    createMany?: QueueHistoryCreateManyQueueInputEnvelope;
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
  };

  export type ReviewUncheckedCreateNestedManyWithoutQueueInput = {
    create?:
      | XOR<
          ReviewCreateWithoutQueueInput,
          ReviewUncheckedCreateWithoutQueueInput
        >
      | ReviewCreateWithoutQueueInput[]
      | ReviewUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutQueueInput
      | ReviewCreateOrConnectWithoutQueueInput[];
    createMany?: ReviewCreateManyQueueInputEnvelope;
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
  };

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type BarbershopUpdateOneRequiredWithoutQueuesNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutQueuesInput,
      BarbershopUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutQueuesInput;
    upsert?: BarbershopUpsertWithoutQueuesInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutQueuesInput,
        BarbershopUpdateWithoutQueuesInput
      >,
      BarbershopUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type BarberUpdateOneWithoutQueuesNestedInput = {
    create?: XOR<
      BarberCreateWithoutQueuesInput,
      BarberUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutQueuesInput;
    upsert?: BarberUpsertWithoutQueuesInput;
    disconnect?: BarberWhereInput | boolean;
    delete?: BarberWhereInput | boolean;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutQueuesInput,
        BarberUpdateWithoutQueuesInput
      >,
      BarberUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type UserUpdateOneWithoutQueuesNestedInput = {
    create?: XOR<
      UserCreateWithoutQueuesInput,
      UserUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutQueuesInput;
    upsert?: UserUpsertWithoutQueuesInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutQueuesInput,
        UserUpdateWithoutQueuesInput
      >,
      UserUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type ServiceUpdateOneRequiredWithoutQueuesNestedInput = {
    create?: XOR<
      ServiceCreateWithoutQueuesInput,
      ServiceUncheckedCreateWithoutQueuesInput
    >;
    connectOrCreate?: ServiceCreateOrConnectWithoutQueuesInput;
    upsert?: ServiceUpsertWithoutQueuesInput;
    connect?: ServiceWhereUniqueInput;
    update?: XOR<
      XOR<
        ServiceUpdateToOneWithWhereWithoutQueuesInput,
        ServiceUpdateWithoutQueuesInput
      >,
      ServiceUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type QueueHistoryUpdateManyWithoutQueueNestedInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutQueueInput,
          QueueHistoryUncheckedCreateWithoutQueueInput
        >
      | QueueHistoryCreateWithoutQueueInput[]
      | QueueHistoryUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutQueueInput
      | QueueHistoryCreateOrConnectWithoutQueueInput[];
    upsert?:
      | QueueHistoryUpsertWithWhereUniqueWithoutQueueInput
      | QueueHistoryUpsertWithWhereUniqueWithoutQueueInput[];
    createMany?: QueueHistoryCreateManyQueueInputEnvelope;
    set?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    disconnect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    delete?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    update?:
      | QueueHistoryUpdateWithWhereUniqueWithoutQueueInput
      | QueueHistoryUpdateWithWhereUniqueWithoutQueueInput[];
    updateMany?:
      | QueueHistoryUpdateManyWithWhereWithoutQueueInput
      | QueueHistoryUpdateManyWithWhereWithoutQueueInput[];
    deleteMany?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
  };

  export type ReviewUpdateManyWithoutQueueNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutQueueInput,
          ReviewUncheckedCreateWithoutQueueInput
        >
      | ReviewCreateWithoutQueueInput[]
      | ReviewUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutQueueInput
      | ReviewCreateOrConnectWithoutQueueInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutQueueInput
      | ReviewUpsertWithWhereUniqueWithoutQueueInput[];
    createMany?: ReviewCreateManyQueueInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutQueueInput
      | ReviewUpdateWithWhereUniqueWithoutQueueInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutQueueInput
      | ReviewUpdateManyWithWhereWithoutQueueInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput = {
    create?:
      | XOR<
          QueueHistoryCreateWithoutQueueInput,
          QueueHistoryUncheckedCreateWithoutQueueInput
        >
      | QueueHistoryCreateWithoutQueueInput[]
      | QueueHistoryUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | QueueHistoryCreateOrConnectWithoutQueueInput
      | QueueHistoryCreateOrConnectWithoutQueueInput[];
    upsert?:
      | QueueHistoryUpsertWithWhereUniqueWithoutQueueInput
      | QueueHistoryUpsertWithWhereUniqueWithoutQueueInput[];
    createMany?: QueueHistoryCreateManyQueueInputEnvelope;
    set?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    disconnect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    delete?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    connect?: QueueHistoryWhereUniqueInput | QueueHistoryWhereUniqueInput[];
    update?:
      | QueueHistoryUpdateWithWhereUniqueWithoutQueueInput
      | QueueHistoryUpdateWithWhereUniqueWithoutQueueInput[];
    updateMany?:
      | QueueHistoryUpdateManyWithWhereWithoutQueueInput
      | QueueHistoryUpdateManyWithWhereWithoutQueueInput[];
    deleteMany?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
  };

  export type ReviewUncheckedUpdateManyWithoutQueueNestedInput = {
    create?:
      | XOR<
          ReviewCreateWithoutQueueInput,
          ReviewUncheckedCreateWithoutQueueInput
        >
      | ReviewCreateWithoutQueueInput[]
      | ReviewUncheckedCreateWithoutQueueInput[];
    connectOrCreate?:
      | ReviewCreateOrConnectWithoutQueueInput
      | ReviewCreateOrConnectWithoutQueueInput[];
    upsert?:
      | ReviewUpsertWithWhereUniqueWithoutQueueInput
      | ReviewUpsertWithWhereUniqueWithoutQueueInput[];
    createMany?: ReviewCreateManyQueueInputEnvelope;
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[];
    update?:
      | ReviewUpdateWithWhereUniqueWithoutQueueInput
      | ReviewUpdateWithWhereUniqueWithoutQueueInput[];
    updateMany?:
      | ReviewUpdateManyWithWhereWithoutQueueInput
      | ReviewUpdateManyWithWhereWithoutQueueInput[];
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
  };

  export type QueueCreateNestedOneWithoutHistoryInput = {
    create?: XOR<
      QueueCreateWithoutHistoryInput,
      QueueUncheckedCreateWithoutHistoryInput
    >;
    connectOrCreate?: QueueCreateOrConnectWithoutHistoryInput;
    connect?: QueueWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutChangedLogsInput = {
    create?: XOR<
      UserCreateWithoutChangedLogsInput,
      UserUncheckedCreateWithoutChangedLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutChangedLogsInput;
    connect?: UserWhereUniqueInput;
  };

  export type NullableEnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus | null;
  };

  export type QueueUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<
      QueueCreateWithoutHistoryInput,
      QueueUncheckedCreateWithoutHistoryInput
    >;
    connectOrCreate?: QueueCreateOrConnectWithoutHistoryInput;
    upsert?: QueueUpsertWithoutHistoryInput;
    connect?: QueueWhereUniqueInput;
    update?: XOR<
      XOR<
        QueueUpdateToOneWithWhereWithoutHistoryInput,
        QueueUpdateWithoutHistoryInput
      >,
      QueueUncheckedUpdateWithoutHistoryInput
    >;
  };

  export type UserUpdateOneWithoutChangedLogsNestedInput = {
    create?: XOR<
      UserCreateWithoutChangedLogsInput,
      UserUncheckedCreateWithoutChangedLogsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutChangedLogsInput;
    upsert?: UserUpsertWithoutChangedLogsInput;
    disconnect?: UserWhereInput | boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutChangedLogsInput,
        UserUpdateWithoutChangedLogsInput
      >,
      UserUncheckedUpdateWithoutChangedLogsInput
    >;
  };

  export type BarbershopCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      BarbershopCreateWithoutReviewsInput,
      BarbershopUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutReviewsInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarberCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      BarberCreateWithoutReviewsInput,
      BarberUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutReviewsInput;
    connect?: BarberWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    connect?: UserWhereUniqueInput;
  };

  export type QueueCreateNestedOneWithoutReviewsInput = {
    create?: XOR<
      QueueCreateWithoutReviewsInput,
      QueueUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: QueueCreateOrConnectWithoutReviewsInput;
    connect?: QueueWhereUniqueInput;
  };

  export type BarbershopUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutReviewsInput,
      BarbershopUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutReviewsInput;
    upsert?: BarbershopUpsertWithoutReviewsInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutReviewsInput,
        BarbershopUpdateWithoutReviewsInput
      >,
      BarbershopUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type BarberUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<
      BarberCreateWithoutReviewsInput,
      BarberUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutReviewsInput;
    upsert?: BarberUpsertWithoutReviewsInput;
    disconnect?: BarberWhereInput | boolean;
    delete?: BarberWhereInput | boolean;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutReviewsInput,
        BarberUpdateWithoutReviewsInput
      >,
      BarberUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput;
    upsert?: UserUpsertWithoutReviewsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutReviewsInput,
        UserUpdateWithoutReviewsInput
      >,
      UserUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type QueueUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<
      QueueCreateWithoutReviewsInput,
      QueueUncheckedCreateWithoutReviewsInput
    >;
    connectOrCreate?: QueueCreateOrConnectWithoutReviewsInput;
    upsert?: QueueUpsertWithoutReviewsInput;
    disconnect?: QueueWhereInput | boolean;
    delete?: QueueWhereInput | boolean;
    connect?: QueueWhereUniqueInput;
    update?: XOR<
      XOR<
        QueueUpdateToOneWithWhereWithoutReviewsInput,
        QueueUpdateWithoutReviewsInput
      >,
      QueueUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type BarberCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<
      BarberCreateWithoutSchedulesInput,
      BarberUncheckedCreateWithoutSchedulesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutSchedulesInput;
    connect?: BarberWhereUniqueInput;
  };

  export type BarberUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<
      BarberCreateWithoutSchedulesInput,
      BarberUncheckedCreateWithoutSchedulesInput
    >;
    connectOrCreate?: BarberCreateOrConnectWithoutSchedulesInput;
    upsert?: BarberUpsertWithoutSchedulesInput;
    connect?: BarberWhereUniqueInput;
    update?: XOR<
      XOR<
        BarberUpdateToOneWithWhereWithoutSchedulesInput,
        BarberUpdateWithoutSchedulesInput
      >,
      BarberUncheckedUpdateWithoutSchedulesInput
    >;
  };

  export type BarbershopCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<
      BarbershopCreateWithoutSubscriptionsInput,
      BarbershopUncheckedCreateWithoutSubscriptionsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutSubscriptionsInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarbershopUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutSubscriptionsInput,
      BarbershopUncheckedCreateWithoutSubscriptionsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutSubscriptionsInput;
    upsert?: BarbershopUpsertWithoutSubscriptionsInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutSubscriptionsInput,
        BarbershopUpdateWithoutSubscriptionsInput
      >,
      BarbershopUncheckedUpdateWithoutSubscriptionsInput
    >;
  };

  export type BarbershopCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<
      BarbershopCreateWithoutAnalyticsInput,
      BarbershopUncheckedCreateWithoutAnalyticsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutAnalyticsInput;
    connect?: BarbershopWhereUniqueInput;
  };

  export type BarbershopUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<
      BarbershopCreateWithoutAnalyticsInput,
      BarbershopUncheckedCreateWithoutAnalyticsInput
    >;
    connectOrCreate?: BarbershopCreateOrConnectWithoutAnalyticsInput;
    upsert?: BarbershopUpsertWithoutAnalyticsInput;
    connect?: BarbershopWhereUniqueInput;
    update?: XOR<
      XOR<
        BarbershopUpdateToOneWithWhereWithoutAnalyticsInput,
        BarbershopUpdateWithoutAnalyticsInput
      >,
      BarbershopUncheckedUpdateWithoutAnalyticsInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
  };

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.SubscriptionStatus
      | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionStatusFilter<$PrismaModel>
      | $Enums.SubscriptionStatus;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.SubscriptionStatus
      | EnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.SubscriptionStatus[]
      | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.SubscriptionStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>;
  };
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<
          Required<NestedJsonFilterBase<$PrismaModel>>,
          Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>
        >,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>;

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
    path?: string[];
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>;
    string_contains?: string | StringFieldRefInput<$PrismaModel>;
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>;
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>;
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null;
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>;
    not?:
      | InputJsonValue
      | JsonFieldRefInput<$PrismaModel>
      | JsonNullValueFilter;
  };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedEnumBarberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BarberStatus | EnumBarberStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BarberStatus[]
      | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumBarberStatusFilter<$PrismaModel> | $Enums.BarberStatus;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
  };

  export type NestedEnumBarberStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.BarberStatus
        | EnumBarberStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.BarberStatus[]
        | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.BarberStatus[]
        | ListEnumBarberStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumBarberStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.BarberStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumBarberStatusFilter<$PrismaModel>;
      _max?: NestedEnumBarberStatusFilter<$PrismaModel>;
    };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
  };

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.QueueStatus[]
        | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.QueueStatus[]
        | ListEnumQueueStatusFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel>
        | $Enums.QueueStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumQueueStatusFilter<$PrismaModel>;
      _max?: NestedEnumQueueStatusFilter<$PrismaModel>;
    };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedEnumQueueStatusNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.QueueStatus
      | EnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumQueueStatusNullableFilter<$PrismaModel>
      | $Enums.QueueStatus
      | null;
  };

  export type NestedEnumQueueStatusNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.QueueStatus
      | EnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.QueueStatus[]
      | ListEnumQueueStatusFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumQueueStatusNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.QueueStatus
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumQueueStatusNullableFilter<$PrismaModel>;
    _max?: NestedEnumQueueStatusNullableFilter<$PrismaModel>;
  };

  export type UserCreateWithoutBarbershopInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberCreateNestedOneWithoutUserInput;
    queues?: QueueCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryCreateNestedManyWithoutChangedByInput;
  };

  export type UserUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberUncheckedCreateNestedOneWithoutUserInput;
    queues?: QueueUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput;
  };

  export type UserCreateOrConnectWithoutBarbershopInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutBarbershopInput,
      UserUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type UserCreateManyBarbershopInputEnvelope = {
    data: UserCreateManyBarbershopInput | UserCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type BarberCreateWithoutBarbershopInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutBarbershopInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutBarbershopInput,
      BarberUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type BarberCreateManyBarbershopInputEnvelope = {
    data: BarberCreateManyBarbershopInput | BarberCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type ServiceCreateWithoutBarbershopInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberServiceCreateNestedManyWithoutServiceInput;
    queues?: QueueCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberServiceUncheckedCreateNestedManyWithoutServiceInput;
    queues?: QueueUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutBarbershopInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutBarbershopInput,
      ServiceUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type ServiceCreateManyBarbershopInputEnvelope = {
    data: ServiceCreateManyBarbershopInput | ServiceCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type BarbershopSubscriptionCreateWithoutBarbershopInput = {
    id?: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type BarbershopSubscriptionCreateOrConnectWithoutBarbershopInput = {
    where: BarbershopSubscriptionWhereUniqueInput;
    create: XOR<
      BarbershopSubscriptionCreateWithoutBarbershopInput,
      BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type BarbershopSubscriptionCreateManyBarbershopInputEnvelope = {
    data:
      | BarbershopSubscriptionCreateManyBarbershopInput
      | BarbershopSubscriptionCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type QueueCreateWithoutBarbershopInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutBarbershopInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutBarbershopInput,
      QueueUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type QueueCreateManyBarbershopInputEnvelope = {
    data: QueueCreateManyBarbershopInput | QueueCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutBarbershopInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    barber?: BarberCreateNestedOneWithoutReviewsInput;
    customer: UserCreateNestedOneWithoutReviewsInput;
    queue?: QueueCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    barberId?: string | null;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutBarbershopInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutBarbershopInput,
      ReviewUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type ReviewCreateManyBarbershopInputEnvelope = {
    data: ReviewCreateManyBarbershopInput | ReviewCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type AnalyticsDailyCreateWithoutBarbershopInput = {
    id?: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUncheckedCreateWithoutBarbershopInput = {
    id?: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyCreateOrConnectWithoutBarbershopInput = {
    where: AnalyticsDailyWhereUniqueInput;
    create: XOR<
      AnalyticsDailyCreateWithoutBarbershopInput,
      AnalyticsDailyUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type AnalyticsDailyCreateManyBarbershopInputEnvelope = {
    data:
      | AnalyticsDailyCreateManyBarbershopInput
      | AnalyticsDailyCreateManyBarbershopInput[];
    skipDuplicates?: boolean;
  };

  export type UserUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutBarbershopInput,
      UserUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      UserCreateWithoutBarbershopInput,
      UserUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: UserWhereUniqueInput;
    data: XOR<
      UserUpdateWithoutBarbershopInput,
      UserUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type UserUpdateManyWithWhereWithoutBarbershopInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<'User'> | string;
    barbershopId?: StringNullableFilter<'User'> | string | null;
    fullName?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    phoneNumber?: StringFilter<'User'> | string;
    passwordHash?: StringFilter<'User'> | string;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    fcmToken?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'User'> | Date | string | null;
  };

  export type BarberUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: BarberWhereUniqueInput;
    update: XOR<
      BarberUpdateWithoutBarbershopInput,
      BarberUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      BarberCreateWithoutBarbershopInput,
      BarberUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type BarberUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: BarberWhereUniqueInput;
    data: XOR<
      BarberUpdateWithoutBarbershopInput,
      BarberUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type BarberUpdateManyWithWhereWithoutBarbershopInput = {
    where: BarberScalarWhereInput;
    data: XOR<
      BarberUpdateManyMutationInput,
      BarberUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type BarberScalarWhereInput = {
    AND?: BarberScalarWhereInput | BarberScalarWhereInput[];
    OR?: BarberScalarWhereInput[];
    NOT?: BarberScalarWhereInput | BarberScalarWhereInput[];
    id?: StringFilter<'Barber'> | string;
    barbershopId?: StringFilter<'Barber'> | string;
    userId?: StringFilter<'Barber'> | string;
    displayName?: StringNullableFilter<'Barber'> | string | null;
    specialization?: StringNullableFilter<'Barber'> | string | null;
    status?: EnumBarberStatusFilter<'Barber'> | $Enums.BarberStatus;
    commissionRate?: FloatNullableFilter<'Barber'> | number | null;
    createdAt?: DateTimeFilter<'Barber'> | Date | string;
    updatedAt?: DateTimeFilter<'Barber'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Barber'> | Date | string | null;
  };

  export type ServiceUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: ServiceWhereUniqueInput;
    update: XOR<
      ServiceUpdateWithoutBarbershopInput,
      ServiceUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      ServiceCreateWithoutBarbershopInput,
      ServiceUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type ServiceUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: ServiceWhereUniqueInput;
    data: XOR<
      ServiceUpdateWithoutBarbershopInput,
      ServiceUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type ServiceUpdateManyWithWhereWithoutBarbershopInput = {
    where: ServiceScalarWhereInput;
    data: XOR<
      ServiceUpdateManyMutationInput,
      ServiceUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    OR?: ServiceScalarWhereInput[];
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[];
    id?: StringFilter<'Service'> | string;
    barbershopId?: StringFilter<'Service'> | string;
    name?: StringFilter<'Service'> | string;
    description?: StringNullableFilter<'Service'> | string | null;
    durationMinutes?: IntFilter<'Service'> | number;
    price?: FloatFilter<'Service'> | number;
    createdAt?: DateTimeFilter<'Service'> | Date | string;
    updatedAt?: DateTimeFilter<'Service'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Service'> | Date | string | null;
  };

  export type BarbershopSubscriptionUpsertWithWhereUniqueWithoutBarbershopInput =
    {
      where: BarbershopSubscriptionWhereUniqueInput;
      update: XOR<
        BarbershopSubscriptionUpdateWithoutBarbershopInput,
        BarbershopSubscriptionUncheckedUpdateWithoutBarbershopInput
      >;
      create: XOR<
        BarbershopSubscriptionCreateWithoutBarbershopInput,
        BarbershopSubscriptionUncheckedCreateWithoutBarbershopInput
      >;
    };

  export type BarbershopSubscriptionUpdateWithWhereUniqueWithoutBarbershopInput =
    {
      where: BarbershopSubscriptionWhereUniqueInput;
      data: XOR<
        BarbershopSubscriptionUpdateWithoutBarbershopInput,
        BarbershopSubscriptionUncheckedUpdateWithoutBarbershopInput
      >;
    };

  export type BarbershopSubscriptionUpdateManyWithWhereWithoutBarbershopInput =
    {
      where: BarbershopSubscriptionScalarWhereInput;
      data: XOR<
        BarbershopSubscriptionUpdateManyMutationInput,
        BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopInput
      >;
    };

  export type BarbershopSubscriptionScalarWhereInput = {
    AND?:
      | BarbershopSubscriptionScalarWhereInput
      | BarbershopSubscriptionScalarWhereInput[];
    OR?: BarbershopSubscriptionScalarWhereInput[];
    NOT?:
      | BarbershopSubscriptionScalarWhereInput
      | BarbershopSubscriptionScalarWhereInput[];
    id?: StringFilter<'BarbershopSubscription'> | string;
    barbershopId?: StringFilter<'BarbershopSubscription'> | string;
    planId?: StringFilter<'BarbershopSubscription'> | string;
    status?:
      | EnumSubscriptionStatusFilter<'BarbershopSubscription'>
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    endDate?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    createdAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
    updatedAt?: DateTimeFilter<'BarbershopSubscription'> | Date | string;
  };

  export type QueueUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: QueueWhereUniqueInput;
    update: XOR<
      QueueUpdateWithoutBarbershopInput,
      QueueUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      QueueCreateWithoutBarbershopInput,
      QueueUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type QueueUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: QueueWhereUniqueInput;
    data: XOR<
      QueueUpdateWithoutBarbershopInput,
      QueueUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type QueueUpdateManyWithWhereWithoutBarbershopInput = {
    where: QueueScalarWhereInput;
    data: XOR<
      QueueUpdateManyMutationInput,
      QueueUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type QueueScalarWhereInput = {
    AND?: QueueScalarWhereInput | QueueScalarWhereInput[];
    OR?: QueueScalarWhereInput[];
    NOT?: QueueScalarWhereInput | QueueScalarWhereInput[];
    id?: StringFilter<'Queue'> | string;
    barbershopId?: StringFilter<'Queue'> | string;
    barberId?: StringNullableFilter<'Queue'> | string | null;
    customerId?: StringNullableFilter<'Queue'> | string | null;
    guestName?: StringNullableFilter<'Queue'> | string | null;
    serviceId?: StringFilter<'Queue'> | string;
    status?: EnumQueueStatusFilter<'Queue'> | $Enums.QueueStatus;
    bookingSource?: StringFilter<'Queue'> | string;
    scheduledTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    estimatedStartTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    estimatedEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    actualStartTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    actualEndTime?: DateTimeNullableFilter<'Queue'> | Date | string | null;
    notified30m?: BoolFilter<'Queue'> | boolean;
    notified15m?: BoolFilter<'Queue'> | boolean;
    createdAt?: DateTimeFilter<'Queue'> | Date | string;
    updatedAt?: DateTimeFilter<'Queue'> | Date | string;
    deletedAt?: DateTimeNullableFilter<'Queue'> | Date | string | null;
  };

  export type ReviewUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutBarbershopInput,
      ReviewUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      ReviewCreateWithoutBarbershopInput,
      ReviewUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutBarbershopInput,
      ReviewUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutBarbershopInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    OR?: ReviewScalarWhereInput[];
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[];
    id?: StringFilter<'Review'> | string;
    barbershopId?: StringFilter<'Review'> | string;
    barberId?: StringNullableFilter<'Review'> | string | null;
    customerId?: StringFilter<'Review'> | string;
    queueId?: StringNullableFilter<'Review'> | string | null;
    rating?: IntFilter<'Review'> | number;
    comment?: StringNullableFilter<'Review'> | string | null;
    createdAt?: DateTimeFilter<'Review'> | Date | string;
  };

  export type AnalyticsDailyUpsertWithWhereUniqueWithoutBarbershopInput = {
    where: AnalyticsDailyWhereUniqueInput;
    update: XOR<
      AnalyticsDailyUpdateWithoutBarbershopInput,
      AnalyticsDailyUncheckedUpdateWithoutBarbershopInput
    >;
    create: XOR<
      AnalyticsDailyCreateWithoutBarbershopInput,
      AnalyticsDailyUncheckedCreateWithoutBarbershopInput
    >;
  };

  export type AnalyticsDailyUpdateWithWhereUniqueWithoutBarbershopInput = {
    where: AnalyticsDailyWhereUniqueInput;
    data: XOR<
      AnalyticsDailyUpdateWithoutBarbershopInput,
      AnalyticsDailyUncheckedUpdateWithoutBarbershopInput
    >;
  };

  export type AnalyticsDailyUpdateManyWithWhereWithoutBarbershopInput = {
    where: AnalyticsDailyScalarWhereInput;
    data: XOR<
      AnalyticsDailyUpdateManyMutationInput,
      AnalyticsDailyUncheckedUpdateManyWithoutBarbershopInput
    >;
  };

  export type AnalyticsDailyScalarWhereInput = {
    AND?: AnalyticsDailyScalarWhereInput | AnalyticsDailyScalarWhereInput[];
    OR?: AnalyticsDailyScalarWhereInput[];
    NOT?: AnalyticsDailyScalarWhereInput | AnalyticsDailyScalarWhereInput[];
    id?: StringFilter<'AnalyticsDaily'> | string;
    barbershopId?: StringFilter<'AnalyticsDaily'> | string;
    date?: DateTimeFilter<'AnalyticsDaily'> | Date | string;
    totalQueues?: IntFilter<'AnalyticsDaily'> | number;
    totalRevenue?: FloatFilter<'AnalyticsDaily'> | number;
    data?: JsonFilter<'AnalyticsDaily'>;
  };

  export type BarbershopCreateWithoutUsersInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutUsersInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutUsersInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutUsersInput,
      BarbershopUncheckedCreateWithoutUsersInput
    >;
  };

  export type BarberCreateWithoutUserInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutUserInput = {
    id?: string;
    barbershopId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutUserInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
  };

  export type QueueCreateWithoutCustomerInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutCustomerInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutCustomerInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutCustomerInput,
      QueueUncheckedCreateWithoutCustomerInput
    >;
  };

  export type QueueCreateManyCustomerInputEnvelope = {
    data: QueueCreateManyCustomerInput | QueueCreateManyCustomerInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutCustomerInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    barbershop: BarbershopCreateNestedOneWithoutReviewsInput;
    barber?: BarberCreateNestedOneWithoutReviewsInput;
    queue?: QueueCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutCustomerInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutCustomerInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutCustomerInput,
      ReviewUncheckedCreateWithoutCustomerInput
    >;
  };

  export type ReviewCreateManyCustomerInputEnvelope = {
    data: ReviewCreateManyCustomerInput | ReviewCreateManyCustomerInput[];
    skipDuplicates?: boolean;
  };

  export type QueueHistoryCreateWithoutChangedByInput = {
    id?: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    notes?: string | null;
    createdAt?: Date | string;
    queue: QueueCreateNestedOneWithoutHistoryInput;
  };

  export type QueueHistoryUncheckedCreateWithoutChangedByInput = {
    id?: string;
    queueId: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryCreateOrConnectWithoutChangedByInput = {
    where: QueueHistoryWhereUniqueInput;
    create: XOR<
      QueueHistoryCreateWithoutChangedByInput,
      QueueHistoryUncheckedCreateWithoutChangedByInput
    >;
  };

  export type QueueHistoryCreateManyChangedByInputEnvelope = {
    data:
      | QueueHistoryCreateManyChangedByInput
      | QueueHistoryCreateManyChangedByInput[];
    skipDuplicates?: boolean;
  };

  export type BarbershopUpsertWithoutUsersInput = {
    update: XOR<
      BarbershopUpdateWithoutUsersInput,
      BarbershopUncheckedUpdateWithoutUsersInput
    >;
    create: XOR<
      BarbershopCreateWithoutUsersInput,
      BarbershopUncheckedCreateWithoutUsersInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutUsersInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutUsersInput,
      BarbershopUncheckedUpdateWithoutUsersInput
    >;
  };

  export type BarbershopUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarberUpsertWithoutUserInput = {
    update: XOR<
      BarberUpdateWithoutUserInput,
      BarberUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      BarberCreateWithoutUserInput,
      BarberUncheckedCreateWithoutUserInput
    >;
    where?: BarberWhereInput;
  };

  export type BarberUpdateToOneWithWhereWithoutUserInput = {
    where?: BarberWhereInput;
    data: XOR<
      BarberUpdateWithoutUserInput,
      BarberUncheckedUpdateWithoutUserInput
    >;
  };

  export type BarberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type QueueUpsertWithWhereUniqueWithoutCustomerInput = {
    where: QueueWhereUniqueInput;
    update: XOR<
      QueueUpdateWithoutCustomerInput,
      QueueUncheckedUpdateWithoutCustomerInput
    >;
    create: XOR<
      QueueCreateWithoutCustomerInput,
      QueueUncheckedCreateWithoutCustomerInput
    >;
  };

  export type QueueUpdateWithWhereUniqueWithoutCustomerInput = {
    where: QueueWhereUniqueInput;
    data: XOR<
      QueueUpdateWithoutCustomerInput,
      QueueUncheckedUpdateWithoutCustomerInput
    >;
  };

  export type QueueUpdateManyWithWhereWithoutCustomerInput = {
    where: QueueScalarWhereInput;
    data: XOR<
      QueueUpdateManyMutationInput,
      QueueUncheckedUpdateManyWithoutCustomerInput
    >;
  };

  export type ReviewUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutCustomerInput,
      ReviewUncheckedUpdateWithoutCustomerInput
    >;
    create: XOR<
      ReviewCreateWithoutCustomerInput,
      ReviewUncheckedCreateWithoutCustomerInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutCustomerInput,
      ReviewUncheckedUpdateWithoutCustomerInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutCustomerInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutCustomerInput
    >;
  };

  export type QueueHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: QueueHistoryWhereUniqueInput;
    update: XOR<
      QueueHistoryUpdateWithoutChangedByInput,
      QueueHistoryUncheckedUpdateWithoutChangedByInput
    >;
    create: XOR<
      QueueHistoryCreateWithoutChangedByInput,
      QueueHistoryUncheckedCreateWithoutChangedByInput
    >;
  };

  export type QueueHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: QueueHistoryWhereUniqueInput;
    data: XOR<
      QueueHistoryUpdateWithoutChangedByInput,
      QueueHistoryUncheckedUpdateWithoutChangedByInput
    >;
  };

  export type QueueHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: QueueHistoryScalarWhereInput;
    data: XOR<
      QueueHistoryUpdateManyMutationInput,
      QueueHistoryUncheckedUpdateManyWithoutChangedByInput
    >;
  };

  export type QueueHistoryScalarWhereInput = {
    AND?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
    OR?: QueueHistoryScalarWhereInput[];
    NOT?: QueueHistoryScalarWhereInput | QueueHistoryScalarWhereInput[];
    id?: StringFilter<'QueueHistory'> | string;
    queueId?: StringFilter<'QueueHistory'> | string;
    previousStatus?:
      | EnumQueueStatusNullableFilter<'QueueHistory'>
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFilter<'QueueHistory'> | $Enums.QueueStatus;
    changedById?: StringNullableFilter<'QueueHistory'> | string | null;
    notes?: StringNullableFilter<'QueueHistory'> | string | null;
    createdAt?: DateTimeFilter<'QueueHistory'> | Date | string;
  };

  export type BarbershopCreateWithoutBarbersInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutBarbersInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutBarbersInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutBarbersInput,
      BarbershopUncheckedCreateWithoutBarbersInput
    >;
  };

  export type UserCreateWithoutBarberInfoInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop?: BarbershopCreateNestedOneWithoutUsersInput;
    queues?: QueueCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryCreateNestedManyWithoutChangedByInput;
  };

  export type UserUncheckedCreateWithoutBarberInfoInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    queues?: QueueUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput;
  };

  export type UserCreateOrConnectWithoutBarberInfoInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutBarberInfoInput,
      UserUncheckedCreateWithoutBarberInfoInput
    >;
  };

  export type BarberServiceCreateWithoutBarberInput = {
    customDurationMinutes?: number | null;
    service: ServiceCreateNestedOneWithoutBarbersInput;
  };

  export type BarberServiceUncheckedCreateWithoutBarberInput = {
    serviceId: string;
    customDurationMinutes?: number | null;
  };

  export type BarberServiceCreateOrConnectWithoutBarberInput = {
    where: BarberServiceWhereUniqueInput;
    create: XOR<
      BarberServiceCreateWithoutBarberInput,
      BarberServiceUncheckedCreateWithoutBarberInput
    >;
  };

  export type BarberServiceCreateManyBarberInputEnvelope = {
    data:
      | BarberServiceCreateManyBarberInput
      | BarberServiceCreateManyBarberInput[];
    skipDuplicates?: boolean;
  };

  export type BarberScheduleCreateWithoutBarberInput = {
    id?: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
  };

  export type BarberScheduleUncheckedCreateWithoutBarberInput = {
    id?: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
  };

  export type BarberScheduleCreateOrConnectWithoutBarberInput = {
    where: BarberScheduleWhereUniqueInput;
    create: XOR<
      BarberScheduleCreateWithoutBarberInput,
      BarberScheduleUncheckedCreateWithoutBarberInput
    >;
  };

  export type BarberScheduleCreateManyBarberInputEnvelope = {
    data:
      | BarberScheduleCreateManyBarberInput
      | BarberScheduleCreateManyBarberInput[];
    skipDuplicates?: boolean;
  };

  export type QueueCreateWithoutBarberInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutBarberInput = {
    id?: string;
    barbershopId: string;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutBarberInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutBarberInput,
      QueueUncheckedCreateWithoutBarberInput
    >;
  };

  export type QueueCreateManyBarberInputEnvelope = {
    data: QueueCreateManyBarberInput | QueueCreateManyBarberInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutBarberInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    barbershop: BarbershopCreateNestedOneWithoutReviewsInput;
    customer: UserCreateNestedOneWithoutReviewsInput;
    queue?: QueueCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutBarberInput = {
    id?: string;
    barbershopId: string;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutBarberInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutBarberInput,
      ReviewUncheckedCreateWithoutBarberInput
    >;
  };

  export type ReviewCreateManyBarberInputEnvelope = {
    data: ReviewCreateManyBarberInput | ReviewCreateManyBarberInput[];
    skipDuplicates?: boolean;
  };

  export type BarbershopUpsertWithoutBarbersInput = {
    update: XOR<
      BarbershopUpdateWithoutBarbersInput,
      BarbershopUncheckedUpdateWithoutBarbersInput
    >;
    create: XOR<
      BarbershopCreateWithoutBarbersInput,
      BarbershopUncheckedCreateWithoutBarbersInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutBarbersInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutBarbersInput,
      BarbershopUncheckedUpdateWithoutBarbersInput
    >;
  };

  export type BarbershopUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type UserUpsertWithoutBarberInfoInput = {
    update: XOR<
      UserUpdateWithoutBarberInfoInput,
      UserUncheckedUpdateWithoutBarberInfoInput
    >;
    create: XOR<
      UserCreateWithoutBarberInfoInput,
      UserUncheckedCreateWithoutBarberInfoInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutBarberInfoInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutBarberInfoInput,
      UserUncheckedUpdateWithoutBarberInfoInput
    >;
  };

  export type UserUpdateWithoutBarberInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneWithoutUsersNestedInput;
    queues?: QueueUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutBarberInfoInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    queues?: QueueUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput;
  };

  export type BarberServiceUpsertWithWhereUniqueWithoutBarberInput = {
    where: BarberServiceWhereUniqueInput;
    update: XOR<
      BarberServiceUpdateWithoutBarberInput,
      BarberServiceUncheckedUpdateWithoutBarberInput
    >;
    create: XOR<
      BarberServiceCreateWithoutBarberInput,
      BarberServiceUncheckedCreateWithoutBarberInput
    >;
  };

  export type BarberServiceUpdateWithWhereUniqueWithoutBarberInput = {
    where: BarberServiceWhereUniqueInput;
    data: XOR<
      BarberServiceUpdateWithoutBarberInput,
      BarberServiceUncheckedUpdateWithoutBarberInput
    >;
  };

  export type BarberServiceUpdateManyWithWhereWithoutBarberInput = {
    where: BarberServiceScalarWhereInput;
    data: XOR<
      BarberServiceUpdateManyMutationInput,
      BarberServiceUncheckedUpdateManyWithoutBarberInput
    >;
  };

  export type BarberServiceScalarWhereInput = {
    AND?: BarberServiceScalarWhereInput | BarberServiceScalarWhereInput[];
    OR?: BarberServiceScalarWhereInput[];
    NOT?: BarberServiceScalarWhereInput | BarberServiceScalarWhereInput[];
    barberId?: StringFilter<'BarberService'> | string;
    serviceId?: StringFilter<'BarberService'> | string;
    customDurationMinutes?: IntNullableFilter<'BarberService'> | number | null;
  };

  export type BarberScheduleUpsertWithWhereUniqueWithoutBarberInput = {
    where: BarberScheduleWhereUniqueInput;
    update: XOR<
      BarberScheduleUpdateWithoutBarberInput,
      BarberScheduleUncheckedUpdateWithoutBarberInput
    >;
    create: XOR<
      BarberScheduleCreateWithoutBarberInput,
      BarberScheduleUncheckedCreateWithoutBarberInput
    >;
  };

  export type BarberScheduleUpdateWithWhereUniqueWithoutBarberInput = {
    where: BarberScheduleWhereUniqueInput;
    data: XOR<
      BarberScheduleUpdateWithoutBarberInput,
      BarberScheduleUncheckedUpdateWithoutBarberInput
    >;
  };

  export type BarberScheduleUpdateManyWithWhereWithoutBarberInput = {
    where: BarberScheduleScalarWhereInput;
    data: XOR<
      BarberScheduleUpdateManyMutationInput,
      BarberScheduleUncheckedUpdateManyWithoutBarberInput
    >;
  };

  export type BarberScheduleScalarWhereInput = {
    AND?: BarberScheduleScalarWhereInput | BarberScheduleScalarWhereInput[];
    OR?: BarberScheduleScalarWhereInput[];
    NOT?: BarberScheduleScalarWhereInput | BarberScheduleScalarWhereInput[];
    id?: StringFilter<'BarberSchedule'> | string;
    barberId?: StringFilter<'BarberSchedule'> | string;
    dayOfWeek?: IntFilter<'BarberSchedule'> | number;
    startTime?: StringFilter<'BarberSchedule'> | string;
    endTime?: StringFilter<'BarberSchedule'> | string;
    isActive?: BoolFilter<'BarberSchedule'> | boolean;
  };

  export type QueueUpsertWithWhereUniqueWithoutBarberInput = {
    where: QueueWhereUniqueInput;
    update: XOR<
      QueueUpdateWithoutBarberInput,
      QueueUncheckedUpdateWithoutBarberInput
    >;
    create: XOR<
      QueueCreateWithoutBarberInput,
      QueueUncheckedCreateWithoutBarberInput
    >;
  };

  export type QueueUpdateWithWhereUniqueWithoutBarberInput = {
    where: QueueWhereUniqueInput;
    data: XOR<
      QueueUpdateWithoutBarberInput,
      QueueUncheckedUpdateWithoutBarberInput
    >;
  };

  export type QueueUpdateManyWithWhereWithoutBarberInput = {
    where: QueueScalarWhereInput;
    data: XOR<
      QueueUpdateManyMutationInput,
      QueueUncheckedUpdateManyWithoutBarberInput
    >;
  };

  export type ReviewUpsertWithWhereUniqueWithoutBarberInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutBarberInput,
      ReviewUncheckedUpdateWithoutBarberInput
    >;
    create: XOR<
      ReviewCreateWithoutBarberInput,
      ReviewUncheckedCreateWithoutBarberInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutBarberInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutBarberInput,
      ReviewUncheckedUpdateWithoutBarberInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutBarberInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutBarberInput
    >;
  };

  export type BarbershopCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutServicesInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutServicesInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutServicesInput,
      BarbershopUncheckedCreateWithoutServicesInput
    >;
  };

  export type BarberServiceCreateWithoutServiceInput = {
    customDurationMinutes?: number | null;
    barber: BarberCreateNestedOneWithoutServicesInput;
  };

  export type BarberServiceUncheckedCreateWithoutServiceInput = {
    barberId: string;
    customDurationMinutes?: number | null;
  };

  export type BarberServiceCreateOrConnectWithoutServiceInput = {
    where: BarberServiceWhereUniqueInput;
    create: XOR<
      BarberServiceCreateWithoutServiceInput,
      BarberServiceUncheckedCreateWithoutServiceInput
    >;
  };

  export type BarberServiceCreateManyServiceInputEnvelope = {
    data:
      | BarberServiceCreateManyServiceInput
      | BarberServiceCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type QueueCreateWithoutServiceInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutServiceInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutServiceInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutServiceInput,
      QueueUncheckedCreateWithoutServiceInput
    >;
  };

  export type QueueCreateManyServiceInputEnvelope = {
    data: QueueCreateManyServiceInput | QueueCreateManyServiceInput[];
    skipDuplicates?: boolean;
  };

  export type BarbershopUpsertWithoutServicesInput = {
    update: XOR<
      BarbershopUpdateWithoutServicesInput,
      BarbershopUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      BarbershopCreateWithoutServicesInput,
      BarbershopUncheckedCreateWithoutServicesInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutServicesInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutServicesInput,
      BarbershopUncheckedUpdateWithoutServicesInput
    >;
  };

  export type BarbershopUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarberServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: BarberServiceWhereUniqueInput;
    update: XOR<
      BarberServiceUpdateWithoutServiceInput,
      BarberServiceUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      BarberServiceCreateWithoutServiceInput,
      BarberServiceUncheckedCreateWithoutServiceInput
    >;
  };

  export type BarberServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: BarberServiceWhereUniqueInput;
    data: XOR<
      BarberServiceUpdateWithoutServiceInput,
      BarberServiceUncheckedUpdateWithoutServiceInput
    >;
  };

  export type BarberServiceUpdateManyWithWhereWithoutServiceInput = {
    where: BarberServiceScalarWhereInput;
    data: XOR<
      BarberServiceUpdateManyMutationInput,
      BarberServiceUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type QueueUpsertWithWhereUniqueWithoutServiceInput = {
    where: QueueWhereUniqueInput;
    update: XOR<
      QueueUpdateWithoutServiceInput,
      QueueUncheckedUpdateWithoutServiceInput
    >;
    create: XOR<
      QueueCreateWithoutServiceInput,
      QueueUncheckedCreateWithoutServiceInput
    >;
  };

  export type QueueUpdateWithWhereUniqueWithoutServiceInput = {
    where: QueueWhereUniqueInput;
    data: XOR<
      QueueUpdateWithoutServiceInput,
      QueueUncheckedUpdateWithoutServiceInput
    >;
  };

  export type QueueUpdateManyWithWhereWithoutServiceInput = {
    where: QueueScalarWhereInput;
    data: XOR<
      QueueUpdateManyMutationInput,
      QueueUncheckedUpdateManyWithoutServiceInput
    >;
  };

  export type BarberCreateWithoutServicesInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutServicesInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutServicesInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutServicesInput,
      BarberUncheckedCreateWithoutServicesInput
    >;
  };

  export type ServiceCreateWithoutBarbersInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutServicesInput;
    queues?: QueueCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutBarbersInput = {
    id?: string;
    barbershopId: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    queues?: QueueUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutBarbersInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutBarbersInput,
      ServiceUncheckedCreateWithoutBarbersInput
    >;
  };

  export type BarberUpsertWithoutServicesInput = {
    update: XOR<
      BarberUpdateWithoutServicesInput,
      BarberUncheckedUpdateWithoutServicesInput
    >;
    create: XOR<
      BarberCreateWithoutServicesInput,
      BarberUncheckedCreateWithoutServicesInput
    >;
    where?: BarberWhereInput;
  };

  export type BarberUpdateToOneWithWhereWithoutServicesInput = {
    where?: BarberWhereInput;
    data: XOR<
      BarberUpdateWithoutServicesInput,
      BarberUncheckedUpdateWithoutServicesInput
    >;
  };

  export type BarberUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type ServiceUpsertWithoutBarbersInput = {
    update: XOR<
      ServiceUpdateWithoutBarbersInput,
      ServiceUncheckedUpdateWithoutBarbersInput
    >;
    create: XOR<
      ServiceCreateWithoutBarbersInput,
      ServiceUncheckedCreateWithoutBarbersInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutBarbersInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutBarbersInput,
      ServiceUncheckedUpdateWithoutBarbersInput
    >;
  };

  export type ServiceUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutServicesNestedInput;
    queues?: QueueUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutBarbersInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    queues?: QueueUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type BarbershopCreateWithoutQueuesInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutQueuesInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutQueuesInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutQueuesInput,
      BarbershopUncheckedCreateWithoutQueuesInput
    >;
  };

  export type BarberCreateWithoutQueuesInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutQueuesInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutQueuesInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutQueuesInput,
      BarberUncheckedCreateWithoutQueuesInput
    >;
  };

  export type UserCreateWithoutQueuesInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop?: BarbershopCreateNestedOneWithoutUsersInput;
    barberInfo?: BarberCreateNestedOneWithoutUserInput;
    reviews?: ReviewCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryCreateNestedManyWithoutChangedByInput;
  };

  export type UserUncheckedCreateWithoutQueuesInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberUncheckedCreateNestedOneWithoutUserInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput;
  };

  export type UserCreateOrConnectWithoutQueuesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutQueuesInput,
      UserUncheckedCreateWithoutQueuesInput
    >;
  };

  export type ServiceCreateWithoutQueuesInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutServicesInput;
    barbers?: BarberServiceCreateNestedManyWithoutServiceInput;
  };

  export type ServiceUncheckedCreateWithoutQueuesInput = {
    id?: string;
    barbershopId: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbers?: BarberServiceUncheckedCreateNestedManyWithoutServiceInput;
  };

  export type ServiceCreateOrConnectWithoutQueuesInput = {
    where: ServiceWhereUniqueInput;
    create: XOR<
      ServiceCreateWithoutQueuesInput,
      ServiceUncheckedCreateWithoutQueuesInput
    >;
  };

  export type QueueHistoryCreateWithoutQueueInput = {
    id?: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    notes?: string | null;
    createdAt?: Date | string;
    changedBy?: UserCreateNestedOneWithoutChangedLogsInput;
  };

  export type QueueHistoryUncheckedCreateWithoutQueueInput = {
    id?: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    changedById?: string | null;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryCreateOrConnectWithoutQueueInput = {
    where: QueueHistoryWhereUniqueInput;
    create: XOR<
      QueueHistoryCreateWithoutQueueInput,
      QueueHistoryUncheckedCreateWithoutQueueInput
    >;
  };

  export type QueueHistoryCreateManyQueueInputEnvelope = {
    data: QueueHistoryCreateManyQueueInput | QueueHistoryCreateManyQueueInput[];
    skipDuplicates?: boolean;
  };

  export type ReviewCreateWithoutQueueInput = {
    id?: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
    barbershop: BarbershopCreateNestedOneWithoutReviewsInput;
    barber?: BarberCreateNestedOneWithoutReviewsInput;
    customer: UserCreateNestedOneWithoutReviewsInput;
  };

  export type ReviewUncheckedCreateWithoutQueueInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewCreateOrConnectWithoutQueueInput = {
    where: ReviewWhereUniqueInput;
    create: XOR<
      ReviewCreateWithoutQueueInput,
      ReviewUncheckedCreateWithoutQueueInput
    >;
  };

  export type ReviewCreateManyQueueInputEnvelope = {
    data: ReviewCreateManyQueueInput | ReviewCreateManyQueueInput[];
    skipDuplicates?: boolean;
  };

  export type BarbershopUpsertWithoutQueuesInput = {
    update: XOR<
      BarbershopUpdateWithoutQueuesInput,
      BarbershopUncheckedUpdateWithoutQueuesInput
    >;
    create: XOR<
      BarbershopCreateWithoutQueuesInput,
      BarbershopUncheckedCreateWithoutQueuesInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutQueuesInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutQueuesInput,
      BarbershopUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type BarbershopUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarberUpsertWithoutQueuesInput = {
    update: XOR<
      BarberUpdateWithoutQueuesInput,
      BarberUncheckedUpdateWithoutQueuesInput
    >;
    create: XOR<
      BarberCreateWithoutQueuesInput,
      BarberUncheckedCreateWithoutQueuesInput
    >;
    where?: BarberWhereInput;
  };

  export type BarberUpdateToOneWithWhereWithoutQueuesInput = {
    where?: BarberWhereInput;
    data: XOR<
      BarberUpdateWithoutQueuesInput,
      BarberUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type BarberUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type UserUpsertWithoutQueuesInput = {
    update: XOR<
      UserUpdateWithoutQueuesInput,
      UserUncheckedUpdateWithoutQueuesInput
    >;
    create: XOR<
      UserCreateWithoutQueuesInput,
      UserUncheckedCreateWithoutQueuesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutQueuesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutQueuesInput,
      UserUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type UserUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneWithoutUsersNestedInput;
    barberInfo?: BarberUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUncheckedUpdateOneWithoutUserNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput;
  };

  export type ServiceUpsertWithoutQueuesInput = {
    update: XOR<
      ServiceUpdateWithoutQueuesInput,
      ServiceUncheckedUpdateWithoutQueuesInput
    >;
    create: XOR<
      ServiceCreateWithoutQueuesInput,
      ServiceUncheckedCreateWithoutQueuesInput
    >;
    where?: ServiceWhereInput;
  };

  export type ServiceUpdateToOneWithWhereWithoutQueuesInput = {
    where?: ServiceWhereInput;
    data: XOR<
      ServiceUpdateWithoutQueuesInput,
      ServiceUncheckedUpdateWithoutQueuesInput
    >;
  };

  export type ServiceUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutServicesNestedInput;
    barbers?: BarberServiceUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutQueuesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberServiceUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type QueueHistoryUpsertWithWhereUniqueWithoutQueueInput = {
    where: QueueHistoryWhereUniqueInput;
    update: XOR<
      QueueHistoryUpdateWithoutQueueInput,
      QueueHistoryUncheckedUpdateWithoutQueueInput
    >;
    create: XOR<
      QueueHistoryCreateWithoutQueueInput,
      QueueHistoryUncheckedCreateWithoutQueueInput
    >;
  };

  export type QueueHistoryUpdateWithWhereUniqueWithoutQueueInput = {
    where: QueueHistoryWhereUniqueInput;
    data: XOR<
      QueueHistoryUpdateWithoutQueueInput,
      QueueHistoryUncheckedUpdateWithoutQueueInput
    >;
  };

  export type QueueHistoryUpdateManyWithWhereWithoutQueueInput = {
    where: QueueHistoryScalarWhereInput;
    data: XOR<
      QueueHistoryUpdateManyMutationInput,
      QueueHistoryUncheckedUpdateManyWithoutQueueInput
    >;
  };

  export type ReviewUpsertWithWhereUniqueWithoutQueueInput = {
    where: ReviewWhereUniqueInput;
    update: XOR<
      ReviewUpdateWithoutQueueInput,
      ReviewUncheckedUpdateWithoutQueueInput
    >;
    create: XOR<
      ReviewCreateWithoutQueueInput,
      ReviewUncheckedCreateWithoutQueueInput
    >;
  };

  export type ReviewUpdateWithWhereUniqueWithoutQueueInput = {
    where: ReviewWhereUniqueInput;
    data: XOR<
      ReviewUpdateWithoutQueueInput,
      ReviewUncheckedUpdateWithoutQueueInput
    >;
  };

  export type ReviewUpdateManyWithWhereWithoutQueueInput = {
    where: ReviewScalarWhereInput;
    data: XOR<
      ReviewUpdateManyMutationInput,
      ReviewUncheckedUpdateManyWithoutQueueInput
    >;
  };

  export type QueueCreateWithoutHistoryInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    reviews?: ReviewCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutHistoryInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    reviews?: ReviewUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutHistoryInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutHistoryInput,
      QueueUncheckedCreateWithoutHistoryInput
    >;
  };

  export type UserCreateWithoutChangedLogsInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop?: BarbershopCreateNestedOneWithoutUsersInput;
    barberInfo?: BarberCreateNestedOneWithoutUserInput;
    queues?: QueueCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewCreateNestedManyWithoutCustomerInput;
  };

  export type UserUncheckedCreateWithoutChangedLogsInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberUncheckedCreateNestedOneWithoutUserInput;
    queues?: QueueUncheckedCreateNestedManyWithoutCustomerInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutCustomerInput;
  };

  export type UserCreateOrConnectWithoutChangedLogsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutChangedLogsInput,
      UserUncheckedCreateWithoutChangedLogsInput
    >;
  };

  export type QueueUpsertWithoutHistoryInput = {
    update: XOR<
      QueueUpdateWithoutHistoryInput,
      QueueUncheckedUpdateWithoutHistoryInput
    >;
    create: XOR<
      QueueCreateWithoutHistoryInput,
      QueueUncheckedCreateWithoutHistoryInput
    >;
    where?: QueueWhereInput;
  };

  export type QueueUpdateToOneWithWhereWithoutHistoryInput = {
    where?: QueueWhereInput;
    data: XOR<
      QueueUpdateWithoutHistoryInput,
      QueueUncheckedUpdateWithoutHistoryInput
    >;
  };

  export type QueueUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type UserUpsertWithoutChangedLogsInput = {
    update: XOR<
      UserUpdateWithoutChangedLogsInput,
      UserUncheckedUpdateWithoutChangedLogsInput
    >;
    create: XOR<
      UserCreateWithoutChangedLogsInput,
      UserUncheckedCreateWithoutChangedLogsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutChangedLogsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutChangedLogsInput,
      UserUncheckedUpdateWithoutChangedLogsInput
    >;
  };

  export type UserUpdateWithoutChangedLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneWithoutUsersNestedInput;
    barberInfo?: BarberUpdateOneWithoutUserNestedInput;
    queues?: QueueUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput;
  };

  export type UserUncheckedUpdateWithoutChangedLogsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUncheckedUpdateOneWithoutUserNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput;
  };

  export type BarbershopCreateWithoutReviewsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutReviewsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutReviewsInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutReviewsInput,
      BarbershopUncheckedCreateWithoutReviewsInput
    >;
  };

  export type BarberCreateWithoutReviewsInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutReviewsInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    schedules?: BarberScheduleUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutReviewsInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutReviewsInput,
      BarberUncheckedCreateWithoutReviewsInput
    >;
  };

  export type UserCreateWithoutReviewsInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop?: BarbershopCreateNestedOneWithoutUsersInput;
    barberInfo?: BarberCreateNestedOneWithoutUserInput;
    queues?: QueueCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryCreateNestedManyWithoutChangedByInput;
  };

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string;
    barbershopId?: string | null;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barberInfo?: BarberUncheckedCreateNestedOneWithoutUserInput;
    queues?: QueueUncheckedCreateNestedManyWithoutCustomerInput;
    changedLogs?: QueueHistoryUncheckedCreateNestedManyWithoutChangedByInput;
  };

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
  };

  export type QueueCreateWithoutReviewsInput = {
    id?: string;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutQueuesInput;
    barber?: BarberCreateNestedOneWithoutQueuesInput;
    customer?: UserCreateNestedOneWithoutQueuesInput;
    service: ServiceCreateNestedOneWithoutQueuesInput;
    history?: QueueHistoryCreateNestedManyWithoutQueueInput;
  };

  export type QueueUncheckedCreateWithoutReviewsInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    history?: QueueHistoryUncheckedCreateNestedManyWithoutQueueInput;
  };

  export type QueueCreateOrConnectWithoutReviewsInput = {
    where: QueueWhereUniqueInput;
    create: XOR<
      QueueCreateWithoutReviewsInput,
      QueueUncheckedCreateWithoutReviewsInput
    >;
  };

  export type BarbershopUpsertWithoutReviewsInput = {
    update: XOR<
      BarbershopUpdateWithoutReviewsInput,
      BarbershopUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      BarbershopCreateWithoutReviewsInput,
      BarbershopUncheckedCreateWithoutReviewsInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutReviewsInput,
      BarbershopUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type BarbershopUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarberUpsertWithoutReviewsInput = {
    update: XOR<
      BarberUpdateWithoutReviewsInput,
      BarberUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      BarberCreateWithoutReviewsInput,
      BarberUncheckedCreateWithoutReviewsInput
    >;
    where?: BarberWhereInput;
  };

  export type BarberUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BarberWhereInput;
    data: XOR<
      BarberUpdateWithoutReviewsInput,
      BarberUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type BarberUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<
      UserUpdateWithoutReviewsInput,
      UserUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      UserCreateWithoutReviewsInput,
      UserUncheckedCreateWithoutReviewsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutReviewsInput,
      UserUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneWithoutUsersNestedInput;
    barberInfo?: BarberUpdateOneWithoutUserNestedInput;
    queues?: QueueUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: NullableStringFieldUpdateOperationsInput | string | null;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUncheckedUpdateOneWithoutUserNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput;
  };

  export type QueueUpsertWithoutReviewsInput = {
    update: XOR<
      QueueUpdateWithoutReviewsInput,
      QueueUncheckedUpdateWithoutReviewsInput
    >;
    create: XOR<
      QueueCreateWithoutReviewsInput,
      QueueUncheckedCreateWithoutReviewsInput
    >;
    where?: QueueWhereInput;
  };

  export type QueueUpdateToOneWithWhereWithoutReviewsInput = {
    where?: QueueWhereInput;
    data: XOR<
      QueueUpdateWithoutReviewsInput,
      QueueUncheckedUpdateWithoutReviewsInput
    >;
  };

  export type QueueUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type BarberCreateWithoutSchedulesInput = {
    id?: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    barbershop: BarbershopCreateNestedOneWithoutBarbersInput;
    user: UserCreateNestedOneWithoutBarberInfoInput;
    services?: BarberServiceCreateNestedManyWithoutBarberInput;
    queues?: QueueCreateNestedManyWithoutBarberInput;
    reviews?: ReviewCreateNestedManyWithoutBarberInput;
  };

  export type BarberUncheckedCreateWithoutSchedulesInput = {
    id?: string;
    barbershopId: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    services?: BarberServiceUncheckedCreateNestedManyWithoutBarberInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarberInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarberInput;
  };

  export type BarberCreateOrConnectWithoutSchedulesInput = {
    where: BarberWhereUniqueInput;
    create: XOR<
      BarberCreateWithoutSchedulesInput,
      BarberUncheckedCreateWithoutSchedulesInput
    >;
  };

  export type BarberUpsertWithoutSchedulesInput = {
    update: XOR<
      BarberUpdateWithoutSchedulesInput,
      BarberUncheckedUpdateWithoutSchedulesInput
    >;
    create: XOR<
      BarberCreateWithoutSchedulesInput,
      BarberUncheckedCreateWithoutSchedulesInput
    >;
    where?: BarberWhereInput;
  };

  export type BarberUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: BarberWhereInput;
    data: XOR<
      BarberUpdateWithoutSchedulesInput,
      BarberUncheckedUpdateWithoutSchedulesInput
    >;
  };

  export type BarberUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutBarbersNestedInput;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type BarbershopCreateWithoutSubscriptionsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutSubscriptionsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
    analytics?: AnalyticsDailyUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutSubscriptionsInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutSubscriptionsInput,
      BarbershopUncheckedCreateWithoutSubscriptionsInput
    >;
  };

  export type BarbershopUpsertWithoutSubscriptionsInput = {
    update: XOR<
      BarbershopUpdateWithoutSubscriptionsInput,
      BarbershopUncheckedUpdateWithoutSubscriptionsInput
    >;
    create: XOR<
      BarbershopCreateWithoutSubscriptionsInput,
      BarbershopUncheckedCreateWithoutSubscriptionsInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutSubscriptionsInput,
      BarbershopUncheckedUpdateWithoutSubscriptionsInput
    >;
  };

  export type BarbershopUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
    analytics?: AnalyticsDailyUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopCreateWithoutAnalyticsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberCreateNestedManyWithoutBarbershopInput;
    services?: ServiceCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionCreateNestedManyWithoutBarbershopInput;
    queues?: QueueCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopUncheckedCreateWithoutAnalyticsInput = {
    id?: string;
    name: string;
    slug: string;
    address?: string | null;
    logoUrl?: string | null;
    timezone?: string;
    subscriptionStatus?: $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
    users?: UserUncheckedCreateNestedManyWithoutBarbershopInput;
    barbers?: BarberUncheckedCreateNestedManyWithoutBarbershopInput;
    services?: ServiceUncheckedCreateNestedManyWithoutBarbershopInput;
    subscriptions?: BarbershopSubscriptionUncheckedCreateNestedManyWithoutBarbershopInput;
    queues?: QueueUncheckedCreateNestedManyWithoutBarbershopInput;
    reviews?: ReviewUncheckedCreateNestedManyWithoutBarbershopInput;
  };

  export type BarbershopCreateOrConnectWithoutAnalyticsInput = {
    where: BarbershopWhereUniqueInput;
    create: XOR<
      BarbershopCreateWithoutAnalyticsInput,
      BarbershopUncheckedCreateWithoutAnalyticsInput
    >;
  };

  export type BarbershopUpsertWithoutAnalyticsInput = {
    update: XOR<
      BarbershopUpdateWithoutAnalyticsInput,
      BarbershopUncheckedUpdateWithoutAnalyticsInput
    >;
    create: XOR<
      BarbershopCreateWithoutAnalyticsInput,
      BarbershopUncheckedCreateWithoutAnalyticsInput
    >;
    where?: BarbershopWhereInput;
  };

  export type BarbershopUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: BarbershopWhereInput;
    data: XOR<
      BarbershopUpdateWithoutAnalyticsInput,
      BarbershopUncheckedUpdateWithoutAnalyticsInput
    >;
  };

  export type BarbershopUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUpdateManyWithoutBarbershopNestedInput;
  };

  export type BarbershopUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    slug?: StringFieldUpdateOperationsInput | string;
    address?: NullableStringFieldUpdateOperationsInput | string | null;
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    timezone?: StringFieldUpdateOperationsInput | string;
    subscriptionStatus?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    settings?: JsonNullValueInput | InputJsonValue;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    users?: UserUncheckedUpdateManyWithoutBarbershopNestedInput;
    barbers?: BarberUncheckedUpdateManyWithoutBarbershopNestedInput;
    services?: ServiceUncheckedUpdateManyWithoutBarbershopNestedInput;
    subscriptions?: BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarbershopNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarbershopNestedInput;
  };

  export type UserCreateManyBarbershopInput = {
    id?: string;
    fullName: string;
    email: string;
    phoneNumber: string;
    passwordHash: string;
    role: $Enums.UserRole;
    fcmToken?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type BarberCreateManyBarbershopInput = {
    id?: string;
    userId: string;
    displayName?: string | null;
    specialization?: string | null;
    status?: $Enums.BarberStatus;
    commissionRate?: number | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ServiceCreateManyBarbershopInput = {
    id?: string;
    name: string;
    description?: string | null;
    durationMinutes: number;
    price: number;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type BarbershopSubscriptionCreateManyBarbershopInput = {
    id?: string;
    planId: string;
    status?: $Enums.SubscriptionStatus;
    startDate?: Date | string;
    endDate: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type QueueCreateManyBarbershopInput = {
    id?: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ReviewCreateManyBarbershopInput = {
    id?: string;
    barberId?: string | null;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type AnalyticsDailyCreateManyBarbershopInput = {
    id?: string;
    date: Date | string;
    totalQueues?: number;
    totalRevenue?: number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type UserUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUpdateOneWithoutUserNestedInput;
    queues?: QueueUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barberInfo?: BarberUncheckedUpdateOneWithoutUserNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutCustomerNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutCustomerNestedInput;
    changedLogs?: QueueHistoryUncheckedUpdateManyWithoutChangedByNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    fullName?: StringFieldUpdateOperationsInput | string;
    email?: StringFieldUpdateOperationsInput | string;
    phoneNumber?: StringFieldUpdateOperationsInput | string;
    passwordHash?: StringFieldUpdateOperationsInput | string;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarberUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    user?: UserUpdateOneRequiredWithoutBarberInfoNestedInput;
    services?: BarberServiceUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUpdateManyWithoutBarberNestedInput;
    queues?: QueueUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    services?: BarberServiceUncheckedUpdateManyWithoutBarberNestedInput;
    schedules?: BarberScheduleUncheckedUpdateManyWithoutBarberNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutBarberNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutBarberNestedInput;
  };

  export type BarberUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    displayName?: NullableStringFieldUpdateOperationsInput | string | null;
    specialization?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumBarberStatusFieldUpdateOperationsInput | $Enums.BarberStatus;
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ServiceUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberServiceUpdateManyWithoutServiceNestedInput;
    queues?: QueueUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbers?: BarberServiceUncheckedUpdateManyWithoutServiceNestedInput;
    queues?: QueueUncheckedUpdateManyWithoutServiceNestedInput;
  };

  export type ServiceUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    durationMinutes?: IntFieldUpdateOperationsInput | number;
    price?: FloatFieldUpdateOperationsInput | number;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type BarbershopSubscriptionUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarbershopSubscriptionUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    planId?: StringFieldUpdateOperationsInput | string;
    status?:
      | EnumSubscriptionStatusFieldUpdateOperationsInput
      | $Enums.SubscriptionStatus;
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarbershopSubscriptionUncheckedUpdateManyWithoutBarbershopInput =
    {
      id?: StringFieldUpdateOperationsInput | string;
      planId?: StringFieldUpdateOperationsInput | string;
      status?:
        | EnumSubscriptionStatusFieldUpdateOperationsInput
        | $Enums.SubscriptionStatus;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    };

  export type QueueUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ReviewUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barber?: BarberUpdateOneWithoutReviewsNestedInput;
    customer?: UserUpdateOneRequiredWithoutReviewsNestedInput;
    queue?: QueueUpdateOneWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnalyticsDailyUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUncheckedUpdateWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type AnalyticsDailyUncheckedUpdateManyWithoutBarbershopInput = {
    id?: StringFieldUpdateOperationsInput | string;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    totalQueues?: IntFieldUpdateOperationsInput | number;
    totalRevenue?: FloatFieldUpdateOperationsInput | number;
    data?: JsonNullValueInput | InputJsonValue;
  };

  export type QueueCreateManyCustomerInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ReviewCreateManyCustomerInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryCreateManyChangedByInput = {
    id?: string;
    queueId: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type QueueUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ReviewUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barbershop?: BarbershopUpdateOneRequiredWithoutReviewsNestedInput;
    barber?: BarberUpdateOneWithoutReviewsNestedInput;
    queue?: QueueUpdateOneWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type QueueHistoryUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    queue?: QueueUpdateOneRequiredWithoutHistoryNestedInput;
  };

  export type QueueHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    queueId?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type QueueHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: StringFieldUpdateOperationsInput | string;
    queueId?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarberServiceCreateManyBarberInput = {
    serviceId: string;
    customDurationMinutes?: number | null;
  };

  export type BarberScheduleCreateManyBarberInput = {
    id?: string;
    dayOfWeek: number;
    startTime: string;
    endTime: string;
    isActive?: boolean;
  };

  export type QueueCreateManyBarberInput = {
    id?: string;
    barbershopId: string;
    customerId?: string | null;
    guestName?: string | null;
    serviceId: string;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type ReviewCreateManyBarberInput = {
    id?: string;
    barbershopId: string;
    customerId: string;
    queueId?: string | null;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type BarberServiceUpdateWithoutBarberInput = {
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    service?: ServiceUpdateOneRequiredWithoutBarbersNestedInput;
  };

  export type BarberServiceUncheckedUpdateWithoutBarberInput = {
    serviceId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type BarberServiceUncheckedUpdateManyWithoutBarberInput = {
    serviceId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type BarberScheduleUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type BarberScheduleUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type BarberScheduleUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    dayOfWeek?: IntFieldUpdateOperationsInput | number;
    startTime?: StringFieldUpdateOperationsInput | string;
    endTime?: StringFieldUpdateOperationsInput | string;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type QueueUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    service?: ServiceUpdateOneRequiredWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    serviceId?: StringFieldUpdateOperationsInput | string;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type ReviewUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barbershop?: BarbershopUpdateOneRequiredWithoutReviewsNestedInput;
    customer?: UserUpdateOneRequiredWithoutReviewsNestedInput;
    queue?: QueueUpdateOneWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutBarberInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    customerId?: StringFieldUpdateOperationsInput | string;
    queueId?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type BarberServiceCreateManyServiceInput = {
    barberId: string;
    customDurationMinutes?: number | null;
  };

  export type QueueCreateManyServiceInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId?: string | null;
    guestName?: string | null;
    status?: $Enums.QueueStatus;
    bookingSource?: string;
    scheduledTime?: Date | string | null;
    estimatedStartTime?: Date | string | null;
    estimatedEndTime?: Date | string | null;
    actualStartTime?: Date | string | null;
    actualEndTime?: Date | string | null;
    notified30m?: boolean;
    notified15m?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    deletedAt?: Date | string | null;
  };

  export type BarberServiceUpdateWithoutServiceInput = {
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
    barber?: BarberUpdateOneRequiredWithoutServicesNestedInput;
  };

  export type BarberServiceUncheckedUpdateWithoutServiceInput = {
    barberId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type BarberServiceUncheckedUpdateManyWithoutServiceInput = {
    barberId?: StringFieldUpdateOperationsInput | string;
    customDurationMinutes?:
      | NullableIntFieldUpdateOperationsInput
      | number
      | null;
  };

  export type QueueUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    barbershop?: BarbershopUpdateOneRequiredWithoutQueuesNestedInput;
    barber?: BarberUpdateOneWithoutQueuesNestedInput;
    customer?: UserUpdateOneWithoutQueuesNestedInput;
    history?: QueueHistoryUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    history?: QueueHistoryUncheckedUpdateManyWithoutQueueNestedInput;
    reviews?: ReviewUncheckedUpdateManyWithoutQueueNestedInput;
  };

  export type QueueUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: NullableStringFieldUpdateOperationsInput | string | null;
    guestName?: NullableStringFieldUpdateOperationsInput | string | null;
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    bookingSource?: StringFieldUpdateOperationsInput | string;
    scheduledTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    estimatedEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualStartTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    actualEndTime?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    notified30m?: BoolFieldUpdateOperationsInput | boolean;
    notified15m?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    deletedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
  };

  export type QueueHistoryCreateManyQueueInput = {
    id?: string;
    previousStatus?: $Enums.QueueStatus | null;
    newStatus: $Enums.QueueStatus;
    changedById?: string | null;
    notes?: string | null;
    createdAt?: Date | string;
  };

  export type ReviewCreateManyQueueInput = {
    id?: string;
    barbershopId: string;
    barberId?: string | null;
    customerId: string;
    rating: number;
    comment?: string | null;
    createdAt?: Date | string;
  };

  export type QueueHistoryUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    changedBy?: UserUpdateOneWithoutChangedLogsNestedInput;
  };

  export type QueueHistoryUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    changedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type QueueHistoryUncheckedUpdateManyWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    previousStatus?:
      | NullableEnumQueueStatusFieldUpdateOperationsInput
      | $Enums.QueueStatus
      | null;
    newStatus?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus;
    changedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    barbershop?: BarbershopUpdateOneRequiredWithoutReviewsNestedInput;
    barber?: BarberUpdateOneWithoutReviewsNestedInput;
    customer?: UserUpdateOneRequiredWithoutReviewsNestedInput;
  };

  export type ReviewUncheckedUpdateWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ReviewUncheckedUpdateManyWithoutQueueInput = {
    id?: StringFieldUpdateOperationsInput | string;
    barbershopId?: StringFieldUpdateOperationsInput | string;
    barberId?: NullableStringFieldUpdateOperationsInput | string | null;
    customerId?: StringFieldUpdateOperationsInput | string;
    rating?: IntFieldUpdateOperationsInput | number;
    comment?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
